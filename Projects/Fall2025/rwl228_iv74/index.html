<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, shrink-to-fit=no">
<link href="assets/images/favicon.png" rel="icon" />
<title>Final Report | Project Documentation</title>
<meta name="description" content="Final report documentation template">
<meta name="author" content="harnishdesign.net">

<!-- Stylesheet
============================== -->
<!-- Bootstrap -->
<link rel="stylesheet" type="text/css" href="assets/vendor/bootstrap/css/bootstrap.min.css" />
<!-- Font Awesome Icon -->
<link rel="stylesheet" type="text/css" href="assets/vendor/font-awesome/css/all.min.css" />
<!-- Magnific Popup -->
<link rel="stylesheet" type="text/css" href="assets/vendor/magnific-popup/magnific-popup.min.css" />
<!-- Highlight Syntax -->
<link rel="stylesheet" type="text/css" href="assets/vendor/highlight.js/styles/github.css" />
<!-- Custom Stylesheet -->
<link rel="stylesheet" type="text/css" href="assets/css/stylesheet.css" />
</head>

<body data-spy="scroll" data-target=".idocs-navigation" data-offset="125">

<!-- Preloader -->
<div class="preloader">
  <div class="lds-ellipsis">
    <div></div>
    <div></div>
    <div></div>
    <div></div>
  </div>
</div>
<!-- Preloader End --> 

<!-- Document Wrapper   
=============================== -->
<div id="main-wrapper"> 
  
  <!-- Header
  ============================ -->
  <header id="header" class="sticky-top"> 
    <!-- Navbar -->
    <nav class="primary-menu navbar navbar-expand-lg navbar-dropdown-dark">
      <div class="container-fluid">
        <!-- Sidebar Toggler -->
        <button id="sidebarCollapse" class="navbar-toggler d-block d-md-none" type="button">
          <span></span><span class="w-75"></span><span class="w-50"></span>
        </button>

        <div class="d-flex align-items-center mr-auto">
          <!-- Logo removed; use text instead -->
          <a class="logo ml-md-3" href="index.html" title="ScopeBoy">
            <strong>ScopeBoy</strong>
          </a>
          <span class="text-2 ml-2">v1.0</span>
        </div>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#header-nav">
          <span></span><span></span><span></span>
        </button>

        <!-- <div id="header-nav" class="collapse navbar-collapse justify-content-end">
          <ul class="navbar-nav">
            <li class="dropdown"> <a class="dropdown-toggle" href="#">Dropdown</a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="#">Action</a></li>
                <li class="dropdown"><a class="dropdown-item dropdown-toggle" href="#">Dropdown Action</a>
                  <ul class="dropdown-menu">
                    <li><a class="dropdown-item" href="index.html">Action</a></li>
                    <li><a class="dropdown-item" href="feature-header-dark.html">Another Action</a></li>
                    <li><a class="dropdown-item" href="feature-header-primary.html">Something Else Here</a></li>
                    <li><a class="dropdown-item" href="index-2.html">Another Link</a></li>
                  </ul>
                </li>
                <li><a class="dropdown-item" href="#">Another Action</a>
                <li><a class="dropdown-item" href="#">Something Else Here</a></li>
              </ul>
            </li>
            <li><a target="_blank" href="https://themeforest.net/user/harnishdesign/portfolio?ref=HarnishDesign">Other Template</a></li>
            <li><a target="_blank" href="https://themeforest.net/user/harnishdesign/#contact?ref=HarnishDesign">Support</a></li>
          </ul>
        </div>
        <ul class="social-icons social-icons-sm ml-lg-2 mr-2">
          <li class="social-icons-twitter"><a data-toggle="tooltip" href="http://www.twitter.com/harnishdesign/" target="_blank" title="" data-original-title="Twitter"><i class="fab fa-twitter"></i></a></li>
          <li class="social-icons-facebook"><a data-toggle="tooltip" href="http://www.facebook.com/harnishdesign/" target="_blank" title="" data-original-title="Facebook"><i class="fab fa-facebook-f"></i></a></li>
          <li class="social-icons-dribbble"><a data-toggle="tooltip" href="http://www.dribbble.com/harnishdesign/" target="_blank" title="" data-original-title="Dribbble"><i class="fab fa-dribbble"></i></a></li>
        </ul>
      </div>
    </nav> -->
    <!-- Navbar End --> 
  </header>
  <!-- Header End --> 
  
  <!-- Content
  ============================ -->
  <div id="content" role="main">

  <!-- Sidebar Navigation
  ============================ -->
  <div class="idocs-navigation bg-dark docs-navigation-dark">
    <ul class="nav flex-column">
      <li class="nav-item">
        <a class="nav-link active" href="#report_start">Final Report</a>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#report_intro">Project Introduction</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#report_intro_soundbite">One-sentence sound bite</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_intro_summary">Summary (what you did and why)</a></li>
        </ul>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#report_high_level">High Level Design</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#report_high_level_rationale">Rationale & sources of idea</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_high_level_math">Background math</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_high_level_structure">Logical structure</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_high_level_tradeoffs">Hardware/software tradeoffs</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_high_level_ip">Relevant patents/copyrights/trademarks</a></li>
        </ul>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#report_design">Program / Hardware Design</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#report_design_program">Program details</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_design_hardware">Hardware details</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_design_reuse">Reused code/design</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_design_failed">Things that did not work</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_design_ai">Thorough discussion of AI use</a></li>
        </ul>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#report_results">Results of the Design</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#report_results_data">Test data / traces / waveforms</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_results_speed">Speed of execution</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_results_accuracy">Accuracy</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_results_safety">Safety enforcement</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_results_usability">Usability</a></li>
        </ul>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#report_conclusions">Conclusions</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#report_conclusions_analysis">Expectation vs results / next time</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_conclusions_standards">Applicable standards</a></li>
          <li class="nav-item"><a class="nav-link" href="#report_conclusions_ip">Intellectual property considerations</a></li>
        </ul>
      </li>

      <!-- <li class="nav-item">
        <a class="nav-link" href="#appendix_a">Appendix A (Permissions)</a>
        <ul class="nav flex-column">
          
        </ul>
      </li> -->

      <li class="nav-item">
        <a class="nav-link" href="#appendices">Appendices</a>
        <ul class="nav flex-column">
          <li class="nav-item"><a class="nav-link" href="#appendix_a_permissions">Appendix A: Permissions</a></li>
          <li class="nav-item"><a class="nav-link" href="#appendix_b_code">Appendix B: Program listings</a></li>
          <li class="nav-item"><a class="nav-link" href="#appendix_c_schematics">Appendix C: Schematics</a></li>
          <li class="nav-item"><a class="nav-link" href="#appendix_d_tasks">Appendix D: Team member tasks</a></li>
        </ul>
      </li>

      <li class="nav-item">
        <a class="nav-link" href="#references">References</a>
      </li>
    </ul>
  </div>

  <!-- Docs Content
  ============================ -->
  <div class="idocs-content">
    <div class="container">

      <!-- Start
      ============================ -->
      <section id="report_start">
        <h1>ScopeBoy: Handheld Mixed-Domain Oscilloscope (MDO)</h1>
        <!-- <p class="lead">Replace the placeholder text in each section with your project’s content.</p> -->
        <hr>
        <div class="row">
          <div class="col-sm-6 col-lg-4">
            <ul class="list-unstyled">
              <li><strong>Project:</strong> <span>ScopeBoy: Portable Oscilloscope</span></li>
              <li><strong>Team:</strong> <span>Robbie Leslie, Immanual Koshy</span></li>
            </ul>
          </div>
          <div class="col-sm-6 col-lg-4">
            <ul class="list-unstyled">
              <li><strong>Course:</strong> <span>ECE 5730</span></li>
              <li><strong>Date:</strong> <span>December, 2025</span></li>
            </ul>
          </div>
        </div>
      </section>

      <hr class="divider">

      <!-- Project Introduction
      ============================ -->
      <section id="report_intro">
        <h2>Project Introduction</h2>

        <section id="report_intro_soundbite">
          <p>
            This project builds ScopeBoy, a handheld, dual-core mixed-domain oscilloscope (MDO) on the Raspberry Pi Pico RP2040,
            featuring real-time spectral analysis and gain control.
          </p>
        </section>

        <section id="report_intro_summary">
          <p>
            Using the RP2040 microcontroller, we created a device that samples signals at 500 kSps. It leverages the dual-core
            architecture to separate signal processing (FFT math) from the user interface (drawing waveforms), ensuring a lag-free 60 FPS
            experience.
          </p>

          <h4>Key Features</h4>
          <ul>
            <li><strong>Oscilloscope Mode:</strong> Adjustable timebase (10ms-1s), voltage scale, and live cursors.</li>
            <li><strong>Spectrum Analyzer Mode:</strong> 64-bin real-time FFT with Hanning windowing and peak frequency detection.</li>
            <li><strong>Easter Egg:</strong> A fully playable "Snake" game triggered by a hidden button combo.</li>
          </ul>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              ScopeBoy 3D Render - Assembled Device Concept
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_3d_overall.png"
                alt="ScopeBoy 3D Assembled View" />
          </figure>
        </section>
      </section>

      <h4>Project Demo Video</h4>
      <div class="embed-responsive embed-responsive-16by9">
        <iframe
          class="embed-responsive-item"
          src="https://www.youtube-nocookie.com/embed/MxbmWoJlQEc"
          title="ScopeBoy Demo Video"
          frameborder="0"
          referrerpolicy="strict-origin-when-cross-origin"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
          allowfullscreen>
        </iframe>
      </div>

      

      <hr class="divider">

      <!-- High Level Design
      ============================ -->
      <section id="report_high_level">
        <h2>High Level Design</h2>

        <section id="report_high_level_rationale">
          <h3>Rationale and sources of your project idea</h3>
          <p>
            We wanted a portable, battery-friendly instrument for quickly debugging real-world signals (especially PWM control signals and
            small audio circuits) without needing a bench scope.
          </p>
          <ul>
            <li>
              <strong>Motivation / constraints:</strong> A handheld tool that is fast to deploy for labs, demos, and quick iteration,
              while still providing both time-domain and frequency-domain visibility.
            </li>
            <li>
              <strong>Inspiration:</strong> The Cornell ECE4760/ECE5730 course structure and prior RP2040 oscilloscope projects motivated a
              dual-core approach that keeps the UI responsive while running DSP in parallel.
            </li>
          </ul>
        </section>

        <section id="report_high_level_math">
          <h3>Background math</h3>
          <ul>
            <li>
              <strong>Nyquist-Shannon Sampling Theorem:</strong> With a sampling rate of 500 kSps, the highest measurable frequency
              without aliasing is 250 kHz (the Nyquist frequency).
            </li>
            <li>
              <strong>Discrete Fourier Transform (DFT):</strong> Our <code>computeDFT()</code> converts a block of \(N\) time samples
              into frequency bins:
              <pre><code>X_k = Σ_{n=0}^{N-1} x_n · e^{-j2πkn/N}</code></pre>
              <p>Where:</p>
              <ul>
                <li><code>x_n</code> is the input voltage sample at index <code>n</code>.</li>
                <li><code>X_k</code> is the output spectral component (magnitude and phase) at frequency bin <code>k</code>.</li>
                <li>
                  We compute real/imaginary components and then convert to magnitude, \( |X_k| = \sqrt{Re^2 + Im^2} \), to find peaks.
                </li>
              </ul>
            </li>
            <li>
              <strong>Windowing (Hanning Window):</strong> Because we capture a finite “slice” of a continuous signal, the start and end
              of the sample buffer rarely align perfectly. This discontinuity causes <em>spectral leakage</em>, where energy from one
              frequency bleeds into neighboring bins. We apply a Hanning window before running the FFT/DFT to taper the edges:
              <pre><code>w(n) = 0.5(1 − cos(2πn/(N−1)))</code></pre>
            </li>
          </ul>
        </section>

        <section id="report_high_level_structure">
          <h3>Logical structure</h3>
          <p>
            The system uses an Asymmetric Multiprocessing (AMP) model to ensure the User Interface (UI) never stutters, even when
            performing heavy calculations.
          </p>
          <p>Create a block diagram showing:</p>
          <ul>
            <li>
              <strong>Core 0 (The Application Processor):</strong>
              <ul>
                <li>
                  <strong>Responsibilities:</strong> Handles all User Input (Joystick, Buttons, Rotary Encoder), manages the Trigger Logic
                  (detecting rising/falling edges), and drives the SPI TFT Display.
                </li>
                <li>
                  <strong>Architecture:</strong> Runs a cooperative scheduler (<code>protothreads</code>) to toggle between input polling
                  and screen rendering at 60Hz.
                </li>
              </ul>
            </li>
            <li>
              <strong>Core 1 (The DSP Coprocessor):</strong>
              <ul>
                <li>
                  <strong>Responsibilities:</strong> Dedicated entirely to number crunching. It runs an infinite loop that waits for fresh
                  data, applies the Hanning Window, computes the DFT, and updates the FFT output array.
                </li>
                <li>
                  <strong>Benefit:</strong> Because this math happens on a separate core, the oscilloscope trace on screen never “freezes”
                  or lags, even if the math takes milliseconds to complete.
                </li>
              </ul>
            </li>
            <li>
              <strong>Shared Memory &amp; Synchronization:</strong>
              <ul>
                <li>The <code>frame_buf</code> (ADC samples) and <code>fft_output</code> arrays reside in shared RAM.</li>
                <li>
                  Access is managed via flags and semaphores to ensure Core 1 doesn't try to calculate the FFT while Core 0 is
                  simultaneously writing new data from the ADC.
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section id="report_high_level_tradeoffs">
          <h3>Hardware/software tradeoffs</h3>

          <p><strong>1. Signal Processing (FFT): Software (Core 1) vs. Dedicated DSP Hardware</strong></p>
          <ul>
            <li><strong>Decision:</strong> Implemented <strong>Software FFT</strong> on the secondary Cortex-M0+ core.</li>
            <li>
              <strong>Performance:</strong> While a dedicated DSP chip or FPGA would calculate DFTs microseconds faster, the RP2040's dual-core
              architecture allowed us to offload the math to Core 1. This prevents the UI (Core 0) from freezing, achieving a "good enough"
              real-time update rate (approx. 15-30 Hz for FFT) without additional hardware.
            </li>
            <li>
              <strong>Cost &amp; Complexity:</strong> Using the existing microcontroller reduced the Bill of Materials (BOM) cost by ~$5-10 and
              significantly reduced PCB complexity.
            </li>
            <li>
              <strong>Maintainability:</strong> Doing the math in C allows for easy adjustments to windowing functions (e.g., swapping Hanning
              for Blackman) without rewiring hardware.
            </li>
          </ul>

          <p><strong>2. Analog Front End: Digital Zoom vs. Analog Gain</strong></p>
          <ul>
            <li><strong>Decision:</strong> A <strong>Hybrid approach</strong>. We use hardware switches (Gain Modes) for coarse range adjustment, refined by software scaling.</li>
            <li>
              <strong>Performance:</strong> Purely software "zoom" (multiplying the ADC value) destroys signal resolution; zooming 10x on a 10mV
              signal amplifies the quantization noise. Hardware gain (using Op-Amps/Relays) preserves the Signal-to-Noise Ratio (SNR) before it
              hits the ADC.
            </li>
            <li>
              <strong>Complexity:</strong> Adding hardware gain stages increases circuit complexity and power consumption compared to a simple
              voltage divider, but it was strictly necessary to measure small signals accurately.
            </li>
          </ul>

          <p><strong>3. Display Driving: Hardware SPI vs. Bit-Banging</strong></p>
          <ul>
            <li><strong>Decision:</strong> <strong>Hardware SPI Peripheral</strong>.</li>
            <li>
              <strong>Performance:</strong> Driving a 320x240 display requires pushing ~153,000 bytes per frame. "Bit-banging" (toggling pins in
              software) would cap the frame rate at ~5 FPS. Using the RP2040's hardware SPI block allows us to reach 60 FPS with minimal CPU
              overhead.
            </li>
            <li>
              <strong>Power:</strong> Hardware peripherals are more power-efficient as they allow the CPU to sleep or perform other tasks (like
              polling inputs) during data transmission.
            </li>
          </ul>
        </section>

        <!-- <section id="report_high_level_ip">
          <h3>Relevant patents, copyrights, and trademarks</h3>
          
        </section> -->
      </section>

      <hr class="divider">

      <!-- Program / Hardware Design
      ============================ -->
      <section id="report_design">
        <h2>Program / Hardware Design</h2>

        <section id="report_design_program">
          <h3>Program details</h3>
          <p>
            This project required solving several complex graphics and concurrency problems to achieve a stable 60 FPS update rate on the
            RP2040.
          </p>

          <h4>Program Details: Technical Challenges &amp; Solutions</h4>

          <p><strong>1. The "No-Fly Zone" Rendering Algorithm</strong></p>
          <p>
            One of the most persistent issues in digital oscilloscope displays is text flickering or overwriting. If the waveform is drawn
            across the entire screen width, it inevitably scribbles over the voltage axis labels (e.g., "3.3V", "1.65V") on the left
            side. Redrawing these labels every frame is computationally expensive and causes flashing.
          </p>
          <ul>
            <li>
              <strong>The Solution:</strong> We implemented a viewport clipping algorithm in the <code>drawWaveformFromBuffer</code>
              function. By defining specific <code>WAVE_MARGIN</code> constants (Left: 35px, Top: 25px, Bottom: 20px), the renderer
              creates a "protected" area for the UI.
            </li>
            <li>
              <strong>How it works:</strong> The drawing loop starts at <code>x = MARGIN_LEFT</code> rather than <code>0</code>. Any
              signal sample that exceeds the vertical bounds (<code>MARGIN_TOP</code> or <code>MARGIN_BOTTOM</code>) is mathematically
              clamped before drawing. This ensures the waveform "emerges" cleanly from behind the axis labels without ever corrupting the
              text pixels.
            </li>
          </ul>

          <p><strong>2. Flicker-Free Graphics (Smart Erase)</strong></p>
          <p>
            Standard graphics libraries often rely on <code>tft_fillScreen(BLACK)</code> to clear the frame before redrawing. On SPI
            displays, this bulk pixel transfer is too slow and results in a visible "scanline" flicker.
          </p>
          <ul>
            <li>
              <strong>Snake Mode Implementation:</strong> Instead of clearing the screen, we used a <strong>differential rendering</strong>
              strategy. The game logic tracks the exact position of the snake's tail before it moves. We draw a single black block over the
              <em>old</em> tail position and a colored block at the <em>new</em> head position. This reduces the SPI bus load from
              ~76,000 pixels per frame (full screen) to just ~200 pixels per frame.
            </li>
            <li>
              <strong>Oscilloscope Grid:</strong> Similarly, when the waveform erases its old trace (drawing black lines), it often
              accidentally deletes the grid lines. We added a "Repair Bot" logic inside the draw loop: if the eraser crosses a known grid
              coordinate (e.g., <code>x=160</code> or <code>y=120</code>), the function immediately repaints that specific grid pixel,
              maintaining a solid, unbroken reticle.
            </li>
          </ul>

          <p><strong>3. Dual-Core Concurrency</strong></p>
          <p>
            The RP2040 features two ARM Cortex-M0+ cores, which we leveraged to separate the real-time blocking tasks from the math-heavy
            processing.
          </p>
          <ul>
            <li>
              <strong>Core 0 (The Interface):</strong> Runs the <code>protothreads</code> scheduler to handle high-speed SPI display
              rendering and user input (Joystick/Buttons). This ensures the UI remains responsive (60 FPS) at all times.
            </li>
            <li>
              <strong>Core 1 (The Math Coprocessor):</strong> Dedicated solely to the FFT calculations. Using
              <code>multicore_launch_core1</code>, this core continuously processes the ADC buffer, applying the Hanning window and
              computing the Discrete Fourier Transform (DFT).
            </li>
            <li>
              <strong>Synchronization:</strong> Shared memory access to the <code>frame_buf</code> array is protected using semaphores to
              prevent race conditions (read-while-write errors).
            </li>
          </ul>

          <p><strong>4. Rotary Encoder</strong></p>
          <p>
            The rotary encoder generates pulses on its CLK and DT pins when rotated. The direction is determined by looking at if the pulse on CLK or DT was first. Professor Bruce had previously worked with rotary encoders, so we started by referencing his work (<a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_joystick/index_vga_Joystick.html" target="_blank" rel="noopener noreferrer">found here</a>). He used a protothread and would sample the GPIO pins at a set interval. While this solution works, we wanted to use interrupts to make the driver cleaner.
          </p>
          <ul>
            <li>
              <strong>Interrupts:</strong> The RP2040 uses a single ISR to handle all GPIO interrupts. We set up the interrupt once for rising edges on GPIO pins, then check which pin triggered it.
            </li>
            <li>
              <strong>Delta:</strong> When the interrupt is triggered, a counter is incremented or decremented depending on whether the CLK or DT pin was triggered. When we process the input, we use the counter value to determine how many times the encoder was rotated, then reset the counter.
            </li>
            <li>
              <strong>Debouncing:</strong> In order to prevent bouncing, we placed on the CLK and DT pins of the encoder. We found that 10 nF capacitors were enough to reduce bouncing, while still keeping the encoder responsive.
            </li>
          </ul>

          <p><strong>5. ADC</strong></p>
          <p>
            We decided to use the ADC built into the RP2040, mostly due to time after loosing the PCBs.
          </p>
          <ul>
            <li>
              <strong>Sample Rate:</strong> The internal ADC operates at 500 kS/s. We wanted to use the full sampling rate to get as much data as we could. This meant not using the clock divider for the ADC.
            </li>
            <li>
              <strong>DMA:</strong> To read data from the ADC without blocking a CPU core, we used DMA channels. We had a two-channel configuration, with a control channel and a data channel. The data channel would read data from the ADC when it was available and store it in a buffer array. When it reached the end of the array, the control channel would trigger and reset the data channel's pointer to the start of the array.
            </li>
          </ul>
        </section>

        <section id="report_design_hardware">
          <h3>Hardware details</h3>
          <p>
            The hardware design prioritizes modularity and low cost, using off-the-shelf components to create a professional-grade
            instrument. Figure 1 in Appendix C shows the full schematic for the breadboard version of the ScopeBoy.
          </p>

        <h4>Bill of Materials (BOM)</h4>
          <ul>
            <li><strong>Microcontroller:</strong> Raspberry Pi Pico (RP2040)</li>
            <li><strong>Display:</strong> Adafruit 3.5&quot; TFT Breakout (320x480) with HX8357D driver</li>
            <li><strong>Input:</strong> Adafruit Mini Gamepad (I2C Gamepad with Analog Joystick)</li>
            <li><strong>Control:</strong> KY-040 Rotary Encoder (for precise zoom/scale adjustment)</li>
            <li><strong>Interface:</strong> Breadboard and jumpers for rapid prototyping</li>
          </ul>

          <h4 class="mt-4 mb-2">Breadboard Analog Front End BOM</h4>
          <p class="text-muted mb-3">Components used for input coupling, biasing, protection, and gain/trigger circuitry. See the schematic in Figure 1 for more details.</p>

              <div class="table-responsive">
                <table class="table table-bordered">
                  <thead>
                    <tr>
                      <th>Item</th>
                      <th>Part / Value</th>
                      <th>Qty</th>
                      <th>Notes</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Op-amp</td>
                      <td>MCP6242 (dual, rail-to-rail)</td>
                      <td>1</td>
                      <td>Gain/buffer stages</td>
                    </tr>
                    <tr>
                      <td>Comparator </td>
                      <td>AD8561</td>
                      <td>1</td>
                      <td>Fast edge/trigger detection</td>
                    </tr>
                    <tr>
                      <td>DAC</td>
                      <td>MCP4822</td>
                      <td>1</td>
                      <td>Adjustable trigger threshold</td>
                    </tr>
                    <tr>
                      <td>Analog switch</td>
                      <td>ADG621 (dual SPST)</td>
                      <td>1</td>
                      <td>Gain range switching</td>
                    </tr>
                    <tr>
                      <td>Input resistor</td>
                      <td>1 MΩ</td>
                      <td>1</td>
                      <td>Scope-probe style input impedance</td>
                    </tr>
                    <tr>
                      <td>Compensation capacitor</td>
                      <td>10–22 pF</td>
                      <td>1</td>
                      <td>Input compensation (probe-dependent)</td>
                    </tr>
                    <tr>
                      <td>AC coupling capacitor</td>
                      <td>0.1–1 µF</td>
                      <td>1</td>
                      <td>Blocks DC before biasing</td>
                    </tr>
                    <tr>
                      <td>Bias divider resistors</td>
                      <td>10 kΩ</td>
                      <td>2</td>
                      <td>Generates ~1.65 V mid-bias</td>
                    </tr>
                    <tr>
                      <td>Connector / adapter</td>
                      <td><a href="https://www.adafruit.com/product/2889" target="_blank" rel="noopener noreferrer">BNC-to-terminal block</a></td>
                      <td>1</td>
                      <td>Connects standard scope probes to breadboard</td>
                    </tr>
                  </tbody>
                </table>

          <h4 class="mt-4 mb-2">PCB BOM</h4>
          <p class="text-muted mb-3">
            Download the full BOM CSV:
            <a class="btn btn-sm btn-outline-primary ml-2"
               href="assets/bom/scopeboyBOM.csv"
               download>Download CSV</a>
          </p>
          <div class="table-responsive">
            <table class="table table-bordered table-sm">
              <thead>
                <tr>
                  <th>Reference</th>
                  <th>Value</th>
                  <th>Qty</th>
                </tr>
              </thead>
              <tbody>
                <tr><td>C1,C3,C8,C10,C11</td><td>2.2u</td><td>5</td></tr>
                <tr><td>C2,C26</td><td>1u</td><td>2</td></tr>
                <tr><td>C4,C5</td><td>10n</td><td>2</td></tr>
                <tr><td>C6</td><td>4.7u</td><td>1</td></tr>
                <tr><td>C7</td><td>1p</td><td>1</td></tr>
                <tr><td>C9</td><td>6.8p</td><td>1</td></tr>
                <tr><td>C12,C13,C14,C16,C18,C19,C20,C21,C22,C23,C27,C28,C29,C30</td><td>100n</td><td>14</td></tr>
                <tr><td>C15,C17,C24</td><td>22u</td><td>3</td></tr>
                <tr><td>C25</td><td>160p</td><td>1</td></tr>
                <tr><td>C31,C32</td><td>10nF</td><td>2</td></tr>

                <tr><td>D1,D2,D3</td><td>D</td><td>3</td></tr>

                <tr><td>J1</td><td>SMA Samtec SMA-J-P-X-ST-EM1 EdgeMount </td><td>2</td></tr>
                <tr><td>J5</td><td>SM04B-SRSS-TB</td><td>1</td></tr>
                <tr><td>J6,J7</td><td>SM03B-SRSS-TB</td><td>2</td></tr>

                <tr><td>Q1</td><td>DMG2305UX-7</td><td>1</td></tr>

                <tr><td>R1,R2</td><td>87k</td><td>2</td></tr>
                <tr><td>R3</td><td>680k</td><td>1</td></tr>
                <tr><td>R4,R6</td><td>50k</td><td>2</td></tr>
                <tr><td>R5</td><td>100k</td><td>1</td></tr>
                <tr><td>R7,R8</td><td>0</td><td>2</td></tr>
                <tr><td>R9,R14,R17,R23</td><td>1k</td><td>4</td></tr>
                <tr><td>R10</td><td>47</td><td>1</td></tr>
                <tr><td>R11,R12,R15,R16,R18</td><td>100</td><td>5</td></tr>
                <tr><td>R13</td><td>680</td><td>1</td></tr>
                <tr><td>R19,R24</td><td>22</td><td>2</td></tr>
                <tr><td>R20,R21</td><td>4.7k</td><td>2</td></tr>
                <tr><td>R22</td><td>1MEG</td><td>1</td></tr>

                <tr><td>U1</td><td>LP2985-3.3</td><td>1</td></tr>
                <tr><td>U2</td><td>LM27762</td><td>1</td></tr>
                <tr><td>U3</td><td>OPA354</td><td>1</td></tr>
                <tr><td>U4</td><td>ADG621</td><td>1</td></tr>
                <tr><td>U5</td><td>LMH6629</td><td>1</td></tr>
              </tbody>
            </table>
          </div>

          <h4>Pin Mapping</h4>
          <p>
            The system uses <code>SPI0</code> for the display and <code>SPI1</code> for the DAC. Running them both on the same bus caused interference.
          </p>

          <div class="table-responsive">
            <table class="table table-bordered">
              <thead>
                <tr>
                  <th>Component</th>
                  <th>Pico Pin</th>
                  <th>Function</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>TFT Display</strong></td>
                  <td>GPIO 14</td>
                  <td>SPI0 SCK (Clock)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 15</td>
                  <td>SPI0 TX (MOSI)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 18</td>
                  <td>TFT_CS (Chip Select)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 16</td>
                  <td>TFT_DC (Data/Command)</td>
                </tr>
                <tr>
                  <td><strong>Rotary Encoder</strong></td>
                  <td>GPIO 19, 20</td>
                  <td>CLK, DT (Encoder Lines)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 6</td>
                  <td>SW (Push Button)</td>
                </tr>
                <tr>
                  <td><strong>I2C Gamepad</strong></td>
                  <td>GPIO 2, 3</td>
                  <td>I2C SDA/SCL</td>
                </tr>
                <tr>
                  <td><strong>Analog In</strong></td>
                  <td>GPIO 26</td>
                  <td>ADC0 (Probe Input)</td>
                </tr>
                <tr>
                  <td><strong>Gain Select</strong></td>
                  <td>GPIO 8, 9</td>
                  <td>Sel1, Sel0</td>
                </tr>
                <tr>
                  <td><strong>DAC SPI</strong></td>
                  <td>GPIO 10</td>
                  <td>SPI1 SCK (Clock)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 11</td>
                  <td>SPI1 TX (MOSI)</td>
                </tr>
                <tr>
                  <td></td>
                  <td>GPIO 13</td>
                  <td>DAC_CS (Chip Select)</td>
                </tr>
              </tbody>
            </table>
          </div>

          <h4>Analog Front End (Gain Scaling)</h4>
          <p>
            While the current version uses a software-simulated gain stage, the architecture is designed to support a hardware op-amp
            frontend.
          </p>
          <ul>
            <li>The system implements three gain modes: <strong>Low (0.21x)</strong>, <strong>Med (0.39x)</strong>, and <strong>High (1.98x)</strong>.</li>
            <li>
              The <code>adc_to_volt</code> function dynamically scales the raw 12-bit ADC reading (0-4095) based on the active mode.
              This allows the scope to measure signals ranging from millivolts (High Gain) to ~15V (Low Gain), with the software
              automatically adjusting the grid labels to display the correct &quot;Real World&quot; voltage.
            </li>
          </ul>

          <h4>3D Assembly Views</h4>
          <p>
            The following exploded views illustrate the physical assembly of the ScopeBoy device:
          </p>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Exploded View: PCB and Back Housing
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_exploded_pcb_back.jpeg"
                alt="ScopeBoy PCB and Back Housing Exploded" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Exploded View: Front Housing, Battery, and Keypad
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_exploded_front_battery.jpeg"
                alt="ScopeBoy Front Housing, Battery, and Keypad Exploded" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Exploded View: Complete Assembly (Front, Back, and PCB)
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_exploded_full.jpeg"
                alt="ScopeBoy Complete Exploded View" />
          </figure>
        </section>

        <section id="report_design_reuse">
          <h3>Reused code/design</h3>
          <p>
            This project stands on the shoulders of open-source libraries and hardware designs, modified for high-performance needs:
          </p>
          <ul>
            <li>
              <strong>TFTMaster.h:</strong> A highly optimized SPI library for the RP2040, originally developed by MEng students at Cornell
              University. It provided the low-level pixel pushing primitives.
            </li>
            <li>
              <strong>Protothreads (pt):</strong> A lightweight threading library by Adam Dunkels, used here to implement the cooperative
              multitasking scheduler on Core 0.
            </li>
            <li>
              <strong>RPScope:</strong> A Pico based dual-channel oscilloscope design by Jenny List. We modified their PCB to make it single channel, and work with our TFT screen, encoder, joystick, and battery charger.
            </li>
          </ul>
        </section>

        <section id="report_design_failed">
          <h3>Things which did not work</h3>
          <p>Our biggest failure was in the PCB. Not because the PCB didn't work or anything. We don't know whether the PCB worked because it wandered off (read: was stolen) over Thanksgiving break. This forced us to think on our feet and redesign the analog front end. We built a working front end, but it had significantly less bandwidth than we originally planned. We had planned for 1 MHz of bandwidth, but ultimately ended up at around 70 kHz. While it has substantially less bandwidth, the scope would still work for audio-range signals, so it serves a purpose.</p>
          <p>We also designed an enclosure for the PCB, which we planned to 3D print. After we lost the boards, we scrapped the enclosure because the breadboard was fragile enough that it didn’t make sense to keep the system handheld. This also meant that we scrapped our plans to power it with a LiPo battery. We had the battery charger component from Adafruit, but since the board wasn’t handheld, it didn't make sense to power it.</p>
          <p>Even though we lost the PCBs and had to redesign the front end, this allowed us to correct some design flaws in the original we had used as the base. Initially, our board had a Coax connector instead of the standard BNC connectors used by scope probes. This was because the design lacked the 1MΩ resistor and 10-22 pF capacitor used in oscilloscopes for 10x mode. So, using a coax SMA made more sense. However, that would have been annoying, since we would have had to make our own probe cable or get a coax-to-BNC connector adapter. We ordered a BNC-to-2-terminal block, which we used with the breadboard to connect standard scope probes, and put the proper resistor and capacitor in the circuit. This made connecting a scope probe easier, but it was still not a perfect solution. The scope probe's impedance wasn't matched, and 10X mode still didn't work because the signal was attenuated to the point that it was lost in the noise by the time it reached the gain stage.</p>
          <p>The original PCB design also included a -3.3 V rail for the op-amps, allowing signals to reach negative voltages. For the breadboard design, we used the 3.3V and grounds directly from the Pico. This added more noise and, more importantly, required biasing all signals to prevent clipping at the op-amp rails. We blocked the DC bias in the original signal using a capacitor at the input, then applied our own 1.65 V bias. This meant that the scope couldn’t measure DC signals, with a minimum frequency of around 2 kHz.</p>
        </section>

        <section id="report_design_ai">
          <h3>Thorough discussion of AI use</h3>

          <h4>1. Tools Used</h4>
          <ul>
            <li><strong>Models:</strong> Google Gemini (Pro/Flash) and OpenAI GPT-5.</li>
            <li><strong>IDE Assistants:</strong> CoPilot in VSCode</li>
          </ul>

          <h4>2. Application of AI</h4>
          <ul>
            <li>
              <strong>Feasibility Checks:</strong> Before writing code, we used AI to estimate the feasibility of adding complex features like
              the FFT spectrum analyzer and the "Snake" game on the secondary core without disrupting the 60Hz oscilloscope refresh rate.
            </li>
            <li>
              <strong>Code Refactoring &amp; Reuse:</strong> AI was instrumental during the major overhaul of the input system. We needed to add
              new modes (Menu navigation, Snake game) that required reusing existing low-level button reading logic. We prompted the AI to
              "wrap" our raw bit-masking logic as the part of our modular state machine (<code>handleInput</code>) that could support multiple
              contexts (Scope vs. Game) without duplicating the low-level driver code.
            </li>
            <li>
              <strong>Website Formatting:</strong> AI was used to assist with the creation of the website. It helped with formatting parts of the website, like the image gallary, and some tables.
            </li>
          </ul>

          <h4>3. Verification Steps</h4>
          <ul>
            <li>
              <strong>Manual Code Review:</strong> Every block of AI-generated C code was manually reviewed for hardware safety.
            </li>
            <li>
              <strong>Signal Measurement:</strong> For the math functions suggested by AI (such as the gain scaling factors), we verified the
              output by injecting known voltage signals from a function generator and confirming the oscilloscope displayed the correct values.
            </li>
          </ul>

          <h4>4. AI-Generated Content NOT Used</h4>
          <p><strong>Attempted TFT Display Driver Port:</strong> Early in the project, we attempted to use AI to port an existing Arduino-based TFT library (Adafruit_ILI9341) to the Raspberry Pi Pico C SDK.</p>
          <ul>
            <li>
              <strong>Why it was discarded:</strong> The AI hallucinated compatibility with Arduino-specific hardware abstraction layers (like
              <code>SPI.h</code> and <code>Adafruit_GFX.h</code>) that do not exist in the bare-metal Pico SDK environment. It produced code
              with heavy dependency chains and incorrect SPI timing constraints that could not compile.
            </li>
            <li>
              <strong>Resolution:</strong> We discarded the AI-generated driver entirely and adopted the <code>TFTMaster.h</code> library
              (developed by MEng students), which provides optimized, hardware-specific SPI functions for the RP2040.
            </li>
          </ul>
        </section>
      </section>

      <hr class="divider">

      <!-- Results
      ============================ -->
      <section id="report_results">
        <h2>Results of the Design</h2>

        <section id="report_results_data">
        <h3>Test data / traces / waveforms</h3>

        <!-- <h4 class="mt-3">Demo Images</h4> -->
        <p class="text-muted">
          Images of the scope in action:
        </p>

        <div id="demo-images-gallery" class="row"></div>

        <script>
          (function () {
            const gallery = document.getElementById("demo-images-gallery");
            if (!gallery) return;

            fetch("assets/images/demo_images/manifest.json", { cache: "no-store" })
              .then((r) => {
                if (!r.ok) throw new Error("manifest.json not found");
                return r.json();
              })
              .then((items) => {
                if (!Array.isArray(items) || items.length === 0) {
                  gallery.innerHTML =
                    '<div class="col-12"><p class="text-muted mb-0">No images listed in manifest.json yet.</p></div>';
                  return;
                }

                // Normalize items into { file, title, caption } and drop invalid entries
                const normalized = items
                  .map((item) => {
                    if (typeof item === "string") {
                      const file = item;
                      return {
                        file,
                        title: file.replace(/\.[^/.]+$/, ""),
                        caption: "Placeholder caption: describe this image.",
                      };
                    }

                    if (item && typeof item === "object" && typeof item.file === "string" && item.file.trim() !== "") {
                      const file = item.file.trim();
                      return {
                        file,
                        title: (item.title && String(item.title).trim()) || file.replace(/\.[^/.]+$/, ""),
                        caption: (item.caption && String(item.caption).trim()) || "Placeholder caption: describe this image.",
                      };
                    }

                    // Missing file -> skip
                    return null;
                  })
                  .filter(Boolean);

                if (normalized.length === 0) {
                  gallery.innerHTML =
                    '<div class="col-12"><p class="text-muted mb-0">Manifest loaded, but no valid <code>file</code> entries were found.</p></div>';
                  return;
                }

                gallery.innerHTML = normalized
                .map(({ file, title, caption }, idx) => {
                  const src = `assets/images/demo_images/${file}`;

                  // Force layout: row 1 = 3 images, rows after = 2 images per row (on lg+ screens)
                  const colClass =
                  idx < 2
                    ? "col-12 col-md-6 col-lg-6"
                    : idx < 5
                      ? "col-12 col-md-6 col-lg-4"
                      : "col-12 col-md-6 col-lg-6";

                  return `
                    <div class="${colClass} mb-3">
                      <div class="card h-100">
                        <a href="${src}" target="_blank" rel="noopener noreferrer">
                          <img class="card-img-top demo-gallery-img" src="${src}" alt="${title}">
                        </a>
                        <div class="card-body">
                          <h6 class="card-title mb-2">${title}</h6>
                          <p class="card-text text-muted mb-0">${caption}</p>
                        </div>
                      </div>
                    </div>
                  `;
                })
                .join("");
              })
              .catch((e) => {
                gallery.innerHTML =
                  `<div class="col-12"><p class="text-muted mb-0">Could not load gallery manifest: <code>${String(e.message || e)}</code></p></div>`;
              });
          })();
        </script>
      </section>

        <section id="report_results_speed">
          <h3>Speed of execution</h3>
          <ul>
            <li>
              <strong>Latency / responsiveness:</strong> The UI runs in a dedicated Core 0 protothread loop that targets ~60 FPS by yielding for
              ~16.7 ms per frame. Input is polled every frame so knob/joystick actions feel immediate.
            </li>
            <li>
              <strong>Flicker / hesitation:</strong> Instead of clearing and redrawing the full screen each frame (too slow over SPI), we use
              “smart redraw”: only update the parts that change (waveform/menus) and repair any grid pixels that get erased. This avoids visible
              scanline flicker.
            </li>
            <li>
              <strong>Concurrency behavior:</strong> The heavy math (DFT/FFT) runs on Core 1, while Core 0 focuses on rendering + input. This
              separation prevents spectrum calculations from freezing the oscilloscope trace.
            </li>
            <li>
              <strong>DMA for ADC:</strong> DMA channels move data from the ADC to an input buffer to keep the CPU free to draw the UI and perform calculations.
            </li>
          </ul>
        </section>

       <section id="report_results_accuracy">
        <h3>Accuracy</h3>
        <ul>
          <li>
            We did not take direct measurements to compare the expected and actual outputs. We did verify that the signals looked mostly correct,
            although we do expect noise in the system and the RP2040's ADC to introduce artifacts in the system.
          </li>
          <li>We performed this informal verifiaction by comparing our signal to a real oscilloscope's output to make sure they aligned. However, we should have recoreded actual measurements to formally verify out output.</li>
        </ul>
      </section>

      <section id="report_results_safety">
        <h3>Safety enforcement</h3>
        <ul>
          <li>
            Due to the analog front end, the scope is fundamentally limited to signals of 30V peak to peak. This voltage level is relatively safe,
            especially given that the scope doesn't work with signals of less than 2kHz. Still, being on a breadboard does mean that there are
            semi-exposed wires, so users should be careful. This problem would have been solved with the enclosure.
          </li>
          <li>
            We had originally planned on using a LiPo battery to power the board. LiPos can be dangerous if charged incorrectly or punctured. We were
            going to use a battery charging circuit to prevent improper charging, and would have enclosed the battery.
          </li>
          <li>
            We did not use the watchdog or any other safety features on the Pico. This is a low-stakes device, and crashes would only inconvenience
            the user, not harm them. We still tried to make the code robust to prevent crashes.
          </li>
        </ul>
      </section>

      <section id="report_results_usability">
        <h3>Usability</h3>
        <ul>
          <li>
            The final version of the oscilloscope worked, but was not the most usable. Its biggest constraint was that it had two breadboards, which
            made it fragile and hard to transport. This version would not be handheld, and we had to be careful when transporting it.
          </li>
          <li>
            The controls all worked, but users had to hold the rotary encoder and joystick/button controller in their hands. Ideally, these would
            have been integrated into the case. The rotary encoder occasionally registered an incorrect input due to our pure-hardware debouncing.
            Accessing the snake minigame required precise button inputs, which didn't always trigger.
          </li>
        </ul>
      </section>

      <hr class="divider">

      <!-- Conclusions
      ============================ -->
      <section id="report_conclusions">
        <h2>Conclusions</h2>

        <section id="report_conclusions_analysis">
          <h3>Expectation vs results</h3>
          <p>Our project ended in a very differnt state than we originally intended. We originally intended to have a fully integrated solution, including a PCB and enclosure to make it portable. Our final design was only on a breadboard, and should not be moved much to avoid the wires on the board breaking. Still, given the circumstances, the project turned out surprisingly well. We were able to demonstrate many software features that professional oscilloscopes have, and proved that this concept is feasable. We are considering an independent study to fully realize our original vision for this project.. Here are a list of ideas that we are thinking about for a proper version:</p>
          <ul>
            <li>Redo the PCB and validate the analog front end bandwidth target.</li>
            <li>Re-add -3.3V rail, and figure out how to accept both AC and DC signals.</li>
            <li>Design/print an enclosure and make the system portable again.</li>
            <li>Add battery power + charging and improve power integrity/noise.</li>
            <li>Integrate the RP2040 directly onto a PCB instead of using a Pico in a surface mount configuration.</li>
            <li>Use a USB-C connector to charge the device and get data, because it is the year 2025 why does the Pico still use Micro-B?</li>
            <li>Add proper 10× probe compensation.</li>
          </ul>
        </section>
        

        <section id="report_conclusions_standards">
          <h3>Conformance to applicable standards</h3>
          <p>We did not reference any standards in the making of this project. We do not believe that our design is suitable for high precision applications.</p>
        </section>

        <section id="report_conclusions_ip">
        <h3>Intellectual property considerations</h3>
        
          <li>
            We started using the
            <a href="https://hackaday.io/project/188051-rpscope" target="_blank" rel="noopener noreferrer">Pi Pico Oscilloscope</a>
            project by Jenny List on Hackaday as the base of our scope. They wrote an article about the hardware design and released the design
            files on Hackaday. We saved time by modifying their PCB. Their original code was in Python, so we did not use any of their code and
            wrote all of our own in C.
          </li>
          <li>
            After losing the PCB, we redesigned the entire front end, using the original board as loose inspiration, but changing much of the
            circuit.
          </li>
          <li>
            We made sure that any libraries we used were open source to comply with patent and copyright law.
          </li>
          <li>We used the iDocs template by Harnish Design for our website. It is under the MIT license.</li>
          <li>
            While the name “ScopeBoy” is similar to the “GameBoy” trademark owned by Nintendo, it is not an entertainment device and should be
            distinct enough. We only take inspiration from the name and form factor and do not reference the GameBoy elsewhere.
          </li>
          <li>
            If developed further, we could potentially patent the project. However, we did not check for similar devices, and publishing this
            level of detail would make a patent significantly harder to obtain. We would rather open source the design to make it accessible to
            others, especially since our design uses open-source work.
          </li>
        
      </section>

      <hr class="divider">

      <!-- Appendices (combined)
      ============================ -->
      <section id="appendices">
        <h2>Appendices</h2>

        <!-- Appendix A -->
        <section id="appendix_a_permissions">
          <h3>Appendix A: Permissions</h3>

          <section id="appendix_a_course">
            <h4>Project on the course website</h4>
            <p><strong>Include exactly one of the following sentences:</strong></p>
            <ul>
              <li>“The group approves this report for inclusion on the course website.”</li>
            </ul>
          </section>

          <section id="appendix_a_youtube">
            <h4>Project video on the course YouTube channel</h4>
            <p><strong>Include exactly one of the following sentences:</strong></p>
            <ul>
              <li>“The group approves the video for inclusion on the course youtube channel.”</li>
            </ul>
          </section>
        </section>

        <!-- Appendix B -->
        <section id="appendix_b_code">
          <h3>Appendix B: Commented program listings</h3>
          <ul>
            <li>
              GitHub Repository:
              <a href="https://github.com/leslier7/ece5730-scopeboy-final-project" target="_blank" rel="noopener noreferrer">Link</a>
            </li>
            <li>The code is stored in the top level. <code>Final_Project.c</code> is the main file.</li>
            <li>ScopeBoy contains the PCB KiCAD project</li>
            <li>ScopeBoyBreadboard contains the breadboard KiCAD project with the schematic</li>
            <li>website contains the website code</li>
          </ul>
        </section>

        <!-- Appendix C -->
        <section id="appendix_c_schematics">
          <h3>Appendix C: Schematics</h3>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 1: ScopeBoy Breadboard Schematic
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_breadboard_schematic.svg"
                alt="ScopeBoy Breadboard Schematic" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 2: ScopeBoy PCB Schematic
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb_schematic.svg"
                alt="ScopeBoy PCB Schematic" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 3: ScopeBoy PCB Top Layer
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/rpicoscope2-F_Cu.svg"
                alt="ScopeBoy PCB Front" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 4: ScopeBoy PCB Back Layer
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/rpicoscope2-B_Cu.svg"
                alt="ScopeBoy PCB Back" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 5: ScopeBoy PCB Signal Layer
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/rpicoscope2-In2_Cu.svg"
                alt="ScopeBoy PCB Signal" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 6: ScopeBoy PCB Ground Layer
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/rpicoscope2-In1_Cu.svg"
                alt="ScopeBoy PCB Ground" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 7: ScopeBoy PCB 3D Render Top
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/model_front.png"
                alt="ScopeBoy PCB 3D Front" />
          </figure>

          <figure class="doc-figure">
            <figcaption class="doc-figure__caption doc-figure__caption--top">
              Figure 8: ScopeBoy PCB 3D Render Bottom
            </figcaption>
            <img class="img-fluid doc-figure__img"
                src="assets/images/scopeboy_pcb/model_back.png"
                alt="ScopeBoy PCB 3D Back" />
          </figure>
        </section>

        <!-- Appendix D -->
        <section id="appendix_d_tasks">
          <h3>Appendix D: Team member task breakdown</h3>
          <ul>
            <li><strong>Robbie:</strong> Rotary encoder driver, PCB design, analog circuit redesign and breadboarding, analog circuit code</li>
            <li>
              <strong>Robbie Leslie:</strong>
              <ul>
                <li>
                  <strong>Software &amp; Firmware:</strong>
                  <ul>
                    <li>Developed the interupt driven rotary encoder driver.</li>
                    <li>Developed the ADC code using the DMA channels, and trigger logic.</li>
                  </ul>
                </li>
                <li>
                  <strong>Hardware &amp; Mechanical:</strong>
                  <ul>
                    <li>Modified the PCB we found to accomodate screen, rotary encoder, I2C joystick, battery circuit, and debug connectors. Modified component selection on PCB.</li>
                    <li>Procured all components used in the project.</li>
                    <li>Redesigned analog front end after loosing PCB.</li>
                    <li>Assembled and debugged the analog front end on the breadboard.</li>
                  </ul>
                </li>
              </ul>
            </li>
            <li>
              <strong>Immanuel Varghese Koshy:</strong>
              <ul>
                <li>
                  <strong>Software &amp; Firmware:</strong>
                  <ul>
                    <li>Developed the complete User Interface (UI) system, including the oscilloscope grid, menu navigation, and real-time waveform rendering.</li>
                    <li>Implemented the Spectrum Analyzer (FFT) mode, including windowing functions and frequency bin visualization.</li>
                    <li>Wrote the I2C drivers for the Adafruit Seesaw Gamepad to handle joystick and button inputs.</li>
                    <li>Engineered the "Smart Redraw" graphics engine to eliminate screen flicker and optimize SPI bus usage.</li>
                    <li>Created the "Snake" game Easter egg, demonstrating isolated game loop logic within the scope architecture.</li>
                  </ul>
                </li>
                <li>
                  <strong>Hardware &amp; Mechanical:</strong>
                  <ul>
                    <li>Designed the mechanical housing, creating custom STL models for the 3D-printed enclosure to fit the Pico, display, and controls.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </section>
      </section>

      <hr class="divider">

      <!-- References
      ============================ -->
      <section id="references">
        <h2>References</h2>
        <ul>
          <li>
            MCP6242 Op Amp Datasheet: <a href="https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/21882d.pdf" target="_blank" rel="noopener noreferrer">
              Link
            </a>
          <li>
            AD8561 Ultra Fast Comparator Datasheet: <a href="https://www.mouser.com/datasheet/3/1014/1/AD8561.pdf" target="_blank" rel="noopener noreferrer">
              Link
            </a>
          <li>
            ADG621 Dual Switch Datasheet: <a href="https://www.mouser.com/datasheet/3/1014/1/ADG621.pdf" target="_blank" rel="noopener noreferrer">
              Link
            </a>
          <li>
            Pi Pico Oscilloscope Original Design: <a href="https://hackaday.com/2022/11/06/a-pi-pico-oscilloscope/" target="_blank" rel="noopener noreferrer">
              Hackaday Link
            </a>
          <li>
            Professor Bruce's Rotary Encoder Driver: <a href="https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_joystick/index_vga_Joystick.html" target="_blank" rel="noopener noreferrer">
              Link
            </a>
          <li>
            iDocs Website Template: <a href="https://github.com/harnishdesign/iDocs" target="_blank" rel="noopener noreferrer">
              Link
            </a>
        </ul>
      </section>

    </div>
  </div>

</div>
<!-- Document Wrapper end --> 

<!-- Back To Top --> 
<a id="back-to-top" data-toggle="tooltip" title="Back to Top" href="javascript:void(0)"><i class="fa fa-chevron-up"></i></a> 

<!-- JavaScript
============================ -->
<script src="assets/vendor/jquery/jquery.min.js"></script> 
<script src="assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script> 
<!-- Highlight JS -->
<script src="assets/vendor/highlight.js/highlight.min.js"></script> 
<!-- Easing --> 
<script src="assets/vendor/jquery.easing/jquery.easing.min.js"></script> 
<!-- Magnific Popup --> 
<script src="assets/vendor/magnific-popup/jquery.magnific-popup.min.js"></script> 
<!-- Custom Script -->
<script src="assets/js/theme.js"></script>
</body>
</html>
