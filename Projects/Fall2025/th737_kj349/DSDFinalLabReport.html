<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_mub4u0dng200-0{list-style-type:none}ul.lst-kix_mub4u0dng200-2{list-style-type:none}ul.lst-kix_mub4u0dng200-1{list-style-type:none}ul.lst-kix_mub4u0dng200-4{list-style-type:none}ul.lst-kix_mub4u0dng200-3{list-style-type:none}ul.lst-kix_mub4u0dng200-6{list-style-type:none}ul.lst-kix_mub4u0dng200-5{list-style-type:none}ul.lst-kix_vr52rq2b191l-3{list-style-type:none}ul.lst-kix_vr52rq2b191l-2{list-style-type:none}ul.lst-kix_vr52rq2b191l-5{list-style-type:none}ul.lst-kix_vr52rq2b191l-4{list-style-type:none}ul.lst-kix_vr52rq2b191l-1{list-style-type:none}ul.lst-kix_vr52rq2b191l-0{list-style-type:none}.lst-kix_mub4u0dng200-5>li:before{content:"\0025a0   "}ul.lst-kix_vr52rq2b191l-7{list-style-type:none}ul.lst-kix_vr52rq2b191l-6{list-style-type:none}.lst-kix_mub4u0dng200-4>li:before{content:"\0025cb   "}ul.lst-kix_vr52rq2b191l-8{list-style-type:none}.lst-kix_mub4u0dng200-3>li:before{content:"\0025cf   "}ul.lst-kix_mub4u0dng200-8{list-style-type:none}ul.lst-kix_mub4u0dng200-7{list-style-type:none}.lst-kix_mub4u0dng200-2>li:before{content:"\0025a0   "}.lst-kix_vr52rq2b191l-5>li:before{content:"\0025a0   "}.lst-kix_mub4u0dng200-0>li:before{content:"\0025cf   "}.lst-kix_vr52rq2b191l-4>li:before{content:"\0025cb   "}.lst-kix_vr52rq2b191l-6>li:before{content:"\0025cf   "}.lst-kix_mub4u0dng200-1>li:before{content:"\0025cb   "}.lst-kix_vr52rq2b191l-3>li:before{content:"\0025cf   "}.lst-kix_vr52rq2b191l-7>li:before{content:"\0025cb   "}.lst-kix_vr52rq2b191l-0>li:before{content:"\0025cf   "}.lst-kix_vr52rq2b191l-2>li:before{content:"\0025a0   "}.lst-kix_vr52rq2b191l-8>li:before{content:"\0025a0   "}.lst-kix_mub4u0dng200-6>li:before{content:"\0025cf   "}.lst-kix_vr52rq2b191l-1>li:before{content:"\0025cb   "}.lst-kix_mub4u0dng200-7>li:before{content:"\0025cb   "}.lst-kix_mub4u0dng200-8>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c17{-webkit-text-decoration-skip:none;color:#000000;font-weight:400;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:14pt;font-family:"Arial";font-style:normal}.c18{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c9{padding-top:0pt;text-indent:36pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c0{background-color:#ffffff;padding-top:0pt;padding-bottom:0pt;line-height:1.5;orphans:2;widows:2;text-align:left}.c26{padding-top:18pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c31{padding-top:0pt;padding-bottom:3pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c19{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial"}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c34{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c36{color:#000000;text-decoration:none;font-size:12pt;font-style:normal}.c7{color:#008000;text-decoration:none;vertical-align:baseline;font-style:normal}.c29{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c3{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c5{color:#a31515;text-decoration:none;vertical-align:baseline;font-style:normal}.c23{font-weight:700;font-size:16pt;font-family:"Arial"}.c15{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c1{font-size:9pt;font-weight:400;font-family:"Courier New"}.c22{font-weight:700;font-size:12pt;font-family:"Arial"}.c13{text-decoration:none;vertical-align:baseline;font-style:normal}.c37{font-weight:700;vertical-align:baseline;font-family:"Arial"}.c32{width:33%;height:1px}.c35{color:inherit;text-decoration:inherit}.c30{font-weight:400;font-family:"Arial"}.c28{vertical-align:super}.c25{text-indent:36pt}.c33{font-size:16pt}.c16{page-break-after:avoid}.c20{color:#a31515}.c24{font-size:10pt}.c4{color:#0000ff}.c21{color:#bd63c5}.c14{color:#808080}.c11{font-style:italic}.c27{height:16pt}.c8{height:12pt}.c6{color:#098658}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:12pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:12pt;font-family:"Arial"}h1{padding-top:0pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:0pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:0pt;-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;font-size:14pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;text-decoration-skip-ink:none;font-family:"Arial";orphans:2;widows:2;text-align:left}h3{padding-top:0pt;-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;font-size:12pt;padding-bottom:0pt;line-height:1.15;page-break-after:avoid;text-decoration-skip-ink:none;font-family:"Arial";orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c15 doc-content"><div><p class="c10 c8"><span class="c2"></span></p></div><p class="c16 c31 title" id="h.ytm7qseap1aj"><span class="c3 c30 c33">ECE 5740 Final Lab: <br>Virtual Pinball with Sonar and Muscle IR Inputs</span></p><p class="c19"><span class="c2">Team Members: Tianqi Hu (th737), Kedar Johnson (kj349)</span></p><p class="c10 c8"><span class="c2"></span></p><h1 class="c10 c16" id="h.6tkjaep4cbgu"><span class="c3 c23">Introduction</span></h1><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For our final project, we designed a virtual pinball machine where the flippers are controlled using two sonar sensors and the ball is launched using an IR sensor configured to read bicep contractions. By waving a hand in front of the two sensors and flexing the arm with the IR sensor strap, one can play this more active variation of pinball. An overview of the project can be found in this </span><span class="c29"><a class="c35" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DfEmvvQ-iMaA&amp;sa=D&amp;source=editors&amp;ust=1766187649734298&amp;usg=AOvVaw07GNDcE6qhC65S8Tt7oOFW">video</a></span><span class="c2">.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 346.67px;"><img alt="" src="images/image35.png" style="width: 624.00px; height: 346.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">This project builds on our Galton Board lab by transforming a physics-based simulation into a fully interactive pinball machine. Rather than relying on conventional controls, we reimagine pinball as a physically driven experience where the player&rsquo;s own movements directly control the game.</span></p><p class="c10 c8"><span class="c2"></span></p><hr style="page-break-before:always;display:none;"><h1 class="c10 c16 c27" id="h.nzfhh6nf6ck6"><span class="c3 c23"></span></h1><h1 class="c10 c16" id="h.3i7jjbl5y2gb"><span class="c3 c23">High Level Overview</span></h1><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our digital pinball machine features a variety of obstacles, including pegs, rectangles, rhombuses, and triangles. We explore different approaches for detecting collisions with these different geometries and for applying appropriate collision physics to update the ball&rsquo;s motion in real time. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We further extend the hardware implementation by incorporating two sensor systems: ultrasonic distance sensors for flipper control and an infrared sensor circuit for ball launching. &nbsp;To enhance game play experience, we also add continuous background music and a discrete &ldquo;ding!&rdquo; sound effect triggered by collisions, implemented using direct memory access to enable CPU-free audio playback.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A top level view of our system is shown below:</span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 427.00px; height: 570.03px;"><img alt="" src="images/image29.png" style="width: 427.00px; height: 570.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c10 c16" id="h.7cahezvnz7hf"><span>Software Design</span></h1><h2 class="c10 c16" id="h.1jfy5d6tiq6z"><span class="c17">Collisons</span></h2><h3 class="c10 c16" id="h.hhk7of79givk"><span class="c18">Ball and Peg Collisions</span></h3><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Our second lab focused on collisions with pegs. These objects had a surface with uniform distance from the center point, so distance between the ball and the peg and normal vectors could be calculated from the peg&rsquo;s center. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 274.50px; height: 298.63px;"><img alt="" src="images/image33.png" style="width: 274.50px; height: 298.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">This helps to prevent clipping through objects in the simulation, since a collision is detected when the distance between the ball&rsquo;s center and the peg&rsquo;s center is less than the sum of their radii. This is checked again by calculating the intermediate and checking if this value is greater than zero.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c19"><img src="images/image1.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image2.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image3.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image4.png"></p><p class="c8 c19"><span class="c2"></span></p><p class="c19"><img src="images/image5.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This essentially checks the ball&#39;s trajectory with respect to the peg&rsquo;s center by comparing the magnitude of these x-components and y-components. When the velocity of the ball is directed towards the peg&rsquo;s center the intermediate will be positive, otherwise, it is zero or negative. </span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.furzu2pbmytn"><span class="c18">Buffer</span></h3><p class="c9"><span class="c2">The issue for collisions with quadrilateral objects is their non-uniform perimeter distance from their centers. This makes practically any normal vectors originating from the center incorrect for collisions with these objects. The natural adaptation is to calculate normal vectors from the perimeter lines.</span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 288.22px; height: 354.81px;"><img alt="" src="images/image41.png" style="width: 288.22px; height: 354.81px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c19 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While this method is practical, it has a key limitation: missed or late collision detection when the ball moves too quickly. Because collisions are only checked once per frame in the interrupt service routine, the ball can &ldquo;tunnel&rdquo; from outside an obstacle to already past its boundary in the next frame. In that case, when we compute the surface normal using the ball&rsquo;s current (inside) position, the normal points from the collision point inwards of the obstacle to the ball. The intermediate check then treats the ball as moving away from the obstacle, so no collision response is applied and the ball continues through the object.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The solution we used is to apply a buffer in the collision calculations such that the point where the distance and normal vector are calculated from is offset into the object. This helps preserve the normal vector&rsquo;s direction and the intermediate&rsquo;s polarity when a collision is detected while the ball&rsquo;s center is within the object.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 371.44px; height: 430.34px;"><img alt="" src="images/image42.png" style="width: 371.44px; height: 430.34px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The buffer is a function of the ball&rsquo;s velocity so it can be large enough to stop major clipping when the ball is fast and small enough to prevent a false collision when the ball is slow. A false collision occurs when the ball is detected as colliding before it meets the object&rsquo;s perimeter due to the extended range provided by a constant buffer.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image6.png"></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.wby4xzf4g28e"><span>Ball and Diagonal Line Collisions</span></h3><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collisions with quadrilateral objects are calculated by finding the point of collision along the buffered perimeter. To find this point, we project the position vector to the ball&rsquo;s center with respect to one of the object&rsquo;s vertices, A, onto the perimeter from A to another vertex, B. This will give us the vector from A to the collision point P.</span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 582.00px; height: 318.00px;"><img alt="" src="images/image37.png" style="width: 582.00px; height: 318.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c19"><img src="images/image7.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image8.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image9.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image10.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note that for collisions with diagonal line segments, we only apply the buffer to the y components for two reasons. First, it will also offset the x component of distance due to the angle of the perimeter. Second, acceleration between collisions is completely due to gravity, so very often the y component of velocity is intense enough to risk clipping. From this collision point with an applied buffer, we calculate the distance to the ball&rsquo;s center.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image11.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">We then calculate the normal vector and intermediate the same as for a peg and check that a collision occurs.</span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.bf4973x14s6u"><span class="c18">Ball and Rectangle Collisions</span></h3><p class="c9"><span class="c2">The process for horizontal and vertical lines is straightforward. Since the perimeter is parallel to the x or y axis, we can simply use the ball&rsquo;s x coordinate for horizontal lines and y coordinate for vertical lines to find the collision point.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c19"><img src="images/image12.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image13.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image14.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image15.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.dima3btsxjc0"><span class="c18">Resolve Collision</span></h3><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a collision is confirmed, we shift the ball out of the object in the normal vector direction with a magnitude of collision distance + 1 pixel.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image1.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image16.png"></p><p class="c19 c8"><span class="c2"></span></p><p class="c19"><img src="images/image17.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image18.png"><span class="c2">)</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then, we update the ball&rsquo;s velocity and apply a 0.75 bounciness factor. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image19.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><img src="images/image20.png"></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>Should either component of the resulting velocity exceed the magnitude of a constant </span><span class="c11">max_velocity</span><span>&nbsp;(35 pixels per frame at 30 FPS)</span><span class="c2">, we reduce it to equal the max. This value was chosen based on testing, where above this we observed some clipping and similar issues despite buffering and other countermeasures.</span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.p98mvq538ey4"><span>Ball and Flipper Collision Check</span></h3><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collisions with flippers differ from collisions with stationary obstacles because they are rigid-body collisions involving a rotating body rather than interactions with a stationary surface. Therefore, once a collision with a flipper has been detected, we compute the collision physics separately. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The flippers undergo rigid-body rotation and therefore have nonzero surface velocity at the point of contact, which means the collision must account for momentum and energy transfer from the rotating rigid body to the ball. This allows the flipper to actively impart velocity to the ball, rather than simply reflecting its incoming motion.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 198.67px;"><img alt="" src="images/image27.png" style="width: 624.00px; height: 198.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;At the moment of impact, we first find the surface velocity of the flipper at the contact point. Next, we find the relative velocity of the ball between the ball velocity and surface velocity. This transforms the collision into the flipper&rsquo;s local frame, where the contact surface is momentarily at rest and standard rigid-body collision physics can be applied.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 161.33px;"><img alt="" src="images/image47.png" style="width: 624.00px; height: 161.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The relative velocity is then decomposed into normal and tangential components. The normal component is what causes the collision, so we apply collision physics to this component whereas the tangential component remains constant throughout the collision. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The velocity along the normal is dependent on the coefficient of restitution, which models how elastic the collision is. In our case, since large velocities cause the ball to clip through obstacles, we set the coefficient value to 0.1. We flip the direction of the normal component and then apply the coefficient of restitution. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 230.67px;"><img alt="" src="images/image25.png" style="width: 624.00px; height: 230.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Next, we calculate the change in the normal component of the relative velocity, &#8710;n, and add it to the pre-collision relative velocity to obtain the new relative velocity after the collision. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finally, we find the final velocity of the ball after the collision. Since the surface velocity of the flipper has not changed, we can calculate the ball&rsquo;s world-frame velocity by adding the post-collision relative velocity to the flipper&rsquo;s surface velocity at the contact point.</span></p><p class="c10 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.byeewal1j6k"><span class="c17">Game State</span></h2><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 457.50px; height: 137.84px;"><img alt="" src="images/image30.png" style="width: 457.50px; height: 137.84px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c19 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.5ml42sr4k1sp"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The program has a state machine that cycles between default state and end state. In default state, the animation thread generates the VGA display, handles ball motion and respawns, and updates lives and scoreboard; the sonar thread reads signals from the sonar sensors and handles flipper motions; the IR thread reads signals from the IR muscle sensor and handles launching the ball when the relaunch sequence is prompted. The default state is essentially regular gameplay.</span></h2><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The animation thread changes the game state to end when the ball hits the bottom boundary and lives are reduced to zero. In the end state, the animation thread displays the highest score for the most recent play through and a prompt to flex to restart. The sonar thread yields during end state and the IR thread waits for a signal above its threshold before switching the game state back to default and resetting lives and highscore.</span></p><p class="c10 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.6ivs8unz4zbf"><span class="c17">Visuals</span></h2><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The animation thread calls all functions for drawing the VGA display except for the flippers which are drawn in the sonar thread. Everytime this thread runs, it starts by checking the game state. In the default state, if it has just switched from the end state then it sets all pixels to black (0) using </span><span class="c11">fillRect()</span><span>&nbsp;across the entire screen</span><span class="c2">.</span></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.m4bam4ozx45n"><span class="c18">Drawing the Ball</span></h3><p class="c9"><span>Next is updating the ball position. The thread will assign the ball&rsquo;s current position to local variables and erase the pixels displaying the ball by setting them black with </span><span class="c11">drawBall()</span><span>. The </span><span class="c11">drawBall()</span><span>&nbsp;function simply takes the ball&rsquo;s x and y coordinates and a char indicating color as parameters and calls </span><span class="c11">fillCircle() </span><span>&nbsp;with all of the </span><span class="c11">drawBall()</span><span>&nbsp;parameters in addition to the global value indicating the ball&rsquo;s radius (8)</span><span>. If the ball is not set to relaunch, then </span><span class="c11">ballMotion()</span><span>&nbsp;is called with the memory address for the ball struct as an input. This is where collision calculations and position updates between frames are completed. &nbsp;Next, the animation thread calls </span><span class="c11">wallsAndEdges()</span><span class="c2">&nbsp;to check collisions specifically with the boundaries. With all changes in the ball&rsquo;s position resolved, the thread&rsquo;s local variables for the ball&rsquo;s position are updated. The ball is redrawn after all other drawing functions in the thread have been called.</span></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.9d5i6rblq6k4"><span class="c18">Drawing the Background and Boundaries</span></h3><p class="c9"><span class="c11">drawBackground()</span><span>&nbsp;is called to draw the borders and most of the background visual effects. First, this function calls </span><span class="c11">drawLine()</span><span>&nbsp;twice to draw the slanted edge in both upper corners, </span><span class="c11">drawVLine()</span><span>&nbsp;to draw the divider for the launch chamber, and </span><span class="c11">drawRect()</span><span class="c2">&nbsp;to draw the top, left, right, and bottom borders. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">Next, variables for the circle effects around the pegs are defined including the initial radius (30), the minimum radius (15), a temporary radius (starting at initial radius), and a temporary color (starting at the global color index value). In a while loop that continues as the temporary radius shrinks from initial to below the minimum, a circle is drawn centered at each peg with a radius equal to temporary radius and color determined by the temporary color. Every loop, the temporary color is also cycled through 16 colors.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>Continuing, </span><span class="c11">drawBackground()</span><span>&nbsp;assigns three temporary color variables with color indices that are 1 apart (from 0 to 15 in a loop). </span><span class="c11">drawStar()</span><span>&nbsp;is called three times with fixed center positions, preset lengths, and temporary color variables in descending order as parameters. </span><span class="c11">drawStar()</span><span>&nbsp;starts by calculating two radii for its farthest and closest points using the length parameter and a 0.382 scale down constant. This function then implements two arrays to hold the x and y coordinates for 10 points/corners and assigns them in a for loop using sin and cos tables to step through 36&deg; intervals. In another for loop, </span><span class="c11">drawLine()</span><span class="c2">&nbsp;is repeatedly called with each point and its neighbor as parameters to draw all 10 edges. The result is a complete star, and drawbackground uses this to draw three descending stars of progressively increasing sizes at the lower center of the VGA display.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>Finally, </span><span class="c11">drawBackground</span><span>&nbsp;calls </span><span class="c11">drawTrianglePairs()</span><span>&nbsp;with the number of triangles as a parameter. </span><span class="c11">drawTrianglePairs()</span><span class="c2">&nbsp;checks which triangles to &ldquo;turn on&rdquo; based on a global variable called blink frames that functions as a frame counter. It divides the current value of blink frames by a length of time to hold the same triangle pair indicated by the variable hold frames (8 frames). This is further broken down into intervals of 6 in a variable called active index to indicate each pair. In a for loop, the function checks which pair to turn on, and for that pair, it sets a temporary color variable to pink. For all other pairs, the color variable is set to black.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>Within these loops, </span><span class="c11">drawtriangle() </span><span>is called twice with corner positions for both triangles in the pair and the temporary color value included as parameters. </span><span class="c11">drawTriangle()</span><span>&nbsp;uses the input parameters to call </span><span class="c11">drawLine() </span><span class="c2">three times to draw or erase a triangle depending on if the color input is pink or black. This creates a flashing pattern of triangles that points along the top of the rhombi towards the space between flippers.</span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.rddl4kw0ylc4"><span class="c18">Drawing the Obstacles</span></h3><p class="c9"><span>The animation thread calls </span><span class="c11">drawObstacles()</span><span>&nbsp;next to print all obstacles. In this function, all rectangle objects are drawn with </span><span class="c11">fillRect()</span><span>; all pegs are drawn with </span><span class="c11">fillCircle()</span><span>; both rhombuses are drawn with </span><span class="c11">drawVLine()</span><span>&nbsp;twice for the sides, </span><span class="c11">drawHLine()</span><span>&nbsp;for the bottom, and </span><span class="c11">drawLine()</span><span class="c2">&nbsp;for the slanted top. Each object has preset positions and sizes, and each group of objects has preset colors.</span></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.dhs6n3e6n3fb"><span class="c18">Drawing Game Information</span></h3><p class="c9"><span>We then call </span><span class="c11">drawInfo()</span><span>&nbsp;to print the game information in the top left corner. This function starts by clearing the space with a black </span><span class="c11">fillRect()</span><span>&nbsp;and setting text and cursor parameters. All text prints use </span><span class="c11">snprintf()</span><span>&nbsp;to prepare variable conversions to strings and </span><span class="c11">writeString()</span><span>&nbsp;or </span><span class="c11">writeStringBold()</span><span class="c2">&nbsp;to print to the VGA display.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c11">drawInfo()</span><span>&nbsp;prints &ldquo;Lives :&rdquo; and in a for loop ending when the loop index exceeds the number of remaining lives, the function uses </span><span class="c11">drawChar()</span><span>&nbsp;to draw hearts that indicate these remaining lives. </span><span class="c11">drawChar()</span><span class="c2">&nbsp;is given a position defined in each loop, the ASCII code for a heart (0x03), the char for red (8), the char for black (0), and text size (1) as parameters. Afterwards, the cursor and text color are readjusted before printing the current score and high score with cursor adjustments in between prints.</span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.wkmp9wgy1nob"><span class="c18">Draw Score Stars</span></h3><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Here is where the global variable blink frames increments up by 1. If blink frames is a multiple of the global constant hold frames then the global variable color index is also incremented up by 1. In </span><span class="c11">ballMotion()</span><span class="c2">, whenever a collision occurs with objects other than the rhombi, launch divider, and flippers, a global variable star blink counter is assigned a value equal to the sum of the constant number of frames to hold white and the constant number of frames to hold yellow (22).</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the animation thread, if the star blink counter is greater than 0 then while it is greater than the global constant for the number of white frames it will call </span><span class="c11">blinkStars()</span><span class="c2">&nbsp;with the color index for yellow (11) as a parameter. Otherwise, if the star blink counter is greater than 0 then it will call the same function with the color index for white (15) as a parameter. If the star blink counter is 0 or less, then the same function is called with black as the parameter.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c11">blinkStars()</span><span>&nbsp;calls the </span><span class="c11">drawStar()</span><span>&nbsp;function 5 times with 5 positions along the top of the display. Each star has matching lengths and colors based on the parameter for </span><span class="c11">blinkStars()</span><span class="c2">.</span></p><p class="c9 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.f5wa26bpntcm"><span class="c18">Draw Relaunch Instructions</span></h3><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If relaunch is enabled, then the animation thread calls </span><span class="c11">relaunchCountdown()</span><span>&nbsp;instead of </span><span class="c11">ballmotion()</span><span>. </span><span class="c11">relaunchCountdown()</span><span>&nbsp;prints an instruction telling the user to flex which will create an IR muscle sensor signal that triggers a ball launch. This function also prints a countdown that starts when the global variable relaunch counter starts decrementing. This function clears the allocated area with a black </span><span class="c11">fillRect()</span><span class="c2">&nbsp;0.25 seconds before the countdown ends and the ball launches</span></p><p class="c10 c8"><span class="c2"></span></p><h3 class="c10 c16" id="h.cbdxp87gftth"><span class="c18">Draw End Screen</span></h3><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the game state is set to end state, the animation thread will only call </span><span class="c11">drawEndScreen()</span><span>&nbsp;once and do nothing else until the game state is changed back to default in the IR thread. </span><span class="c11">drawEndScreen()</span><span>&nbsp;clears the whole VGA display with a black </span><span class="c11">fillRect()</span><span class="c2">. It then prints a large game over message including the high score for the most recent play through. Last, this function prints a prompt to the user to flex to continue playing.</span></p><p class="c10 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.5ow1v9bjo8gc"><span class="c17">Sound Design</span></h2><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Two sounds are to be generated: the first is the background music for the game, which should play throughout the time the pinball machine is active. The other sound should be a classic &ldquo;ding!&rdquo; sound when the ball collides with an obstacle, similar to a real pinball machine. Unlike in previous labs, however, these sounds are not easily synthesized by way of simple sine waves. Therefore, we use music found online and download them as wav files, which we then convert to DAC-compatible data. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">Our first approach was to use the same SPI channel (SPI0), and have 2 sets of control and data channels that feed data to the SPI channel. The &ldquo;ding!&rdquo; control channel would only start when a collision is detected, and write the sound data to the SPI. On the other hand, the background music control channel would be chained to its data channel, which would mean background music data is constantly being fed to the same SPI. </span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The DAC takes in digital data in 16 bits: the first 4 bits determine which DAC channel the analog signal will be output from, either channel A or B. We also set this up such that the &ldquo;ding!&rdquo; data had channel A configuration bits whereas background music data was configured with channel B&rsquo;s bits. This way, data from both music streams could be output to different channels on the DMA and different speakers. &nbsp;</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>However, this setup did not produce the expected audio output. Instead, we observed heavily distorted sounds from the speakers. Although the SPI peripheral transmits data to the DAC at the correct audio sampling rate of approximately 44 kHz, sharing a single SPI interface between two independent DMA streams caused contention at the SPI transmit path. While the SPI includes a transmit FIFO, it does not provide arbitration or timing guarantees between multiple DMA sources. As a result, audio samples from the background music and the &ldquo;ding!&rdquo; </span><span>sound</span><span class="c2">s were interleaved in time rather than mixed, violating the uniform sample timing required by the DAC. This introduced significant timing jitter and led to distorted sounds.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">As such, a simple hardware fix was to use an additional DAC and utilize both SPI peripherals, such that each audio stream is driven by its own dedicated SPI channel. GPIO pins 4&ndash;7 were configured for SPI0, while pins 8&ndash;11 were configured for SPI1. This separation eliminated timing contention between audio streams, allowing each DAC to receive samples at a stable and uniform rate and resulted in clean music playback. </span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">However, another issue that arose from this implementation was that the VGA display would briefly appear to &ldquo;shake&rdquo; during collision events. This occurred because both the VGA subsystem and the audio playback rely on DMA, and a collision triggers additional audio DMA activity. The resulting contention for shared bus and memory resources introduced small delays in the VGA pixel transfers, causing temporary timing irregularities. A fix for this was to increase the clock speed of the RP2040 to 250MHz, allowing DMA transfers to occur faster. This reduces the impact of contention between the VGA and audio DMA channels, and the VGA display was able to run as normal. </span></p><h1 class="c10 c16 c27" id="h.w3zsd4je3an2"><span class="c3 c23"></span></h1><h1 class="c10 c16" id="h.p9iibrabubnu"><span class="c3 c23">Hardware Design</span></h1><h2 class="c10 c16" id="h.d1k539vnj6u0"><span class="c17">Circuit Diagram</span></h2><p class="c10 c8"><span class="c2"></span></p><p class="c10 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.aeghwt8pkziy"><span class="c17">Sonar Sensor</span></h2><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Two ultrasonic distance sensors were used to control the flippers on the pinball machine. These sensors measure the distance between the sensor and the nearest surface, and moving closer to the sensor would cause the flippers to move upwards, whereas moving away would cause the flippers to move downwards. We used HC-SR04 sensors equipped with ultrasonic transmitter, receiver and control circuits. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The sensor is triggered by a 10 microsecond pulse, after which the sensor sends out 8 cycles of ultrasound bursts at 40 kHz to detect surfaces. After detection, it sends out an echo pulse that varies in width: a surface further away returns a longer echo pulse and vice versa. The formula for calculating the distance (in centimetres) is: echo pulse period/58.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Following the data sheet instructions, the period of the trigger pulse should be larger than 60 microseconds, such that the trigger pulse and echo pulse do not overlap. We therefore chose a PWM frequency of 1kHz. To achieve this, we set the clock divide value to 250 (corresponding to a 1MHz clock), and as a result each PWM counter tick equals 1 microsecond. Next, we set the wrap value to 1000 so each PWM period is 1 millisecond long. Finally, we set the control value to 10 such that a pulse is only 10 microseconds long. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>Next, we implement the code to measure the echo pulse. We do this by way of an IRQ, which is triggered both on the rising and falling edge of a pulse received on the input GPIOs to the echo pin on the sonar sensors. When a pulse is detected (rising edge), we enter into the IRQ and record the current system time and exit the IRQ. On the falling edge, the IRQ &nbsp;takes the difference between the current system time and the last measured system time to compute the width of the echo pulse, and updates a global </span><span class="c11">pulse_width_us</span><span>&nbsp;variable with the value. Finally, it sets a</span><span class="c11">&nbsp;pulse_ready</span><span class="c2">&nbsp;bool to true to signal to the sonar protothread that a new pulse has been detected.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>The sonar protothread is responsible for calculating the detected distance and updating the position of the flipper on the VGA screen. It is only active if the </span><span class="c11">pulse_ready</span><span>&nbsp;bool is true; otherwise, it yields to the other threads. When a new pulse is detected, it computes the distance from the </span><span class="c11">pulse_width_us</span><span class="c2">&nbsp;variable, and checks if the distance is larger than 20cm. We chose 20cm to be the threshold through experimental testing. Any distance smaller than 20cm will mean that the user is close enough to be engaging with the flippers, so the flipper should be moving upwards. Otherwise, the user is far away and the flippers should move down. This gameplay sequence was found to be the most intuitive. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The flipper position is not mapped directly to the measured distance. Instead, the distance measurement is used only to determine the direction of rotation. The flipper itself rotates at a fixed angular speed (5 rad/s), which results in smooth and visually stable motion on the VGA display. This design prevents abrupt changes in user distance from causing sudden jumps in the flipper position.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">Each frame, the flipper rotation angle is updated incrementally according to:</span></p><p class="c19 c25"><img src="images/image21.png"></p><p class="c10"><span>where </span><img src="images/image22.png"><span>t is the frame period and </span><img src="images/image23.png"><span>&nbsp;is the constant angular velocity. Although the implementation specifies the update rate in terms of radians per frame, this corresponds to a true angular velocity of </span><img src="images/image24.png"><span class="c2">&nbsp;in radians per second. &nbsp;While the flipper is updated discretely once per frame, the angular velocity itself is defined in continuous time (rad/s). This explicit angular velocity is required later when computing collision physics, since the linear velocity of points along the flipper depends on the true angular velocity rather than a frame-based update amount.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The rotation values were clamped between a minimum and maximum, which corresponds to the range of y values the tip of the flipper could be drawn at. If the rotation values were different from the previous frame, the previous flipper triangle was erased and a new triangle was drawn onto the screen.</span></p><p class="c9 c8"><span class="c2"></span></p><h2 class="c10 c16" id="h.2ygdbac60vl7"><span class="c17">Infrared (IR) Muscle Sensor</span></h2><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The IR muscle sensor is based on a prior student&rsquo;s project where they compared the effectiveness of an IR sensor with an EMG sensor for measuring muscle contractions. The IR sensor uses an IR emitter to shine a beam at the target muscle. Some rays reflect off of the muscle fibers and shine back towards an IR phototransistor positioned next to the emitter with a divider in between them.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 487.50px; height: 365.63px;"><img alt="" src="images/image40.jpg" style="width: 487.50px; height: 365.63px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c19 c8"><span class="c2"></span></p><p class="c10"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During a muscle contraction, there is a short period where the fibers are lengthened, a varying period of sustained force and fiber length, and a final period where the fibers slowly release and blood flows back into the muscle.</span><sup><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span>&nbsp;In the initial lengthening period, the muscle fibers are less reflective due to the stretched out state.</span><span class="c28">1</span><span>&nbsp;In the final period, the fiber&rsquo;s reflectivity increases beyond the resting state due to the blood flow.</span><span class="c30 c28 c36">1</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>When the IR phototransistor is hit by these reflected rays, a signal of matching intensity is sent into the filtering circuit. With a bandpass filter and careful selection of resistance and capacitance values, much of the noise and artifacts can be reduced in the final signal.</span><span class="c28">1</span><span>&nbsp;This also allows the signal from the initial lengthening to finish before the signal from the final period of returning blood flow starts.</span><span class="c28">1</span><span class="c2">&nbsp;We send the signal from the final period of the contraction through GPIO 26 (ADC channel 0) where it is converted to a digital signal using the RP2040&rsquo;s built-in analog to digital converter (ADC).</span></p><h3 class="c10 c16 c8" id="h.ptywe31q4ql4"><span class="c18"></span></h3><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The ball launch velocity is controlled using the input signal from the IR muscle sensor and managed with IR thread. When the ball hits the bottom boundary, the IR thread is signaled to relaunch the ball. The animation thread will print a prompt to the user to flex for the IR muscle sensor along with a 3 second countdown.</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>Once the IR thread detects a signal greater than the constant </span><span class="c11">IR_MIN</span><span class="c2">&nbsp;(500 in 4095 ADC range) it will start a running summation of IR muscle sensor signals and the animation thread will start the countdown. This minimum value from the IR muscle sensor prevents weak signals from triggering the launch sequence.When the global relaunch counter reaches 12 or higher (3+ seconds), the IR thread will calculate the average IR muscle sensor input over that 3 second period.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>If the average input is higher than the constant </span><span class="c11">IR_MAX </span><span>(1500 in 4095 ADC range) then it is reduced to </span><span class="c11">IR_MAX</span><span>, and if the average input is less than </span><span class="c11">IR_MIN</span><span>&nbsp;then the summation resets and the IR thread waits until it receives a signal from the IR sensor that is greater than </span><span class="c11">IR_MIN</span><span>&nbsp;again. This second </span><span class="c11">IR_MIN</span><span class="c2">&nbsp;check is a secondary measure to prevent brief, small muscle contractions from enabling the launch sequence.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span>The average IR signal is then converted to velocity on a scale such that </span><span class="c11">IR_MAX</span><span class="c2">&nbsp;converts to max velocity. The result is assigned to the respawned ball&rsquo;s y-component velocity, and this causes the ball to launch. The relaunch sequence is ended and the launch counter and tally are reset before yielding.</span></p><h3 class="c10 c16 c8" id="h.rtx1jq2rnn0o"><span class="c18"></span></h3><p class="c9"><span>When starting a new game (after losing and reaching end game state) the IR thread logic changes. Now when the input from the IR muscle sensor exceeds </span><span class="c11">IR_MIN</span><span>&nbsp;high score and lives are reset, the game state is switched to default, and relaunch is signaled to initiate the first ball launch.</span></p><hr style="page-break-before:always;display:none;"><h1 class="c10 c16 c27" id="h.w9n77atgsmk"><span class="c3 c23"></span></h1><h1 class="c10 c16" id="h.141c361axiyv"><span class="c3 c23">Results </span></h1><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The pinball game as displayed on the VGA is shown below. It has 8 rectangles, 5 pegs, and 2 rhombuses as the obstacles. The two flippers at the bottom of the screen are used to push the ball back up the screen. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 543.23px; height: 387.40px;"><img alt="" src="images/image34.png" style="width: 543.23px; height: 387.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c19 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the screenshot above, we show the instance where a ball has collided with the top of a rectangle. The shadow of the ball that appears is the previous position of the ball. The next position of the ball is correctly drawn: we see that the new position of the ball is just above the rectangle, which is in line with our collision logic that transports the ball just above the surface of the obstacle in event of a collision. Another hidden easter egg is shown: the stars at the top of the screen light up in yellow for a collision! &nbsp;</span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span class="c2">In general, the collision behavior of the pinball game is robust and visually realistic. Collisions between the ball and all obstacles are accurately resolved so that the ball never overlaps any surface. Upon contact, the ball is immediately reflected based on the local surface normal or surface velocity in the case of moving flippers. This results in motion that closely resembles a real pinball machine, where impacts feel responsive and predictable. </span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The muscle flexing to launch the ball is an engaging input mechanism that provides a clear sense of physical effort and direct control over the ball&rsquo;s initial velocity. The muscle sensor circuit has been set up such that even subtle changes in flexing strength cause a corresponding change in the measured signal. If the player flexes hard enough, the ball is launched with full force. Correspondingly, when the player is not flexing, the IR signal remains below the activation threshold, so the launch sequence and countdown do not begin until intentional muscle activation is detected.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">As for the flipper control, the sonar sensors correctly trigger upward flipper motion when a person is close enough and return the flippers downward when no object is detected within range. With our design choice of using the distance measurement as a per-frame directional command rather than a direct position mapping, the flippers rotate up or down smoothly, resulting in a more polished gameplay. </span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">These sensor controls provide a safe method for incorporating human movement into gameplay, as they rely only on passive sensing and do not require any electrical current to be passed through the body.</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">The music is played back reliably using DMA-driven audio output, and after utilising both SPI buses on the RP2040, both the background music and the &ldquo;ding!&rdquo; collision sounds can be produced at the same time, without any interruptions. &nbsp;</span></p><p class="c9 c8"><span class="c2"></span></p><p class="c9"><span class="c2">Finally, the game state of our system is well managed and the game over screen appears after all 3 lives have been used up. The high score of the 3 games is displayed on the screen, and the user flexes to play again. </span></p><p class="c9 c8"><span class="c2"></span></p><p class="c19"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 470.00px; height: 274.15px;"><img alt="" src="images/image39.jpg" style="width: 470.00px; height: 353.17px; margin-left: 0.00px; margin-top: -27.17px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9"><span>To get a better understanding of how the game play is like, we invite you to watch the youtube video linked in the introduction. </span></p><p class="c10 c8"><span class="c2"></span></p><h1 class="c10 c16" id="h.153fsk7dkgqb"><span class="c3 c23">Conclusion</span></h1><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overall, designing this pinball machine game and coming up with inventive ways to include human movement into the gameplay was a rewarding process. We first started with setting up the sensor circuits, then moved to writing code for collision physics, and finally integrated all pieces to present a working pinball game. As we experienced the game ourselves, we iteratively refined its mechanics and interactions to improve responsiveness, stability, and overall user experience. </span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One area of improvement would be expanding the gameplay features to increase variety and engagement. For example, allowing more balls to be animated simultaneously or introducing multiple levels with different obstacle layouts would add depth to the experience and allow the system to go beyond the limitations of a traditional pinball machine. </span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finally, we would like to thank Professor Hunter and Professor Bruce for their guidance and support throughout the project, including helping us to find safe and effective ways to measure human movement and integrate it into the gameplay design.</span></p><h1 class="c26 c16" id="h.xs2xjrk8jye4"><span class="c3 c23">Appendix A &ndash; Permissions</span></h1><p class="c10"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The group approves this report for inclusion on the course website. The group approves the video for inclusion on the course youtube channel.</span></p><h1 class="c26 c16" id="h.8se1i7fhvbjl"><span class="c3 c23">Appendix B &ndash; Work Division</span></h1><p class="c10"><span class="c2">Tianqi: Sonar Sensor circuits, Collision Physics, Game Design, Music </span></p><p class="c10"><span class="c2">Kedar: IR Sensor circuit, Collision Physics, Game Design</span></p><hr style="page-break-before:always;display:none;"><h1 class="c26 c16 c27" id="h.2kp2o34msg11"><span class="c3 c23"></span></h1><h1 class="c16 c26" id="h.6bc29k42qoyl"><span class="c3 c23">Appendix C &ndash; Code </span></h1><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span class="c2">Animation.c file:</span></p><p class="c10"><span>&#8203;&#8203;</span><span class="c7 c1">/**</span></p><p class="c0"><span class="c7 c1">* Hunter Adams (vha3@cornell.edu)</span></p><p class="c0"><span class="c7 c1">*</span></p><p class="c0"><span class="c7 c1">*</span></p><p class="c0"><span class="c7 c1">* HARDWARE CONNECTIONS</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 16 ---&gt; VGA Hsync</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 17 ---&gt; VGA Vsync</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 18 ---&gt; VGA Green lo-bit --&gt; 470 ohm resistor --&gt; VGA_Green</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 19 ---&gt; VGA Green hi_bit --&gt; 330 ohm resistor --&gt; VGA_Green</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 20 ---&gt; 330 ohm resistor ---&gt; VGA-Blue</span></p><p class="c0"><span class="c7 c1">&nbsp; - GPIO 21 ---&gt; 330 ohm resistor ---&gt; VGA-Red</span></p><p class="c0"><span class="c7 c1">&nbsp; - RP2040 GND ---&gt; VGA-GND</span></p><p class="c0"><span class="c7 c1">*</span></p><p class="c0"><span class="c7 c1">* RESOURCES USED</span></p><p class="c0"><span class="c7 c1">* &nbsp;- PIO state machines 0, 1, and 2 on PIO instance 0</span></p><p class="c0"><span class="c7 c1">* &nbsp;- DMA channels obtained by claim mechanism</span></p><p class="c0"><span class="c7 c1">* &nbsp;- 153.6 kBytes of RAM (for pixel color data)</span></p><p class="c0"><span class="c7 c1">*</span></p><p class="c0"><span class="c7 c1">*/</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// VGA graphics library</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;vga16_graphics_v2.h&quot;</span></p><p class="c0"><span class="c7 c1">// Standard libraries</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&lt;stdio.h&gt;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&lt;stdlib.h&gt;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&lt;math.h&gt;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&lt;string.h&gt;</span></p><p class="c0"><span class="c7 c1">// Pico libraries</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;pico/stdlib.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;pico/divider.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;pico/multicore.h&quot;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Hardware libraries</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/clocks.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/pio.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/dma.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/adc.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/pwm.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/irq.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/spi.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;hardware/pll.h&quot;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Protothreads</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;pt_cornell_rp2040_v1_4.h&quot;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + + BEGIN ANIMATION CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">char</span><span class="c1">&nbsp;color_index = </span><span class="c1 c6">0</span><span class="c3 c1">&nbsp;;</span></p><p class="c0"><span class="c1 c4">typedef</span><span class="c1">&nbsp;</span><span class="c1 c4">struct</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1x, B1y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2x, B2y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Tx, Ty;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1x_m, B1y_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2x_m, B2y_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Tx_m, &nbsp;Ty_m;</span></p><p class="c0"><span class="c3 c1">} TrianglePair;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">TrianglePair triangle_pairs[</span><span class="c1 c6">6</span><span class="c3 c1">] = {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">40</span><span class="c1">,</span><span class="c1 c6">303</span><span class="c1">, </span><span class="c1 c6">49</span><span class="c1">,</span><span class="c1 c6">286</span><span class="c1">, </span><span class="c1 c6">71</span><span class="c1">,</span><span class="c1 c6">309</span><span class="c1">, &nbsp; </span><span class="c1 c6">600</span><span class="c1">,</span><span class="c1 c6">303</span><span class="c1">, </span><span class="c1 c6">591</span><span class="c1">,</span><span class="c1 c6">286</span><span class="c1">, </span><span class="c1 c6">569</span><span class="c1">,</span><span class="c1 c6">309</span><span class="c1">},</span><span class="c7 c1">&nbsp; // 0</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">76</span><span class="c1">,</span><span class="c1 c6">324</span><span class="c1">, </span><span class="c1 c6">86</span><span class="c1">,</span><span class="c1 c6">306</span><span class="c1">, </span><span class="c1 c6">107</span><span class="c1">,</span><span class="c1 c6">330</span><span class="c1">, &nbsp;</span><span class="c1 c6">564</span><span class="c1">,</span><span class="c1 c6">324</span><span class="c1">, </span><span class="c1 c6">554</span><span class="c1">,</span><span class="c1 c6">306</span><span class="c1">, </span><span class="c1 c6">533</span><span class="c1">,</span><span class="c1 c6">330</span><span class="c1">},</span><span class="c7 c1">&nbsp; // 1</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">113</span><span class="c1">,</span><span class="c1 c6">345</span><span class="c1">,</span><span class="c1 c6">123</span><span class="c1">,</span><span class="c1 c6">327</span><span class="c1">,</span><span class="c1 c6">144</span><span class="c1">,</span><span class="c1 c6">351</span><span class="c1">, &nbsp;</span><span class="c1 c6">527</span><span class="c1">,</span><span class="c1 c6">345</span><span class="c1">, </span><span class="c1 c6">517</span><span class="c1">,</span><span class="c1 c6">327</span><span class="c1">, </span><span class="c1 c6">496</span><span class="c1">,</span><span class="c1 c6">351</span><span class="c1">},</span><span class="c7 c1">&nbsp; // 2</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">149</span><span class="c1">,</span><span class="c1 c6">365</span><span class="c1">,</span><span class="c1 c6">159</span><span class="c1">,</span><span class="c1 c6">348</span><span class="c1">,</span><span class="c1 c6">180</span><span class="c1">,</span><span class="c1 c6">371</span><span class="c1">, &nbsp;</span><span class="c1 c6">491</span><span class="c1">,</span><span class="c1 c6">365</span><span class="c1">, </span><span class="c1 c6">481</span><span class="c1">,</span><span class="c1 c6">348</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">,</span><span class="c1 c6">371</span><span class="c1">},</span><span class="c7 c1">&nbsp; // 3</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">186</span><span class="c1">,</span><span class="c1 c6">386</span><span class="c1">,</span><span class="c1 c6">196</span><span class="c1">,</span><span class="c1 c6">369</span><span class="c1">,</span><span class="c1 c6">217</span><span class="c1">,</span><span class="c1 c6">392</span><span class="c1">, &nbsp;</span><span class="c1 c6">454</span><span class="c1">,</span><span class="c1 c6">386</span><span class="c1">, </span><span class="c1 c6">444</span><span class="c1">,</span><span class="c1 c6">369</span><span class="c1">, </span><span class="c1 c6">423</span><span class="c1">,</span><span class="c1 c6">392</span><span class="c1">},</span><span class="c7 c1">&nbsp; // 4</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{</span><span class="c1 c6">222</span><span class="c1">,</span><span class="c1 c6">407</span><span class="c1">,</span><span class="c1 c6">232</span><span class="c1">,</span><span class="c1 c6">389</span><span class="c1">,</span><span class="c1 c6">253</span><span class="c1">,</span><span class="c1 c6">413</span><span class="c1">, &nbsp;</span><span class="c1 c6">418</span><span class="c1">,</span><span class="c1 c6">407</span><span class="c1">, </span><span class="c1 c6">408</span><span class="c1">,</span><span class="c1 c6">389</span><span class="c1">, </span><span class="c1 c6">387</span><span class="c1">,</span><span class="c1 c6">413</span><span class="c1">}</span><span class="c7 c1">&nbsp; &nbsp;// 5</span></p><p class="c0"><span class="c3 c1">};</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;cos1000[</span><span class="c1 c6">10</span><span class="c1">] = { </span><span class="c1 c6">0</span><span class="c1">,</span><span class="c1 c6">587</span><span class="c1">,</span><span class="c1 c6">951</span><span class="c1">,</span><span class="c1 c6">951</span><span class="c1">,</span><span class="c1 c6">587</span><span class="c1">,</span><span class="c1 c6">0</span><span class="c1">,-</span><span class="c1 c6">587</span><span class="c1">,-</span><span class="c1 c6">951</span><span class="c1">,-</span><span class="c1 c6">951</span><span class="c1">,-</span><span class="c1 c6">587</span><span class="c3 c1">&nbsp;};</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;sin1000[</span><span class="c1 c6">10</span><span class="c1">] = {-</span><span class="c1 c6">1000</span><span class="c1">,-</span><span class="c1 c6">809</span><span class="c1">,-</span><span class="c1 c6">309</span><span class="c1">,</span><span class="c1 c6">309</span><span class="c1">,</span><span class="c1 c6">809</span><span class="c1">,</span><span class="c1 c6">1000</span><span class="c1">,</span><span class="c1 c6">809</span><span class="c1">,</span><span class="c1 c6">309</span><span class="c1">,-</span><span class="c1 c6">309</span><span class="c1">,-</span><span class="c1 c6">809</span><span class="c3 c1">};</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;blink_frames = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;hold_frames = </span><span class="c1 c6">2</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;drawTriangle(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">a_x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">a_y</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">b_x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">b_y</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">c_x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">c_y</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">color</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;vert_length = b_y - a_y;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;hori_width = c_x - b_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;drawLine(a_x, a_y, b_x, b_y, color);</span></p><p class="c0"><span class="c3 c1">&nbsp;drawLine(b_x, b_y, c_x, c_y, color);</span></p><p class="c0"><span class="c3 c1">&nbsp;drawLine(a_x, a_y, c_x, c_y, color);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;drawStar(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">center_x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">center_y</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">length</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">color</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;outer_r = length / </span><span class="c1 c6">2</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;inner_r = (outer_r * </span><span class="c1 c6">382</span><span class="c1">) / </span><span class="c1 c6">1000</span><span class="c1">;</span><span class="c7 c1">&nbsp; &nbsp;// integer 0.382</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;px[</span><span class="c1 c6">10</span><span class="c3 c1">];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;py[</span><span class="c1 c6">10</span><span class="c3 c1">];</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">for</span><span class="c1">(</span><span class="c1 c4">int</span><span class="c1">&nbsp;i = </span><span class="c1 c6">0</span><span class="c1">; i &lt; </span><span class="c1 c6">10</span><span class="c3 c1">; i++){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;r = (i % </span><span class="c1 c6">2</span><span class="c1">&nbsp;== </span><span class="c1 c6">0</span><span class="c3 c1">) ? outer_r : inner_r;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;px[i] = center_x + (r * cos1000[i]) / </span><span class="c1 c6">1000</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;py[i] = center_y + (r * sin1000[i]) / </span><span class="c1 c6">1000</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">for</span><span class="c1">(</span><span class="c1 c4">int</span><span class="c1">&nbsp;i = </span><span class="c1 c6">0</span><span class="c1">; i &lt; </span><span class="c1 c6">10</span><span class="c3 c1">; i++){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;j = (i + </span><span class="c1 c6">1</span><span class="c1">) % </span><span class="c1 c6">10</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawLine(px[i], py[i], px[j], py[j], color);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;drawTrianglePairs(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">start_x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">start_y</span><span class="c3 c1">,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">axis_x</span><span class="c3 c1">,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">num_triangles</span><span class="c3 c1">,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c1 c4">float</span><span class="c1">&nbsp;</span><span class="c1 c14">step</span><span class="c1">, </span><span class="c1 c4">float</span><span class="c1">&nbsp;</span><span class="c1 c14">h</span><span class="c1">, </span><span class="c1 c4">float</span><span class="c1">&nbsp;</span><span class="c1 c14">w</span><span class="c3 c1">)</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;triangle_hold = </span><span class="c1 c6">8</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;active_index = (blink_frames / triangle_hold) % num_triangles;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">for</span><span class="c1">(</span><span class="c1 c4">int</span><span class="c1">&nbsp;k = </span><span class="c1 c6">0</span><span class="c3 c1">; k &lt; num_triangles; k++){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;color;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">(k == active_index){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;color = PINK;</span><span class="c7 c1">&nbsp; &nbsp;// only this triangle pair is on</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;color = BLACK;</span><span class="c7 c1">&nbsp; // off triangles</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1x &nbsp;= triangle_pairs[k].B1x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1y &nbsp;= triangle_pairs[k].B1y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2x &nbsp;= triangle_pairs[k].B2x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2y &nbsp;= triangle_pairs[k].B2y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Tx &nbsp; = triangle_pairs[k].Tx;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Ty &nbsp; = triangle_pairs[k].Ty;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1x_m = triangle_pairs[k].B1x_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B1y_m = triangle_pairs[k].B1y_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2x_m = triangle_pairs[k].B2x_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;B2y_m = triangle_pairs[k].B2y_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Tx_m &nbsp;= triangle_pairs[k].Tx_m;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;Ty_m &nbsp;= triangle_pairs[k].Ty_m;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// original triangle</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(B1x, &nbsp;B1y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B2x, &nbsp;B2y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tx, &nbsp; Ty,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// mirrored triangle</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(B1x_m, B1y_m,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; B2x_m, B2y_m,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Tx_m, &nbsp;Ty_m,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;drawBackground(){</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// drawRect(4, 0, 635, 479, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">//draws the borders and the tunnel</span></p><p class="c0"><span class="c1">&nbsp;drawLine(</span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c3 c1">, WHITE);</span></p><p class="c0"><span class="c1">&nbsp;drawLine(</span><span class="c1 c6">518</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">638</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c3 c1">, WHITE);</span></p><p class="c0"><span class="c1">&nbsp;drawVLine(</span><span class="c1 c6">611</span><span class="c1">, </span><span class="c1 c6">135</span><span class="c1">, </span><span class="c1 c6">479</span><span class="c1">-</span><span class="c1 c6">135</span><span class="c3 c1">, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;drawRect(</span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">640</span><span class="c1">, </span><span class="c1 c6">480</span><span class="c3 c1">, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// circles</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;circle_radius = </span><span class="c1 c6">30</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;min_radius = </span><span class="c1 c6">15</span><span class="c3 c1">; &nbsp; &nbsp; &nbsp;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;r = circle_radius;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;local_color = color_index;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">while</span><span class="c3 c1">(r &gt; min_radius){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawCircle(</span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c3 c1">, r, local_color);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawCircle(</span><span class="c1 c6">220</span><span class="c1">, </span><span class="c1 c6">160</span><span class="c3 c1">, r, local_color);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawCircle(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">200</span><span class="c3 c1">, r, local_color);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawCircle(</span><span class="c1 c6">420</span><span class="c1">, </span><span class="c1 c6">160</span><span class="c3 c1">, r, local_color);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawCircle(</span><span class="c1 c6">520</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c3 c1">, r, local_color);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// shrink radius</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;r -= </span><span class="c1 c6">2</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// advance color</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;local_color++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">(local_color &gt;= </span><span class="c1 c6">15</span><span class="c1">) local_color = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;star0_color = color_index;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;star1_color = (color_index + </span><span class="c1 c6">1</span><span class="c1">) % </span><span class="c1 c6">15</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;star2_color = (color_index + </span><span class="c1 c6">2</span><span class="c1">) % </span><span class="c1 c6">15</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">265</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c3 c1">, star0_color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">315</span><span class="c1">, </span><span class="c1 c6">40</span><span class="c3 c1">, star1_color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">385</span><span class="c1">, </span><span class="c1 c6">70</span><span class="c3 c1">, star2_color);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;drawTrianglePairs(</span><span class="c1 c6">45</span><span class="c1">, </span><span class="c1 c6">295</span><span class="c1">, </span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">6</span><span class="c1">, </span><span class="c1 c6">42</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;blinkStars(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">color</span><span class="c3 c1">){</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">266</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c1">, </span><span class="c1 c6">16</span><span class="c3 c1">, color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">293</span><span class="c1">, </span><span class="c1 c6">31</span><span class="c1">, </span><span class="c1 c6">16</span><span class="c3 c1">, color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">47</span><span class="c1">, </span><span class="c1 c6">16</span><span class="c3 c1">, color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">347</span><span class="c1">, </span><span class="c1 c6">31</span><span class="c1">, </span><span class="c1 c6">16</span><span class="c3 c1">, color);</span></p><p class="c0"><span class="c1">&nbsp;drawStar(</span><span class="c1 c6">374</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c1">, </span><span class="c1 c6">16</span><span class="c3 c1">, color);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1 c4">char</span><span class="c3 c1">&nbsp;rhombus_colour = WHITE;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;drawObstacles(){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// top two rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">220</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">80</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">400</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">80</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// bottom two rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">280</span><span class="c1">, </span><span class="c1 c6">70</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">80</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">340</span><span class="c1">, </span><span class="c1 c6">70</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">80</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// middle circle</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillCircle(</span><span class="c1 c6">320</span><span class="c1">, </span><span class="c1 c6">200</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c3 c1">, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// 2 circles on the left</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">//left</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillCircle(</span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c3 c1">, WHITE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// right</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillCircle(</span><span class="c1 c6">220</span><span class="c1">, </span><span class="c1 c6">160</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c3 c1">, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// 2 circles on the right</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// left</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillCircle(</span><span class="c1 c6">420</span><span class="c1">, </span><span class="c1 c6">160</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c3 c1">, WHITE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// right</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillCircle(</span><span class="c1 c6">520</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">15</span><span class="c3 c1">, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// second set of rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">100</span><span class="c1">, </span><span class="c1 c6">180</span><span class="c1">, </span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">110</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">200</span><span class="c1">, </span><span class="c1 c6">220</span><span class="c1">, </span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">110</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">400</span><span class="c1">, </span><span class="c1 c6">220</span><span class="c1">, </span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">110</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">500</span><span class="c1">, </span><span class="c1 c6">180</span><span class="c1">, </span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">110</span><span class="c3 c1">, DARK_BLUE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// draw left rhombus</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawVLine(</span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">310</span><span class="c1">, </span><span class="c1 c6">150</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawHLine(</span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">200</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawVLine(</span><span class="c1 c6">240</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawLine(</span><span class="c1 c6">40</span><span class="c1">, </span><span class="c1 c6">310</span><span class="c1">, </span><span class="c1 c6">240</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// draw right rhombus</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawVLine(</span><span class="c1 c6">600</span><span class="c1">, </span><span class="c1 c6">310</span><span class="c1">, </span><span class="c1 c6">150</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawHLine(</span><span class="c1 c6">400</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">200</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawVLine(</span><span class="c1 c6">400</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;drawLine(</span><span class="c1 c6">400</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">600</span><span class="c1">, </span><span class="c1 c6">310</span><span class="c3 c1">, rhombus_colour);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + END OF ANIMATION CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// fixed point arithmetic</span></p><p class="c0"><span class="c1 c4">typedef</span><span class="c1">&nbsp;</span><span class="c1 c4">signed</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;fix15;</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">multfix15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">,</span><span class="c1 c14">b</span><span class="c1 c4">) ((fix15)((((signed long long)(a))</span><span class="c1">*</span><span class="c1 c4">((signed long long)(b)))</span><span class="c1">&gt;&gt;</span><span class="c1 c6">15</span><span class="c1 c13 c4">))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">float2fix15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) ((fix15)((a)</span><span class="c1">*</span><span class="c1 c6">32768.0</span><span class="c1 c4">))</span><span class="c7 c1">&nbsp;// 2^15</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">fix2float15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) ((float)(a)</span><span class="c1">/</span><span class="c1 c6">32768.0</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">absfix15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) </span><span class="c1">abs</span><span class="c1 c13 c4">(a)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">int2fix15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) ((fix15)(a </span><span class="c1">&lt;&lt;</span><span class="c1 c4">&nbsp;</span><span class="c1 c6">15</span><span class="c1 c13 c4">))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">fix2int15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) ((int)(a </span><span class="c1">&gt;&gt;</span><span class="c1 c4">&nbsp;</span><span class="c1 c6">15</span><span class="c1 c13 c4">))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">char2fix15</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) (fix15)(((fix15)(a)) </span><span class="c1">&lt;&lt;</span><span class="c1 c4">&nbsp;</span><span class="c1 c6">15</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">divfix</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">,</span><span class="c1 c14">b</span><span class="c1 c4">) (fix15)(</span><span class="c1">div_s64s64</span><span class="c1 c4">( (((signed long long)(a)) </span><span class="c1">&lt;&lt;</span><span class="c1 c4">&nbsp;</span><span class="c1 c6">15</span><span class="c1 c13 c4">), ((signed long long)(b))))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">sqrtfix</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) (</span><span class="c1">float2fix15</span><span class="c1 c4">(</span><span class="c1">sqrt</span><span class="c1 c4">(</span><span class="c1">fix2float15</span><span class="c1 c13 c4">(a))))</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Some globals for storing timer information</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">unsigned</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;time_accum = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">unsigned</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;time_accum_old = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">char</span><span class="c1">&nbsp;timetext[</span><span class="c1 c6">40</span><span class="c3 c1">];</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// for square root</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">MAXIMUM</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">, </span><span class="c1 c14">b</span><span class="c1 c4">) ((a) </span><span class="c1">&gt;</span><span class="c1 c4">&nbsp;(b) </span><span class="c1">?</span><span class="c1 c4">&nbsp;(a) </span><span class="c1">:</span><span class="c1 c13 c4">&nbsp;(b))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">MINIMUM</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">, </span><span class="c1 c14">b</span><span class="c1 c4">) ((a) </span><span class="c1">&lt;</span><span class="c1 c4">&nbsp;(b) </span><span class="c1">?</span><span class="c1 c4">&nbsp;(a) </span><span class="c1">:</span><span class="c1 c13 c4">&nbsp;(b))</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 alpha = float2fix15(</span><span class="c1 c6">0.960433870103</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 beta = float2fix15(</span><span class="c1 c6">0.397824734759</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// macros for wall detection</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">rightDivider</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">611</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitBottom</span><span class="c1 c4">(</span><span class="c1 c14">b</span><span class="c1 c4">) (b</span><span class="c1">&gt;</span><span class="c1 c6">480</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitTop</span><span class="c1 c4">(</span><span class="c1 c14">b</span><span class="c1 c4">) (b</span><span class="c1">&lt;</span><span class="c1 c6">0</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitTopLeft</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">, </span><span class="c1 c14">b</span><span class="c1 c4">) (b</span><span class="c1">&lt;</span><span class="c1 c4">(</span><span class="c1 c6">120</span><span class="c1">-</span><span class="c1 c13 c4">a))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitTopRight</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">, </span><span class="c1 c14">b</span><span class="c1 c4">) (b</span><span class="c1">&lt;</span><span class="c1 c4">(a</span><span class="c1">-</span><span class="c1 c6">518</span><span class="c1 c13 c4">))</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitLeft</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) (a</span><span class="c1">&lt;</span><span class="c1 c6">0</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitRight</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">) (a</span><span class="c1">&gt;</span><span class="c1 c6">639</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">hitRightDivider</span><span class="c1 c4">(</span><span class="c1 c14">a</span><span class="c1 c4">, </span><span class="c1 c14">b</span><span class="c1 c4">) ((a</span><span class="c1">&gt;</span><span class="c1 c4">rightDivider</span><span class="c1">-</span><span class="c1 c6">2</span><span class="c1 c4">&nbsp;</span><span class="c1">&amp;&amp;</span><span class="c1 c4">&nbsp;a</span><span class="c1">&lt;</span><span class="c1 c4">rightDivider</span><span class="c1">+</span><span class="c1 c6">2</span><span class="c1 c4">) </span><span class="c1">&amp;&amp;</span><span class="c1 c4">&nbsp;b</span><span class="c1">&gt;</span><span class="c1 c6">155</span><span class="c1 c13 c4">)</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// uS per frame</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">FRAME_RATE</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">33000</span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;frames;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// globals for pinball objects and balls</span></p><p class="c0"><span class="c7 c1">// #define buffer 20 &nbsp; // accounts for direction issues that affect intermediate calculations when the ball clips to far</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">max_velocity</span><span class="c1 c4">&nbsp;</span><span class="c1">int2fix15</span><span class="c1 c4">(</span><span class="c1 c6">30</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;ball_r = </span><span class="c1 c6">8</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;peg_r = </span><span class="c1 c6">15</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">fix15 b_p_collision_distance;</span></p><p class="c0"><span class="c1">fix15 bounciness = float2fix15(</span><span class="c1 c6">0.75</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">fix15 gravity = float2fix15(</span><span class="c1 c6">0.85</span><span class="c3 c1">);</span></p><p class="c0"><span class="c3 c1">fix15 initial_velocity;</span></p><p class="c0"><span class="c1 c4">char</span><span class="c3 c1">&nbsp;color = WHITE;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// globals for game state</span></p><p class="c0"><span class="c7 c1">// count up to 12, 0.25 * 12 = 3</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;relaunch_counter = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">bool</span><span class="c1">&nbsp;relaunch = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">enum</span><span class="c3 c1">&nbsp;gameState {</span></p><p class="c0"><span class="c3 c1">&nbsp;DEFAULT,</span></p><p class="c0"><span class="c3 c1">&nbsp;END</span></p><p class="c0"><span class="c3 c1">};</span></p><p class="c0"><span class="c1 c4">enum</span><span class="c3 c1">&nbsp;gameState state = DEFAULT;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">typedef</span><span class="c1">&nbsp;</span><span class="c1 c4">struct</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;x, y;</span></p><p class="c0"><span class="c3 c1">} Point;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">typedef</span><span class="c1">&nbsp;</span><span class="c1 c4">struct</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 x, y, vx, vy;</span></p><p class="c0"><span class="c3 c1">} Ball;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">Ball ball;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// numbered left to right with vertices starting at upper left most corner</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 0, 1 are flippers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 2, 3 are bottom trapezoids</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 4 - 7 are middle rectangles (add in once vertices are decided)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 8 - 12 are pegs (starts with center then from left most to right)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 13 - 16 are upper rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 17, 18 are upper left and right slanted bounds</span></p><p class="c0"><span class="c1">Point object_points[</span><span class="c1 c6">18</span><span class="c1">][</span><span class="c1 c6">4</span><span class="c3 c1">] = {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">245</span><span class="c1">), int2fix15 (</span><span class="c1 c6">430</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">305</span><span class="c1">), int2fix15(</span><span class="c1 c6">460</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">335</span><span class="c1">), int2fix15(</span><span class="c1 c6">460</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">395</span><span class="c1">), int2fix15 (</span><span class="c1 c6">430</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">40</span><span class="c1">), &nbsp;int2fix15 (</span><span class="c1 c6">310</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">40</span><span class="c1">), &nbsp;int2fix15 (</span><span class="c1 c6">460</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">240</span><span class="c1">), int2fix15 (</span><span class="c1 c6">460</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">240</span><span class="c1">), int2fix15 (</span><span class="c1 c6">430</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">430</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">460</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">600</span><span class="c1">), int2fix15 (</span><span class="c1 c6">460</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">600</span><span class="c1">), int2fix15 (</span><span class="c1 c6">310</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">100</span><span class="c1">), int2fix15 (</span><span class="c1 c6">180</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">100</span><span class="c1">), int2fix15 (</span><span class="c1 c6">290</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">140</span><span class="c1">), int2fix15 (</span><span class="c1 c6">290</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">140</span><span class="c1">), int2fix15 (</span><span class="c1 c6">180</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">200</span><span class="c1">), int2fix15 (</span><span class="c1 c6">220</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">200</span><span class="c1">), int2fix15 (</span><span class="c1 c6">330</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">240</span><span class="c1">), int2fix15 (</span><span class="c1 c6">330</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">240</span><span class="c1">), int2fix15 (</span><span class="c1 c6">220</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">220</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">330</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">440</span><span class="c1">), int2fix15 (</span><span class="c1 c6">330</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">440</span><span class="c1">), int2fix15 (</span><span class="c1 c6">220</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">500</span><span class="c1">), int2fix15 (</span><span class="c1 c6">180</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">500</span><span class="c1">), int2fix15 (</span><span class="c1 c6">290</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">540</span><span class="c1">), int2fix15 (</span><span class="c1 c6">290</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">540</span><span class="c1">), int2fix15 (</span><span class="c1 c6">180</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">320</span><span class="c1">), int2fix15(</span><span class="c1 c6">200</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">220</span><span class="c1">), int2fix15(</span><span class="c1 c6">160</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">420</span><span class="c1">), int2fix15(</span><span class="c1 c6">160</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">120</span><span class="c1">), int2fix15(</span><span class="c1 c6">120</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">520</span><span class="c1">), int2fix15(</span><span class="c1 c6">120</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">220</span><span class="c1">), int2fix15 (</span><span class="c1 c6">20</span><span class="c1">)}, &nbsp;{int2fix15 (</span><span class="c1 c6">220</span><span class="c1">), int2fix15 (</span><span class="c1 c6">100</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">240</span><span class="c1">), int2fix15 (</span><span class="c1 c6">100</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">240</span><span class="c1">), int2fix15(</span><span class="c1 c6">20</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">280</span><span class="c1">), int2fix15 (</span><span class="c1 c6">70</span><span class="c1">)}, &nbsp;{int2fix15 (</span><span class="c1 c6">280</span><span class="c1">), int2fix15 (</span><span class="c1 c6">150</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">300</span><span class="c1">), int2fix15 (</span><span class="c1 c6">150</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">300</span><span class="c1">), int2fix15(</span><span class="c1 c6">70</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">340</span><span class="c1">), int2fix15 (</span><span class="c1 c6">70</span><span class="c1">)}, &nbsp;{int2fix15 (</span><span class="c1 c6">340</span><span class="c1">), int2fix15 (</span><span class="c1 c6">150</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">360</span><span class="c1">), int2fix15 (</span><span class="c1 c6">150</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">360</span><span class="c1">), int2fix15(</span><span class="c1 c6">70</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15 (</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">20</span><span class="c1">)}, &nbsp;{int2fix15 (</span><span class="c1 c6">400</span><span class="c1">), int2fix15 (</span><span class="c1 c6">100</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">420</span><span class="c1">), int2fix15 (</span><span class="c1 c6">100</span><span class="c1">)}, {int2fix15(</span><span class="c1 c6">420</span><span class="c1">), int2fix15(</span><span class="c1 c6">20</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;{{int2fix15(</span><span class="c1 c6">611</span><span class="c1">), int2fix15 (</span><span class="c1 c6">135</span><span class="c1">)}, {int2fix15 (</span><span class="c1 c6">611</span><span class="c1">), int2fix15(</span><span class="c1 c6">479</span><span class="c3 c1">)}},</span></p><p class="c0"><span class="c3 c1">};</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;drawBall(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">x</span><span class="c1">, </span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">y</span><span class="c1">, </span><span class="c1 c4">char</span><span class="c1">&nbsp;</span><span class="c1 c14">c</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">//center</span></p><p class="c0"><span class="c3 c1">&nbsp;fillCircle(x, y, ball_r, c);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Create a ball</span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;spawnBall(Ball* </span><span class="c1 c14">b</span><span class="c3 c1">)</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Start in launch chamber with 0 initial velocity</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;x = int2fix15(</span><span class="c1 c6">625</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;y = int2fix15(</span><span class="c1 c6">445</span><span class="c1">);</span><span class="c7 c1">&nbsp;//460</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;vx = int2fix15(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;vy = int2fix15(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// For Testing</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// 69 for left, 570 for right</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// b-&gt;x = int2fix15(519); //519, 120</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// b-&gt;y = int2fix15(320);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// b-&gt;vx = int2fix15(0);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// b-&gt;vy = int2fix15(10);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 inv_sqrt2 = float2fix15(</span><span class="c1 c6">0.70710678f</span><span class="c1">);</span><span class="c7 c1">&nbsp; // 1/sqrt(2)</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;lives = </span><span class="c1 c6">3</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;score = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;high_score = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Detect wallstrikes, update velocity and position</span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;wallsAndEdges(Ball* </span><span class="c1 c14">b</span><span class="c3 c1">)</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;b_x = fix2int15(b-&gt;x);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;b_y = fix2int15(b-&gt;y);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;temp;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Reverse direction if we&#39;ve hit a wall</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitTop(b_y)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vy = -(b-&gt;vy) &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;y &nbsp;= int2fix15(ball_r);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitTopLeft(b_x, b_y)) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;temp = b-&gt;vy;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// reflect across the left slanted wall</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// choose the mapping that looks good for you</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vy = -(b-&gt;vx) &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vx = -(temp) &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// push ball inside along down-right normal</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 push = int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 nx = &nbsp;inv_sqrt2;</span><span class="c7 c1">&nbsp; // x component &gt; 0 (to the right)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 ny = &nbsp;inv_sqrt2;</span><span class="c7 c1">&nbsp; // y component &gt; 0 (down)</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;x += multfix15(nx, push);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;y += multfix15(ny, push);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitTopRight(b_x, b_y)) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;temp = b-&gt;vx;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// reflect across the right slanted wall</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vx = b-&gt;vy &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vy = temp &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// push ball inside along down-left normal</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 push = int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 nx = -inv_sqrt2;</span><span class="c7 c1">&nbsp; // x component &lt; 0 (to the left)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fix15 ny = &nbsp;inv_sqrt2;</span><span class="c7 c1">&nbsp; // y component &gt; 0 (down)</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;x += multfix15(nx, push);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;y += multfix15(ny, push);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitBottom(b_y)) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;spawnBall(b);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;relaunch = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;lives--;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(score &gt; high_score) high_score = score;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;score = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(lives &lt; </span><span class="c1 c6">1</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;state = END;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;state = DEFAULT;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitRight(b_x)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vx = -(b-&gt;vx) &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;x &nbsp;= int2fix15(</span><span class="c1 c6">639</span><span class="c3 c1">&nbsp;- ball_r);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(hitLeft(b_x)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;b-&gt;vx = -(b-&gt;vx) &gt;&gt; </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;b-&gt;x &nbsp;= int2fix15(ball_r);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">bool</span><span class="c1">&nbsp;checkDiagonalCollision(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">i</span><span class="c1">, fix15 *</span><span class="c1 c14">dx</span><span class="c1">, fix15 *</span><span class="c1 c14">dy</span><span class="c1">, fix15 *</span><span class="c1 c14">distance</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_x</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_y</span><span class="c1">, fix15 *</span><span class="c1 c14">buffer</span><span class="c1">, Ball* </span><span class="c1 c14">b</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 projection;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JK_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JK_y;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JC_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JC_y;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JC_dot_JK;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 JK_dot_JK;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 side;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dy;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;second_vertex;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// buffer should be tied to x and y velocity</span></p><p class="c0"><span class="c3 c1">&nbsp;*buffer = absfix15(b-&gt;vy) + absfix15(b-&gt;vx);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i == </span><span class="c1 c6">0</span><span class="c1">&nbsp;|| i == </span><span class="c1 c6">1</span><span class="c1">) second_vertex = </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;second_vertex = </span><span class="c1 c6">3</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// always vertex 1 to 0</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// or vertex 3 to 0</span></p><p class="c0"><span class="c1">&nbsp;JK_x = object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].x - object_points[i][second_vertex].x;</span></p><p class="c0"><span class="c1">&nbsp;JK_y = object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].y - object_points[i][second_vertex].y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;JC_x = b-&gt;x - object_points[i][second_vertex].x;</span></p><p class="c0"><span class="c3 c1">&nbsp;JC_y = b-&gt;y - (object_points[i][second_vertex].y + *buffer);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// ball must be above J-&gt;K</span></p><p class="c0"><span class="c3 c1">&nbsp;side = multfix15(JK_x, JC_y) - multfix15(JK_y, JC_x);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// If the ball is on the wrong side of the line, stop checking this segment</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Pick &lt; 0 or &gt; 0 depending on which side you want to keep</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(side &lt; </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// goes to next object</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">false</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;JC_dot_JK = multfix15(JC_x, JK_x) + multfix15(JC_y, JK_y);</span></p><p class="c0"><span class="c3 c1">&nbsp;JK_dot_JK = multfix15(JK_x, JK_x) + multfix15(JK_y, JK_y);</span></p><p class="c0"><span class="c3 c1">&nbsp;projection = divfix(JC_dot_JK, JK_dot_JK);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(projection &gt; int2fix15(</span><span class="c1 c6">1</span><span class="c3 c1">)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;*collision_point_x = object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;*collision_point_y = object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].y + *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(projection &lt; int2fix15(</span><span class="c1 c6">0</span><span class="c3 c1">)) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;*collision_point_x = object_points[i][second_vertex].x;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;*collision_point_y = object_points[i][second_vertex].y + *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;*collision_point_x = object_points[i][second_vertex].x + multfix15(projection, JK_x);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;*collision_point_y = (object_points[i][second_vertex].y + *buffer) + multfix15(projection, JK_y);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;*dx = b-&gt;x - *collision_point_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;*dy = b-&gt;y - *collision_point_y;</span></p><p class="c0"><span class="c3 c1">&nbsp;abs_dx = absfix15(*dx);</span></p><p class="c0"><span class="c3 c1">&nbsp;abs_dy = absfix15(*dy);</span></p><p class="c0"><span class="c1">&nbsp; </span><span class="c7 c1">//collision check</span></p><p class="c0"><span class="c3 c1">&nbsp;*distance = multfix15(alpha, MAXIMUM(abs_dx, abs_dy)) + multfix15(beta, MINIMUM(abs_dx, abs_dy));</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(*distance &lt; int2fix15(ball_r) + *buffer) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">bool</span><span class="c1">&nbsp;checkVerticalCollision(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">i</span><span class="c1">, fix15 *</span><span class="c1 c14">dx</span><span class="c1">, fix15 *</span><span class="c1 c14">dy</span><span class="c1">, fix15 *</span><span class="c1 c14">distance</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_x</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_y</span><span class="c1">, fix15 *</span><span class="c1 c14">buffer</span><span class="c1">, Ball* </span><span class="c1 c14">b</span><span class="c1">, </span><span class="c1 c4">bool</span><span class="c1">&nbsp;</span><span class="c1 c14">check_one</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 lower_bound;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 upper_bound;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dy;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;limit;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// buffer should be tied to x velocity bc vertical collision</span></p><p class="c0"><span class="c3 c1">&nbsp;*buffer = absfix15(b-&gt;vy) + absfix15(b-&gt;vx);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// we have a pair of lines to check; the first is 0-1 and other 3-2</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">for</span><span class="c1">&nbsp;(</span><span class="c1 c4">int</span><span class="c1">&nbsp;seg = </span><span class="c1 c6">0</span><span class="c1">; seg &lt; </span><span class="c1 c6">2</span><span class="c3 c1">; seg++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;j, k;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(seg == </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;j = </span><span class="c1 c6">0</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;k = </span><span class="c1 c6">1</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_x = object_points[i][j].x + *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(check_one){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;j = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;k = </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;j = </span><span class="c1 c6">3</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;k = </span><span class="c1 c6">2</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_x = object_points[i][j].x - *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;lower_bound = object_points[i][j].y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;upper_bound = object_points[i][k].y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// first check: is ball&#39;s y position between the segment?</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;y &gt;= lower_bound &amp;&amp; b-&gt;y &lt;= upper_bound){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_y = b-&gt;y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// drawVLine(fix2int15(*collision_point_x), fix2int15(*collision_point_y), 15, RED);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// this is vector from wall to ball center</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*dx = b-&gt;x - *collision_point_x;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;*dy = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;abs_dx = absfix15(*dx);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;abs_dy = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*distance = multfix15(alpha, MAXIMUM(abs_dx, abs_dy)) + multfix15(beta, &nbsp;MINIMUM(abs_dx, abs_dy));</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(*distance &lt; int2fix15(ball_r) + *buffer) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">bool</span><span class="c1">&nbsp;checkHorizontalCollision(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">i</span><span class="c1">, fix15 *</span><span class="c1 c14">dx</span><span class="c1">, fix15 *</span><span class="c1 c14">dy</span><span class="c1">, fix15 *</span><span class="c1 c14">distance</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_x</span><span class="c1">, fix15 *</span><span class="c1 c14">collision_point_y</span><span class="c1">, fix15 *</span><span class="c1 c14">buffer</span><span class="c1">, Ball* </span><span class="c1 c14">b</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 lower_bound;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 upper_bound;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dy;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;*buffer = absfix15(b-&gt;vy) + absfix15(b-&gt;vx);</span></p><p class="c0"><span class="c1">&nbsp; </span><span class="c7 c1">// we have a pair of lines to check; the first is 0-3 and other 1-2</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">for</span><span class="c1">&nbsp;(</span><span class="c1 c4">int</span><span class="c1">&nbsp;seg = </span><span class="c1 c6">0</span><span class="c1">; seg &lt; </span><span class="c1 c6">2</span><span class="c3 c1">; seg++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;j, k;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(seg == </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;j = </span><span class="c1 c6">0</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;k = </span><span class="c1 c6">3</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_y = object_points[i][j].y + *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;j = </span><span class="c1 c6">1</span><span class="c3 c1">; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;k = </span><span class="c1 c6">2</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_y = object_points[i][j].y - *buffer;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;lower_bound = object_points[i][j].x;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;upper_bound = object_points[i][k].x;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// first check: is ball&#39;s y position between the segment?</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;x &gt;= lower_bound &amp;&amp; b-&gt;x &lt;= upper_bound){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*collision_point_x = b-&gt;x;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// this is vector from wall to ball center</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*dy = b-&gt;y - *collision_point_y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;*dx = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;abs_dx = absfix15(*dx);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;abs_dy = absfix15(*dy);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// collision check</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;*distance = multfix15(alpha, MAXIMUM(abs_dx, abs_dy)) + multfix15(beta, &nbsp;MINIMUM(abs_dx, abs_dy));</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(*distance &lt; int2fix15(ball_r) + *buffer) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">return</span><span class="c1">&nbsp;</span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c3 c1">&nbsp;fix15 angular_velocity_left;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c3 c1">&nbsp;fix15 angular_velocity_right;</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 pivot_left_x = int2fix15(</span><span class="c1 c6">240</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 pivot_left_y = int2fix15(</span><span class="c1 c6">460</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 pivot_right_x = int2fix15(</span><span class="c1 c6">395</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 pivot_right_y = int2fix15(</span><span class="c1 c6">460</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 flipper_e = float2fix15(</span><span class="c1 c6">0.1</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;handleFlipperCollision(</span><span class="c1 c4">int</span><span class="c1">&nbsp;</span><span class="c1 c14">i</span><span class="c1">, fix15 </span><span class="c1 c14">dx</span><span class="c1">, fix15 </span><span class="c1 c14">dy</span><span class="c1">, fix15 </span><span class="c1 c14">distance</span><span class="c1">, fix15 </span><span class="c1 c14">collision_point_x</span><span class="c1">, fix15 </span><span class="c1 c14">collision_point_y</span><span class="c1">, fix15 </span><span class="c1 c14">buffer</span><span class="c1">, Ball* </span><span class="c1 c14">b</span><span class="c3 c1">){</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(distance == </span><span class="c1 c6">0</span><span class="c1">) </span><span class="c1 c4">return</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// normal pointing from flipper -&gt; ball</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 nx = divfix(dx, distance);</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 ny = divfix(dy, distance);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// choose pivot and angular velocity for this flipper</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 pivot_x, pivot_y;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 omega;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i == </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;pivot_x = pivot_left_x;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;pivot_y = pivot_left_y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;omega &nbsp; = angular_velocity_left;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;{</span><span class="c7 c1">&nbsp;// i == 1</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;pivot_x = pivot_right_x;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;pivot_y = pivot_right_y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;omega &nbsp; = angular_velocity_right;</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// radius vector from pivot to contact point</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 rx = collision_point_x - pivot_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 ry = collision_point_y - pivot_y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// surface velocity at contact point: v = omega &times; r</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// perp(r) = (-ry, rx)</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 surf_vx = -multfix15(ry, omega);</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 surf_vy = &nbsp;multfix15(rx, omega);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// relative velocity of ball wrt flipper surface</span></p><p class="c0"><span class="c1">&nbsp;fix15 rel_vx = b-&gt;vx - surf_vx;</span><span class="c7 c1">&nbsp;//negative if ball moving towards flipper</span></p><p class="c0"><span class="c1">&nbsp;fix15 rel_vy = b-&gt;vy - surf_vy;</span><span class="c7 c1">&nbsp;//could be neg or pos depending on ball and flipper v</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// normal component of relative velocity</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 v_rel_n = multfix15(rel_vx, nx) + multfix15(rel_vy, ny);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// reflect normal component with restitution</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// v&#39;_rel_n = -e * v_rel_n</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 minus_e = -flipper_e;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 v_rel_n_after = multfix15(minus_e, v_rel_n);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// delta in normal component</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 delta_n = v_rel_n_after - v_rel_n;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// apply change along normal in relative frame</span></p><p class="c0"><span class="c3 c1">&nbsp;rel_vx += multfix15(delta_n, nx);</span></p><p class="c0"><span class="c3 c1">&nbsp;rel_vy += multfix15(delta_n, ny);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// convert back to world velocity</span></p><p class="c0"><span class="c3 c1">&nbsp;b-&gt;vx = rel_vx + surf_vx;</span></p><p class="c0"><span class="c3 c1">&nbsp;b-&gt;vy = rel_vy + surf_vy;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vx &gt; max_velocity) b-&gt;vx = max_velocity;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vx &lt; -max_velocity) b-&gt;vx = -max_velocity;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vy &gt; max_velocity) b-&gt;vy = max_velocity;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vy &lt; -max_velocity) b-&gt;vy = -max_velocity;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// finally, push ball out so it sits exactly at radius ball_r from the contact</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;x = collision_point_x + multfix15(nx, buffer + int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">));</span></p><p class="c0"><span class="c1">&nbsp;b-&gt;y = collision_point_y + multfix15(ny, buffer + int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">));</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;data_chan;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;ctrl_chan;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;data_chan_1;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;ctrl_chan_1;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;star_blink_counter = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;star_blink_yellow_frames = </span><span class="c1 c6">14</span><span class="c1">;</span><span class="c7 c1">&nbsp; // how many frames to stay yellow</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;star_blink_white_frames &nbsp;= </span><span class="c1 c6">8</span><span class="c1">;</span><span class="c7 c1">&nbsp; // how many frames to stay white</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;ballMotion(Ball* </span><span class="c1 c14">b</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// update ball&#39;s position and velocity</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 dx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 dy;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 abs_dy;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 distance;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 nx;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 ny;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 intermediate;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 collision_point_x;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 collision_point_y;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;start_object = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;end_object = </span><span class="c1 c6">17</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">bool</span><span class="c1">&nbsp;collide = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp;fix15 buffer;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">//apply gravity</span></p><p class="c0"><span class="c3 c1">&nbsp;b-&gt;vy += gravity;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">//update position</span></p><p class="c0"><span class="c3 c1">&nbsp;b-&gt;x += b-&gt;vx;</span></p><p class="c0"><span class="c3 c1">&nbsp;b-&gt;y += b-&gt;vy;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">for</span><span class="c1">&nbsp;(</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;i = start_object; i &lt;= end_object; i++) {</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// peg collisions</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">7</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">13</span><span class="c3 c1">) { &nbsp; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;dx = b-&gt;x - object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;dy = b-&gt;y - object_points[i][</span><span class="c1 c6">0</span><span class="c3 c1">].y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;abs_dx = absfix15(dx);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;abs_dy = absfix15(dy);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// collision check</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(abs_dx &lt; b_p_collision_distance &amp;&amp; abs_dy &lt; b_p_collision_distance) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;distance = multfix15(alpha, MAXIMUM(abs_dx, abs_dy)) + multfix15(beta, MINIMUM(abs_dx, abs_dy));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;collide = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// flipper collisions</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i == </span><span class="c1 c6">0</span><span class="c1">&nbsp;|| i == </span><span class="c1 c6">1</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// check diagonal line</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;collide = checkDiagonalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">(collide){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;handleFlipperCollision(i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">continue</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// rhombus collisions</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i == </span><span class="c1 c6">2</span><span class="c1">&nbsp;|| i == </span><span class="c1 c6">3</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// check diagonal line</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;collide = checkDiagonalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(!collide){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// check Vertical lines</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;collide = checkVerticalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c13 c4">false</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">//</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;((i &gt; </span><span class="c1 c6">3</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">8</span><span class="c1">) || i &gt; </span><span class="c1 c6">12</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">17</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;collide = checkHorizontalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(!collide){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;collide = checkVerticalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c13 c4">false</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1 c3">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// this is for the launcher wall</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i == </span><span class="c1 c6">17</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;collide = checkVerticalCollision(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dx,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;dy,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;distance,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_x,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;collision_point_y,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;buffer,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c13 c4">true</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(collide) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// distance could be 0, so add a check</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(distance == </span><span class="c1 c6">0</span><span class="c1">) </span><span class="c1 c4">continue</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;nx = divfix(dx, distance);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;ny = divfix(dy, distance);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;intermediate = multfix15(nx, b-&gt;vx) + multfix15(ny, b-&gt;vy);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;intermediate = multfix15(int2fix15(-</span><span class="c1 c6">2</span><span class="c3 c1">), intermediate);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// check intermediate to confirm that the ball is moving towards the obstacle</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">(intermediate &gt; </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// teleport ball outside of object</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">7</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">13</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b-&gt;x = object_points[i][</span><span class="c1 c6">0</span><span class="c1">].x + (multfix15(nx, (b_p_collision_distance + int2fix15(</span><span class="c1 c6">1</span><span class="c3 c1">))));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b-&gt;y = object_points[i][</span><span class="c1 c6">0</span><span class="c1">].y + (multfix15(ny, (b_p_collision_distance + int2fix15(</span><span class="c1 c6">1</span><span class="c3 c1">))));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b-&gt;x = collision_point_x + multfix15(nx, buffer + int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b-&gt;y = collision_point_y + multfix15(ny, buffer + int2fix15(ball_r + </span><span class="c1 c6">1</span><span class="c3 c1">));</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;b-&gt;vx += multfix15(nx, intermediate);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;b-&gt;vy += multfix15(ny, intermediate);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;b-&gt;vx = multfix15(b-&gt;vx, bounciness);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;b-&gt;vy = multfix15(b-&gt;vy, bounciness);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vx &gt; max_velocity) b-&gt;vx = max_velocity;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vx &lt; -max_velocity) b-&gt;vx = -max_velocity;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vy &gt; max_velocity) b-&gt;vy = max_velocity;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(b-&gt;vy &lt; -max_velocity) b-&gt;vy = -max_velocity;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// blink the stars</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">3</span><span class="c1">&nbsp;&amp;&amp; i != </span><span class="c1 c6">17</span><span class="c3 c1">){</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;star_blink_counter = star_blink_yellow_frames + star_blink_white_frames;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dma_start_channel_mask(</span><span class="c1 c6">1u</span><span class="c3 c1">&nbsp;&lt;&lt; ctrl_chan);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 20 points for pegs</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">7</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">13</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;score += </span><span class="c1 c6">20</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 10 points for bottom row of rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">3</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">8</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;score += </span><span class="c1 c6">10</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// 30 points for top row of rectangles</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(i &gt; </span><span class="c1 c6">12</span><span class="c1">&nbsp;&amp;&amp; i &lt; </span><span class="c1 c6">17</span><span class="c3 c1">){</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;score +=</span><span class="c1 c6">30</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">break</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// OBJECT FOR LOOP ENDS HERE</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;relaunchCountdown() {</span></p><p class="c0"><span class="c1">&nbsp;setTextWrap(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextSize(</span><span class="c1 c6">3</span><span class="c3 c1">); &nbsp; &nbsp;</span></p><p class="c0"><span class="c1">&nbsp;setTextColor2(WHITE, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">char</span><span class="c1">&nbsp;buf[</span><span class="c1 c6">64</span><span class="c3 c1">];</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setTextSize(</span><span class="c1 c6">4</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setCursor(</span><span class="c1 c6">310</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;snprintf(buf, </span><span class="c1 c4">sizeof</span><span class="c1">&nbsp;buf, </span><span class="c1 c20">&quot;%d&quot;</span><span class="c1">, (</span><span class="c1 c6">3</span><span class="c1">-(relaunch_counter/</span><span class="c1 c6">4</span><span class="c3 c1">)));</span></p><p class="c0"><span class="c3 c1">&nbsp;writeString(buf);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(</span><span class="c1 c6">270</span><span class="c1">, </span><span class="c1 c6">380</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;snprintf(buf, </span><span class="c1 c4">sizeof</span><span class="c1">&nbsp;buf, </span><span class="c1 c20">&quot;FLEX!&quot;</span><span class="c3 c1">);</span></p><p class="c0"><span class="c3 c1">&nbsp;writeString(buf);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(relaunch_counter &gt; </span><span class="c1 c6">10</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// erase the flex</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">270</span><span class="c1">, </span><span class="c1 c6">380</span><span class="c1">, </span><span class="c1 c6">120</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c3 c1">, BLACK);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// erase the countdown</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;fillRect(</span><span class="c1 c6">310</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">20</span><span class="c1">, </span><span class="c1 c6">30</span><span class="c3 c1">, BLACK);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// draw Time Since Start, High Score, Lives, and Score</span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;drawInfo(){</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c1">&nbsp;x = </span><span class="c1 c6">2</span><span class="c1">, y = </span><span class="c1 c6">10</span><span class="c1">, w = </span><span class="c1 c6">73</span><span class="c1">, h = </span><span class="c1 c6">8</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Erase panel</span></p><p class="c0"><span class="c1">&nbsp;fillRect(x, y, w+</span><span class="c1 c6">10</span><span class="c1">, h, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setTextWrap(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextSize(</span><span class="c1 c6">1</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextColor2(WHITE, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;setCursor(x, y);</span></p><p class="c0"><span class="c1">&nbsp;writeStringBold(</span><span class="c1 c20">&quot;Lives:&quot;</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextColor2(RED, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// draw lives as hearts using drawChar directly</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">for</span><span class="c1">&nbsp;(</span><span class="c1 c4">int</span><span class="c1">&nbsp;i = </span><span class="c1 c6">0</span><span class="c3 c1">; i &lt; lives; i++) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">short</span><span class="c1">&nbsp;cx = x + </span><span class="c1 c6">7</span><span class="c1">&nbsp;* </span><span class="c1 c6">6</span><span class="c1">&nbsp; + i * </span><span class="c1 c6">8</span><span class="c1">;</span><span class="c7 c1">&nbsp; &nbsp;// 6 px glyph width + a bit of spacing</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">short</span><span class="c1">&nbsp;cy = y;</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// top of the 8 px high box</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;drawChar(cx, cy, </span><span class="c1 c6">0x03</span><span class="c1">, RED, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">1</span><span class="c3 c1">);</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">//Draw the score now</span></p><p class="c0"><span class="c1">&nbsp;setTextColor2(WHITE, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Score line</span></p><p class="c0"><span class="c1">&nbsp;fillRect(x, y+</span><span class="c1 c6">10</span><span class="c1">, w, h, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setCursor(x, y + </span><span class="c1 c6">10</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;writeStringBold(</span><span class="c1 c20">&quot;Score:&quot;</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(x + </span><span class="c1 c6">45</span><span class="c1">, y + </span><span class="c1 c6">10</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">char</span><span class="c1">&nbsp;buf[</span><span class="c1 c6">16</span><span class="c3 c1">];</span></p><p class="c0"><span class="c1">&nbsp;snprintf(buf, </span><span class="c1 c4">sizeof</span><span class="c1">&nbsp;buf, </span><span class="c1 c20">&quot;%d&quot;</span><span class="c3 c1">, score);</span></p><p class="c0"><span class="c3 c1">&nbsp;writeStringBold(buf);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// High score line (stacked)</span></p><p class="c0"><span class="c1">&nbsp;fillRect(x, y+</span><span class="c1 c6">30</span><span class="c1">, w-</span><span class="c1 c6">12</span><span class="c1">, h+</span><span class="c1 c6">6</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setCursor(x, y + </span><span class="c1 c6">30</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;writeStringBold(</span><span class="c1 c20">&quot;High&quot;</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(x, y+</span><span class="c1 c6">40</span><span class="c3 c1">); </span></p><p class="c0"><span class="c1">&nbsp;writeStringBold(</span><span class="c1 c20">&quot;Score&quot;</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setCursor(x+</span><span class="c1 c6">35</span><span class="c1">, y+</span><span class="c1 c6">35</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;snprintf(buf, </span><span class="c1 c4">sizeof</span><span class="c1">&nbsp;buf, </span><span class="c1 c20">&quot;:%d&quot;</span><span class="c3 c1">, high_score);</span></p><p class="c0"><span class="c3 c1">&nbsp;writeStringBold(buf);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;drawEndScreen() {</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Erase screen</span></p><p class="c0"><span class="c1">&nbsp;fillRect(</span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">640</span><span class="c1">, </span><span class="c1 c6">480</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setTextWrap(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextSize(</span><span class="c1 c6">6</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;setTextColor2(WHITE, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">char</span><span class="c1">&nbsp;buf[</span><span class="c1 c6">32</span><span class="c3 c1">];</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(</span><span class="c1 c6">140</span><span class="c1">, </span><span class="c1 c6">180</span><span class="c3 c1">); </span></p><p class="c0"><span class="c1">&nbsp;writeStringBold(</span><span class="c1 c20">&quot;GAME OVER&quot;</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setTextSize(</span><span class="c1 c6">4</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(</span><span class="c1 c6">160</span><span class="c1">, </span><span class="c1 c6">240</span><span class="c3 c1">); </span></p><p class="c0"><span class="c1">&nbsp;snprintf(buf, </span><span class="c1 c4">sizeof</span><span class="c1">&nbsp;buf, </span><span class="c1 c20">&quot;High Score: %d&quot;</span><span class="c3 c1">, high_score);</span></p><p class="c0"><span class="c3 c1">&nbsp;writeString(buf);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;setCursor(</span><span class="c1 c6">100</span><span class="c1">, </span><span class="c1 c6">280</span><span class="c3 c1">); </span></p><p class="c0"><span class="c1">&nbsp;writeString(</span><span class="c1 c20">&quot;Flex to Play Again&quot;</span><span class="c3 c1">);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">static</span><span class="c1">&nbsp;PT_THREAD (protothread_anim(</span><span class="c1 c4">struct</span><span class="c1">&nbsp;pt *</span><span class="c1 c14">pt</span><span class="c3 c1">))</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// Mark beginning of thread</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;PT_BEGIN(pt);</span></p><p class="c0"><span class="c3 c1">&nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// Spawn balls</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;spawnBall(&amp;ball);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c7 c1">// Variables for maintaining frame rate</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;begin_time;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;spare_time;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;ball_x;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;ball_y;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">bool</span><span class="c3 c1">&nbsp;endDrawn;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">while</span><span class="c1">(</span><span class="c1 c6">1</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// Measure time at start of thread</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;begin_time = time_us_32();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(state == DEFAULT) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(endDrawn) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fillRect(</span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">640</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endDrawn = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;ball_x = fix2int15(ball.x);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;ball_y = fix2int15(ball.y);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawBall(ball_x, ball_y, BLACK);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(!relaunch) ballMotion(&amp;ball);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;relaunchCountdown();</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">//check if hit walls or bottom</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;wallsAndEdges(&amp;ball);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;ball_x = fix2int15(ball.x);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;ball_y = fix2int15(ball.y);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawBackground();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawObstacles();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawInfo();</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawBall(ball_x, ball_y, WHITE);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;blink_frames++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(blink_frames % hold_frames == </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;color_index++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">(color_index &gt;= </span><span class="c1 c6">15</span><span class="c1">) color_index = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(star_blink_counter &gt; </span><span class="c1 c6">0</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(star_blink_counter &gt; star_blink_white_frames) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// first phase: yellow</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blinkStars(YELLOW);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// second phase: white</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blinkStars(WHITE);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;star_blink_counter--;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;blinkStars(BLACK);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;drawBall(ball_x, ball_y, WHITE);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(!endDrawn) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawEndScreen();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;endDrawn = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// delay in accordance with frame rate</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;spare_time = FRAME_RATE - (time_us_32() - begin_time) ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;PT_YIELD_usec(spare_time) ;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; </span><span class="c7 c1">// NEVER exit while</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;}</span><span class="c7 c1">&nbsp;// END WHILE(1)</span></p><p class="c0"><span class="c3 c1">&nbsp;PT_END(pt);</span></p><p class="c0"><span class="c1">}</span><span class="c7 c1">&nbsp;// animation thread</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + BEGIN SONAR SENSOR CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// PWM wrap value and clock divide value</span></p><p class="c0"><span class="c7 c1">// For a CPU rate of 250 MHz, this gives</span></p><p class="c0"><span class="c7 c1">// a PWM frequency of 1 kHz.</span></p><p class="c0"><span class="c7 c1">// so you count up to 25000 within this 1 cycle</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">CLKDIV</span><span class="c1 c4">&nbsp; </span><span class="c1 c13 c6">250.0</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">WRAPVAL</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">1000</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// GPIO we&#39;re using for PWM</span></p><p class="c0"><span class="c7 c1">// GPIO 2 is pin 4</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PWM_OUT</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">2</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// GPIO for pulse measurement</span></p><p class="c0"><span class="c7 c1">// GPIO 3 corresponds to pin 5</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PULSE_LEFT_GPIO</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">12</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PULSE_RIGHT_GPIO</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">13</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// Variable to hold PWM slice number</span></p><p class="c0"><span class="c1 c4">uint</span><span class="c3 c1">&nbsp;slice_num ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// PWM duty cycle</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;control ;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;old_control ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">uint64_t</span><span class="c1">&nbsp;pulse_start_left_us = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">uint64_t</span><span class="c1">&nbsp;pulse_width_left_us = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">bool</span><span class="c1">&nbsp;pulse_ready_left = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">uint64_t</span><span class="c1">&nbsp;pulse_start_right_us = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">uint64_t</span><span class="c1">&nbsp;pulse_width_right_us = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">volatile</span><span class="c1">&nbsp;</span><span class="c1 c4">bool</span><span class="c1">&nbsp;pulse_ready_right = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">void</span><span class="c1">&nbsp;pulse_irq(</span><span class="c1 c4">uint</span><span class="c1">&nbsp;</span><span class="c1 c14">gpio</span><span class="c1">, </span><span class="c1 c4">uint32_t</span><span class="c1">&nbsp;</span><span class="c1 c14">events</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(gpio == PULSE_LEFT_GPIO) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(events &amp; GPIO_IRQ_EDGE_RISE) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_start_left_us = time_us_64();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(events &amp; GPIO_IRQ_EDGE_FALL) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">uint64_t</span><span class="c3 c1">&nbsp;now = time_us_64();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_width_left_us = now - pulse_start_left_us;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_ready_left = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c1">&nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(gpio == PULSE_RIGHT_GPIO) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(events &amp; GPIO_IRQ_EDGE_RISE) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_start_right_us = time_us_64();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(events &amp; GPIO_IRQ_EDGE_FALL) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">uint64_t</span><span class="c3 c1">&nbsp;now = time_us_64();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_width_right_us = now - pulse_start_right_us;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_ready_right = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// max distance is distance to start engaging</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 engaged_distance = int2fix15(</span><span class="c1 c6">20</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 angular_velocity = float2fix15(</span><span class="c1 c6">5.0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 dt = float2fix15(</span><span class="c1 c6">0.1</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 max_rotation = float2fix15(</span><span class="c1 c6">0.877636</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;fix15 ratio = float2fix15(</span><span class="c1 c6">50</span><span class="c1">/</span><span class="c1 c6">0.877636</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">fix15 rotation_left = float2fix15(</span><span class="c1 c6">0.0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">fix15 rotation_right = float2fix15(</span><span class="c1 c6">0.0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">fix15 last_rotation_left = float2fix15(</span><span class="c1 c6">0.1</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">fix15 last_rotation_right = float2fix15(</span><span class="c1 c6">0.1</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;old_left_vertex_y = </span><span class="c1 c6">460</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;new_left_vertex_y = </span><span class="c1 c6">460</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;old_right_vertex_y = </span><span class="c1 c6">460</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1 c4">int</span><span class="c1">&nbsp;new_right_vertex_y = </span><span class="c1 c6">460</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">fix15 distance_left;</span></p><p class="c0"><span class="c3 c1">fix15 distance_right;</span></p><p class="c0"><span class="c3 c1">fix15 updated_rotation;</span></p><p class="c0"><span class="c3 c1">fix15 tip_left_y;</span></p><p class="c0"><span class="c3 c1">fix15 tip_right_y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// clamping the max values because sometimes the ball jumps too much</span></p><p class="c0"><span class="c7 c1">// fix15 max_distance = 50</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">static</span><span class="c1">&nbsp;PT_THREAD (protothread_sonar(</span><span class="c1 c4">struct</span><span class="c1">&nbsp;pt *</span><span class="c1 c14">pt</span><span class="c3 c1">))</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;PT_BEGIN(pt);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">while</span><span class="c1">&nbsp;(</span><span class="c1 c6">1</span><span class="c3 c1">) {</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;PT_YIELD_usec(</span><span class="c1 c6">100000</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;PT_WAIT_UNTIL(pt, pulse_ready_left || pulse_ready_right);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(state == DEFAULT) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">305</span><span class="c3 c1">, new_left_vertex_y, rhombus_colour);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">335</span><span class="c3 c1">, new_right_vertex_y, rhombus_colour);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(pulse_ready_left) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;distance_left = float2fix15(pulse_width_left_us / </span><span class="c1 c6">58</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(distance_left &lt; engaged_distance) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updated_rotation = rotation_left + multfix15(dt, angular_velocity);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rotation_left = (updated_rotation &lt; max_rotation) ? updated_rotation : max_rotation;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updated_rotation = rotation_left - multfix15(dt, angular_velocity);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rotation_left = (updated_rotation &gt; </span><span class="c1 c6">0.0f</span><span class="c1">) ? updated_rotation : </span><span class="c1 c6">0.0f</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(rotation_left != last_rotation_left) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// erase old flipper</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">305</span><span class="c3 c1">, old_left_vertex_y, BLACK);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tip_left_y = pivot_left_y - multfix15(rotation_left, ratio);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// update collision data</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;object_points[</span><span class="c1 c6">0</span><span class="c1">][</span><span class="c1 c6">1</span><span class="c3 c1">].y = tip_left_y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_left_vertex_y = fix2int15(tip_left_y);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// draw new</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">245</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">305</span><span class="c3 c1">, new_left_vertex_y, rhombus_colour);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// update stored vertex</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;old_left_vertex_y = new_left_vertex_y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;angular_velocity_left = divfix(rotation_left - last_rotation_left, dt);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;last_rotation_left = rotation_left;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_ready_left = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(pulse_ready_right) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;distance_right = float2fix15(pulse_width_right_us / </span><span class="c1 c6">58</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(distance_right &lt; engaged_distance) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updated_rotation = rotation_right + multfix15(dt, angular_velocity);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rotation_right = (updated_rotation &lt; max_rotation) ? updated_rotation : max_rotation;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;updated_rotation = rotation_right - multfix15(dt, angular_velocity);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;rotation_right = (updated_rotation &gt; </span><span class="c1 c6">0.0f</span><span class="c1">) ? updated_rotation : </span><span class="c1 c6">0.0f</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// sprintf(pt_serial_out_buffer, &quot;Updated Rotation: %.3f\n&quot;, fix2float15(updated_rotation));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// serial_write;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// sprintf(pt_serial_out_buffer, &quot;Rotation Right: %.3f\n&quot;, fix2float15(rotation_left));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// serial_write;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(rotation_right != last_rotation_right) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// erase old flipper</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">335</span><span class="c3 c1">, old_right_vertex_y, BLACK);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tip_right_y = pivot_right_y - multfix15(rotation_right, ratio);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// update collision data</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;object_points[</span><span class="c1 c6">1</span><span class="c1">][</span><span class="c1 c6">0</span><span class="c3 c1">].y = tip_right_y;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new_right_vertex_y = fix2int15(tip_right_y);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// draw new</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;drawTriangle(</span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">430</span><span class="c1">, </span><span class="c1 c6">395</span><span class="c1">, </span><span class="c1 c6">460</span><span class="c1">, </span><span class="c1 c6">335</span><span class="c3 c1">, new_right_vertex_y, rhombus_colour);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c1">// update stored vertex</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;old_right_vertex_y = new_right_vertex_y;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;angular_velocity_right = divfix(rotation_right - last_rotation_right, dt);</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;last_rotation_right = rotation_right;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pulse_ready_right = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;PT_END(pt);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + END OF SONAR SENSOR CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + START OF IR SENSOR CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// globals for IR sensor and ball launch</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">IR_GPIO</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">26</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">IR_HISTORY_RANGE</span><span class="c1 c4">&nbsp;</span><span class="c1 c6 c13">16</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">ADC_CONVERSION</span><span class="c1 c4">&nbsp;</span><span class="c1 c6">26.40644669</span><span class="c7 c1">&nbsp; // = 3.3 Volts / 4095 for fix15</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">IR_MIN</span><span class="c1 c4">&nbsp;</span><span class="c1">int2fix15</span><span class="c1 c4">(</span><span class="c1 c6">500</span><span class="c1 c13 c4">)</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">IR_MAX</span><span class="c1 c4">&nbsp;</span><span class="c1">int2fix15</span><span class="c1 c4">(</span><span class="c1 c6">1500</span><span class="c1 c13 c4">)</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">static</span><span class="c1">&nbsp;PT_THREAD (protothread_ir(</span><span class="c1 c4">struct</span><span class="c1">&nbsp;pt *</span><span class="c1 c14">pt</span><span class="c3 c1">))</span></p><p class="c0"><span class="c3 c1">{</span></p><p class="c0"><span class="c3 c1">&nbsp;PT_BEGIN(pt);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">int</span><span class="c3 c1">&nbsp;adc_input;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">static</span><span class="c3 c1">&nbsp;fix15 ir_input;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;fix15 max_ir_input = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">static</span><span class="c1">&nbsp;</span><span class="c1 c4">bool</span><span class="c1">&nbsp;start_input = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c1 c4">while</span><span class="c1">(</span><span class="c1 c6">1</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;adc_input = adc_read();</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;ir_input = int2fix15(adc_input);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(state == DEFAULT) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(relaunch == </span><span class="c1 c4">true</span><span class="c1">&nbsp;&amp;&amp; ir_input &gt; IR_MIN) start_input = </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(start_input) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;relaunch_counter += </span><span class="c1 c6">1</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(ir_input &gt; max_ir_input) max_ir_input = ir_input;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c1">&nbsp;(relaunch_counter &gt; </span><span class="c1 c6">11</span><span class="c3 c1">) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(max_ir_input &gt; IR_MAX) max_ir_input = IR_MAX;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(max_ir_input &gt; IR_MIN) {</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;initial_velocity = -divfix(multfix15(max_ir_input, max_velocity), IR_MAX);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relaunch = </span><span class="c1 c4">false</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ball.vy = initial_velocity;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;relaunch_counter = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start_input = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;max_ir_input = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c1">&nbsp;initial_velocity = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;} </span><span class="c1 c4">else</span><span class="c3 c1">&nbsp;{</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">if</span><span class="c3 c1">&nbsp;(ir_input &gt; IR_MIN) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;high_score = </span><span class="c1 c6">0</span><span class="c3 c1">;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;lives = </span><span class="c1 c6">3</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp; &nbsp;state = DEFAULT;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;relaunch = </span><span class="c1 c4">true</span><span class="c3 c1">;</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;PT_YIELD_usec(</span><span class="c1 c6">1750000</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; // = 750 ms for a total of 1s</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp;}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp;PT_YIELD_usec(</span><span class="c1 c6">250000</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; // = 250 ms</span></p><p class="c0"><span class="c3 c1">&nbsp;}</span></p><p class="c0"><span class="c3 c1">&nbsp;PT_END(pt);</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0"><span class="c7 c1">// + + + END OF IR SENSOR CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + START OF DMA CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// DMA parameters</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c1 c5">&quot;dac_ding.h&quot;</span></p><p class="c0"><span class="c1 c14">#include</span><span class="c1 c4">&nbsp;</span><span class="c5 c1">&quot;dac_background.h&quot;</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">uint16_t</span><span class="c1">&nbsp;* ding_address_pointer = &amp;DAC_ding_data[</span><span class="c1 c6">0</span><span class="c3 c1">];</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">uint32_t</span><span class="c1">&nbsp;ding_transfer_count = </span><span class="c1 c4">sizeof</span><span class="c1">(DAC_ding_data) / </span><span class="c1 c4">sizeof</span><span class="c1">(</span><span class="c1 c4">uint16_t</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">uint16_t</span><span class="c1">&nbsp;* bg_address_pointer = &amp;DAC_background_data[</span><span class="c1 c6">0</span><span class="c3 c1">];</span></p><p class="c0"><span class="c1 c4">const</span><span class="c1">&nbsp;</span><span class="c1 c4">uint32_t</span><span class="c1">&nbsp;bg_transfer_count = </span><span class="c1 c4">sizeof</span><span class="c1">(DAC_background_data) / </span><span class="c1 c4">sizeof</span><span class="c1">(</span><span class="c1 c4">uint16_t</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">//SPI configurations</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_MISO</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">4</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_CS</span><span class="c1 c4">&nbsp; &nbsp;</span><span class="c1 c13 c6">5</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_SCK</span><span class="c1 c4">&nbsp; </span><span class="c1 c13 c6">6</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_MOSI</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">7</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">SPI_PORT</span><span class="c1 c13 c4">&nbsp;spi0</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_MISO_1</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">8</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_CS_1</span><span class="c1 c4">&nbsp; &nbsp;</span><span class="c1 c13 c6">9</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_SCK_1</span><span class="c1 c4">&nbsp; </span><span class="c1 c13 c6">10</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">PIN_MOSI_1</span><span class="c1 c4">&nbsp;</span><span class="c1 c13 c6">11</span></p><p class="c0"><span class="c1 c14">#define</span><span class="c1 c4">&nbsp;</span><span class="c1 c21">SPI_PORT_1</span><span class="c1 c13 c4">&nbsp;spi1</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// + + + END OF DMA CODE</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">// ========================================</span></p><p class="c0"><span class="c7 c1">// === core 1 main -- started in main below</span></p><p class="c0"><span class="c7 c1">// ========================================</span></p><p class="c0"><span class="c1 c4">void</span><span class="c3 c1">&nbsp;core1_main(){</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Add threads</span></p><p class="c0"><span class="c3 c1">&nbsp;pt_add_thread(protothread_sonar);</span></p><p class="c0"><span class="c3 c1">&nbsp;pt_add_thread(protothread_ir);</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Start the scheduler</span></p><p class="c0"><span class="c3 c1">&nbsp;pt_schedule_start ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1 c4">int</span><span class="c3 c1">&nbsp;main() {</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// overclock</span></p><p class="c0"><span class="c1">&nbsp;set_sys_clock_khz(</span><span class="c1 c6">250000</span><span class="c1">, </span><span class="c1 c4">true</span><span class="c3 c1">) ;</span></p><p class="c0"><span class="c1">&nbsp; </span><span class="c7 c1">// Initialize stdio</span></p><p class="c0"><span class="c3 c1">&nbsp;stdio_init_all();</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">&nbsp;////////////////////////////////////////////////////////////////////////</span></p><p class="c0"><span class="c7 c1">&nbsp;///////////////////////// PWM CONFIGURATION ////////////////////////////</span></p><p class="c0"><span class="c7 c1">&nbsp;////////////////////////////////////////////////////////////////////////</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; </span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Tell GPIO PWM_OUT that it is allocated to the PWM</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PWM_OUT, GPIO_FUNC_PWM);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Find out which PWM slice is connected to GPIO PWM_OUT (it&#39;s slice 2)</span></p><p class="c0"><span class="c3 c1">&nbsp;slice_num = pwm_gpio_to_slice_num(PWM_OUT);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Mask our slice&#39;s IRQ output into the PWM block&#39;s single interrupt line,</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// and register our interrupt handler</span></p><p class="c0"><span class="c3 c1">&nbsp;pwm_clear_irq(slice_num);</span></p><p class="c0"><span class="c1">&nbsp;pwm_set_chan_level(slice_num, PWM_CHAN_A, </span><span class="c1 c6">10</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// This section configures the period of the PWM signals</span></p><p class="c0"><span class="c3 c1">&nbsp;pwm_set_wrap(slice_num, WRAPVAL) ;</span></p><p class="c0"><span class="c3 c1">&nbsp;pwm_set_clkdiv(slice_num, CLKDIV) ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Start the channel</span></p><p class="c0"><span class="c1">&nbsp;pwm_set_mask_enabled((</span><span class="c1 c6">1u</span><span class="c3 c1">&nbsp;&lt;&lt; slice_num));</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c7 c1">&nbsp;////////////////////////////////////////////////////////////////////////</span></p><p class="c0"><span class="c7 c1">&nbsp;///////////////////////// PULSE CONFIGURATION ////////////////////////////</span></p><p class="c0"><span class="c7 c1">&nbsp;////////////////////////////////////////////////////////////////////////</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Init pulse GPIOs</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_init(PULSE_LEFT_GPIO);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_dir(PULSE_LEFT_GPIO, GPIO_IN);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_pull_down(PULSE_LEFT_GPIO);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_init(PULSE_RIGHT_GPIO);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_dir(PULSE_RIGHT_GPIO, GPIO_IN);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_pull_down(PULSE_RIGHT_GPIO);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// void gpio_set_irq_enabled_with_callback (uint gpio, uint32_t event_mask, bool enabled, gpio_irq_callback_t callback)</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_irq_enabled_with_callback(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;PULSE_LEFT_GPIO,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">true</span><span class="c3 c1">,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;&amp;pulse_irq</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_irq_enabled(</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;PULSE_RIGHT_GPIO,</span></p><p class="c0"><span class="c3 c1">&nbsp; &nbsp; &nbsp;GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c13 c4">true</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// ++++ DMA CONFIGURATIONS ++++</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Initialize SPI channel (channel, baud rate set to 20MHz)</span></p><p class="c0"><span class="c1">&nbsp;spi_init(SPI_PORT, </span><span class="c1 c6">4000000</span><span class="c3 c1">) ;</span></p><p class="c0"><span class="c1">&nbsp;spi_init(SPI_PORT_1, </span><span class="c1 c6">4000000</span><span class="c3 c1">) ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Format SPI channel (channel, data bits per transfer, polarity, phase, order)</span></p><p class="c0"><span class="c1">&nbsp;spi_set_format(SPI_PORT, </span><span class="c1 c6">16</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0"><span class="c1">&nbsp;spi_set_format(SPI_PORT_1, </span><span class="c1 c6">16</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Map SPI signals to GPIO ports, acts like framed SPI with this CS mapping</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_CS, GPIO_FUNC_SPI) ;</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_MISO_1, GPIO_FUNC_SPI);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_CS_1, GPIO_FUNC_SPI) ;</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_SCK_1, GPIO_FUNC_SPI);</span></p><p class="c0"><span class="c3 c1">&nbsp;gpio_set_function(PIN_MOSI_1, GPIO_FUNC_SPI);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Select DMA channels</span></p><p class="c0"><span class="c1">&nbsp;data_chan = dma_claim_unused_channel(</span><span class="c1 c4">true</span><span class="c3 c1">);;</span></p><p class="c0"><span class="c1">&nbsp;ctrl_chan = dma_claim_unused_channel(</span><span class="c1 c4">true</span><span class="c3 c1">);;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;data_chan_1 = dma_claim_unused_channel(</span><span class="c1 c4">true</span><span class="c3 c1">);;</span></p><p class="c0"><span class="c1">&nbsp;ctrl_chan_1 = dma_claim_unused_channel(</span><span class="c1 c4">true</span><span class="c3 c1">);;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Setup the control channel</span></p><p class="c0"><span class="c1">&nbsp;dma_channel_config c = dma_channel_get_default_config(ctrl_chan);</span><span class="c7 c1">&nbsp; &nbsp;// default configs</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_transfer_data_size(&amp;c, DMA_SIZE_32);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 32-bit txfers</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_read_increment(&amp;c, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// no read incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_write_increment(&amp;c, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // no write incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_chain_to(&amp;c, data_chan);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// chain to data channel</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;dma_channel_config c_1 = dma_channel_get_default_config(ctrl_chan_1);</span><span class="c7 c1">&nbsp; &nbsp;// default configs</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_transfer_data_size(&amp;c_1, DMA_SIZE_32);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 32-bit txfers</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_read_increment(&amp;c_1, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// no read incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_write_increment(&amp;c_1, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // no write incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_chain_to(&amp;c_1, data_chan_1);</span><span class="c1 c7">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// chain to data channel</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;dma_channel_configure(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;ctrl_chan,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Channel to be configured</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;&amp;c,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// The configuration we just created</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;&amp;dma_hw-&gt;ch[data_chan].read_addr,</span><span class="c7 c1">&nbsp; &nbsp;// Write address (data channel read address)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;&amp;ding_address_pointer,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Read address (POINTER TO AN ADDRESS), in this case the sine table</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c6">1</span><span class="c1">,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Number of transfers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">false</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Don&#39;t start immediately</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;dma_channel_configure(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;ctrl_chan_1,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Channel to be configured</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;&amp;c_1,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// The configuration we just created</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;&amp;dma_hw-&gt;ch[data_chan_1].read_addr,</span><span class="c7 c1">&nbsp; &nbsp;// Write address (data channel read address)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;&amp;bg_address_pointer,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Read address (POINTER TO AN ADDRESS), in this case the sine table</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c6">1</span><span class="c1">,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Number of transfers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">false</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Don&#39;t start immediately</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Setup the data channel</span></p><p class="c0"><span class="c1">&nbsp;dma_channel_config c2 = dma_channel_get_default_config(data_chan);</span><span class="c7 c1">&nbsp; // Default configs</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_transfer_data_size(&amp;c2, DMA_SIZE_16);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 16-bit txfers</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_read_increment(&amp;c2, </span><span class="c1 c4">true</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// yes read incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_write_increment(&amp;c2, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// no write incrementing</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// (X/Y)*sys_clk, where X is the first 16 bytes and Y is the second</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// sys_clk is 150 MHz unless changed in code. Configured to ~44 kHz</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// 0x13 = 19, 0xffff = 65535</span></p><p class="c0"><span class="c1">&nbsp;dma_timer_set_fraction(</span><span class="c1 c6">0</span><span class="c1">, </span><span class="c1 c6">0x000C</span><span class="c1">, </span><span class="c1 c6">0xffff</span><span class="c3 c1">) ;</span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// 0x3b means timer0 (see SDK manual)</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_dreq(&amp;c2, </span><span class="c1 c6">0x3b</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// DREQ paced by timer 0</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;dma_channel_config c2_1 = dma_channel_get_default_config(data_chan_1);</span><span class="c7 c1">&nbsp; // Default configs</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_transfer_data_size(&amp;c2_1, DMA_SIZE_16);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 16-bit txfers</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_read_increment(&amp;c2_1, </span><span class="c1 c4">true</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// yes read incrementing</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_write_increment(&amp;c2_1, </span><span class="c1 c4">false</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// no write incrementing</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// 0x3b means timer0 (see SDK manual)</span></p><p class="c0"><span class="c1">&nbsp;channel_config_set_dreq(&amp;c2_1, </span><span class="c1 c6">0x3b</span><span class="c1">);</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// DREQ paced by timer 0</span></p><p class="c0"><span class="c3 c1">&nbsp;channel_config_set_chain_to(&amp;c2_1, ctrl_chan_1);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;dma_channel_configure(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;data_chan,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Channel to be configured</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;&amp;c2,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The configuration we just created</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;&amp;spi_get_hw(SPI_PORT)-&gt;dr,</span><span class="c7 c1">&nbsp; // write address (SPI data register)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;DAC_ding_data,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// The initial read address</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;ding_transfer_count,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Number of transfers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp;</span><span class="c1 c4">false</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Don&#39;t start immediately.</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c3 c1">&nbsp;dma_channel_configure(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;data_chan_1,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Channel to be configured</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;&amp;c2_1,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The configuration we just created</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;&amp;spi_get_hw(SPI_PORT_1)-&gt;dr,</span><span class="c7 c1">&nbsp; // write address (SPI data register)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;DAC_background_data,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// The initial read address</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;bg_transfer_count,</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Number of transfers</span></p><p class="c0"><span class="c1">&nbsp; &nbsp;</span><span class="c1 c4">false</span><span class="c7 c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Don&#39;t start immediately.</span></p><p class="c0"><span class="c3 c1">&nbsp;);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;dma_start_channel_mask(</span><span class="c1 c6">1u</span><span class="c3 c1">&nbsp;&lt;&lt; ctrl_chan_1) ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// ++++ END OF DMA CONFIG ++++</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Initialize the VGA screen</span></p><p class="c0"><span class="c3 c1">&nbsp;initVGA() ;</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// initialize ADC</span></p><p class="c0"><span class="c3 c1">&nbsp;adc_init();</span></p><p class="c0"><span class="c3 c1">&nbsp;adc_gpio_init(IR_GPIO);</span></p><p class="c0"><span class="c1">&nbsp;adc_select_input(</span><span class="c1 c6">0</span><span class="c3 c1">);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// Intialize assign gloal variable values</span></p><p class="c0"><span class="c3 c1">&nbsp;b_p_collision_distance = int2fix15((ball_r + peg_r));</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// start core 1</span></p><p class="c0"><span class="c3 c1">&nbsp;multicore_reset_core1();</span></p><p class="c0"><span class="c3 c1">&nbsp;multicore_launch_core1(&amp;core1_main);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// add threads</span></p><p class="c0"><span class="c3 c1">&nbsp;pt_add_thread(protothread_anim);</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0"><span class="c1">&nbsp;</span><span class="c7 c1">// start scheduler</span></p><p class="c0"><span class="c3 c1">&nbsp;pt_schedule_start;</span></p><p class="c0"><span class="c3 c1">}</span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c0 c8"><span class="c3 c1"></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c9 c8"><span class="c2"></span></p><p class="c10 c8"><span class="c3 c22"></span></p><p class="c10 c8"><span class="c3 c22"></span></p><p class="c10 c8"><span class="c36 c37"></span></p><p class="c10 c8"><span class="c3 c22"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image36.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image28.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image48.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image26.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image38.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image45.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image43.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image44.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image32.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 832.00px;"><img alt="" src="images/image46.jpg" style="width: 624.00px; height: 832.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 468.00px;"><img alt="" src="images/image31.jpg" style="width: 624.00px; height: 468.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10 c8"><span class="c2"></span></p><p class="c10"><span>&#8203;&#8203;</span></p><div><p class="c10 c8"><span class="c2"></span></p></div><hr class="c32"><div><p class="c34"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c24">&nbsp;Subramaniam, R. (n.d.). (rep.). </span><span class="c24 c11">An IR Muscle Contraction Sensor</span><span class="c3 c24 c30">. Retrieved December 15, 2025, from https://people.ece.cornell.edu/land/courses/eceprojectsland/STUDENTPROJ/2013to2014/ras578/Writeup/An%20IR%20Muscle%20Contraction%20Sensor.html. </span></p></div></body></html>