<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>balloon-website</title>
    <script type="module" crossorigin>(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const s of o.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&r(s)}).observe(document,{childList:!0,subtree:!0});function t(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(i){if(i.ep)return;i.ep=!0;const o=t(i);fetch(i.href,o)}})();function gr(e){const n=Object.create(null);for(const t of e.split(","))n[t]=1;return t=>t in n}const J={},Ln=[],Ve=()=>{},Ci=()=>!1,Rt=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),mr=e=>e.startsWith("onUpdate:"),ue=Object.assign,wr=(e,n)=>{const t=e.indexOf(n);t>-1&&e.splice(t,1)},Qo=Object.prototype.hasOwnProperty,X=(e,n)=>Qo.call(e,n),B=Array.isArray,Dn=e=>At(e)==="[object Map]",Li=e=>At(e)==="[object Set]",H=e=>typeof e=="function",oe=e=>typeof e=="string",hn=e=>typeof e=="symbol",ee=e=>e!==null&&typeof e=="object",Di=e=>(ee(e)||H(e))&&H(e.then)&&H(e.catch),Ni=Object.prototype.toString,At=e=>Ni.call(e),Jo=e=>At(e).slice(8,-1),Pi=e=>At(e)==="[object Object]",yr=e=>oe(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Xn=gr(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),It=e=>{const n=Object.create(null);return(t=>n[t]||(n[t]=e(t)))},es=/-\w/g,Ie=It(e=>e.replace(es,n=>n.slice(1).toUpperCase())),ns=/\B([A-Z])/g,En=It(e=>e.replace(ns,"-$1").toLowerCase()),Ot=It(e=>e.charAt(0).toUpperCase()+e.slice(1)),Ft=It(e=>e?`on${Ot(e)}`:""),un=(e,n)=>!Object.is(e,n),Wt=(e,...n)=>{for(let t=0;t<e.length;t++)e[t](...n)},ki=(e,n,t,r=!1)=>{Object.defineProperty(e,n,{configurable:!0,enumerable:!1,writable:r,value:t})},ts=e=>{const n=parseFloat(e);return isNaN(n)?e:n};let Fr;const Ct=()=>Fr||(Fr=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Lt(e){if(B(e)){const n={};for(let t=0;t<e.length;t++){const r=e[t],i=oe(r)?ss(r):Lt(r);if(i)for(const o in i)n[o]=i[o]}return n}else if(oe(e)||ee(e))return e}const rs=/;(?![^(]*\))/g,is=/:([^]+)/,os=/\/\*[^]*?\*\//g;function ss(e){const n={};return e.replace(os,"").split(rs).forEach(t=>{if(t){const r=t.split(is);r.length>1&&(n[r[0].trim()]=r[1].trim())}}),n}function at(e){let n="";if(oe(e))n=e;else if(B(e))for(let t=0;t<e.length;t++){const r=at(e[t]);r&&(n+=r+" ")}else if(ee(e))for(const t in e)e[t]&&(n+=t+" ");return n.trim()}const as="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",ls=gr(as);function Gi(e){return!!e||e===""}const Mi=e=>!!(e&&e.__v_isRef===!0),Oe=e=>oe(e)?e:e==null?"":B(e)||ee(e)&&(e.toString===Ni||!H(e.toString))?Mi(e)?Oe(e.value):JSON.stringify(e,Bi,2):String(e),Bi=(e,n)=>Mi(n)?Bi(e,n.value):Dn(n)?{[`Map(${n.size})`]:[...n.entries()].reduce((t,[r,i],o)=>(t[Ut(r,o)+" =>"]=i,t),{})}:Li(n)?{[`Set(${n.size})`]:[...n.values()].map(t=>Ut(t))}:hn(n)?Ut(n):ee(n)&&!B(n)&&!Pi(n)?String(n):n,Ut=(e,n="")=>{var t;return hn(e)?`Symbol(${(t=e.description)!=null?t:n})`:e};let be;class cs{constructor(n=!1){this.detached=n,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=be,!n&&be&&(this.index=(be.scopes||(be.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let n,t;if(this.scopes)for(n=0,t=this.scopes.length;n<t;n++)this.scopes[n].pause();for(n=0,t=this.effects.length;n<t;n++)this.effects[n].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let n,t;if(this.scopes)for(n=0,t=this.scopes.length;n<t;n++)this.scopes[n].resume();for(n=0,t=this.effects.length;n<t;n++)this.effects[n].resume()}}run(n){if(this._active){const t=be;try{return be=this,n()}finally{be=t}}}on(){++this._on===1&&(this.prevScope=be,be=this)}off(){this._on>0&&--this._on===0&&(be=this.prevScope,this.prevScope=void 0)}stop(n){if(this._active){this._active=!1;let t,r;for(t=0,r=this.effects.length;t<r;t++)this.effects[t].stop();for(this.effects.length=0,t=0,r=this.cleanups.length;t<r;t++)this.cleanups[t]();if(this.cleanups.length=0,this.scopes){for(t=0,r=this.scopes.length;t<r;t++)this.scopes[t].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!n){const i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0}}}function fs(){return be}let Q;const jt=new WeakSet;class Hi{constructor(n){this.fn=n,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,be&&be.active&&be.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,jt.has(this)&&(jt.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Wi(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Wr(this),Ui(this);const n=Q,t=Le;Q=this,Le=!0;try{return this.fn()}finally{ji(this),Q=n,Le=t,this.flags&=-3}}stop(){if(this.flags&1){for(let n=this.deps;n;n=n.nextDep)vr(n);this.deps=this.depsTail=void 0,Wr(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?jt.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){nr(this)&&this.run()}get dirty(){return nr(this)}}let Fi=0,Yn,Kn;function Wi(e,n=!1){if(e.flags|=8,n){e.next=Kn,Kn=e;return}e.next=Yn,Yn=e}function br(){Fi++}function xr(){if(--Fi>0)return;if(Kn){let n=Kn;for(Kn=void 0;n;){const t=n.next;n.next=void 0,n.flags&=-9,n=t}}let e;for(;Yn;){let n=Yn;for(Yn=void 0;n;){const t=n.next;if(n.next=void 0,n.flags&=-9,n.flags&1)try{n.trigger()}catch(r){e||(e=r)}n=t}}if(e)throw e}function Ui(e){for(let n=e.deps;n;n=n.nextDep)n.version=-1,n.prevActiveLink=n.dep.activeLink,n.dep.activeLink=n}function ji(e){let n,t=e.depsTail,r=t;for(;r;){const i=r.prevDep;r.version===-1?(r===t&&(t=i),vr(r),ds(r)):n=r,r.dep.activeLink=r.prevActiveLink,r.prevActiveLink=void 0,r=i}e.deps=n,e.depsTail=t}function nr(e){for(let n=e.deps;n;n=n.nextDep)if(n.dep.version!==n.version||n.dep.computed&&(Vi(n.dep.computed)||n.dep.version!==n.version))return!0;return!!e._dirty}function Vi(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===et)||(e.globalVersion=et,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!nr(e))))return;e.flags|=2;const n=e.dep,t=Q,r=Le;Q=e,Le=!0;try{Ui(e);const i=e.fn(e._value);(n.version===0||un(i,e._value))&&(e.flags|=128,e._value=i,n.version++)}catch(i){throw n.version++,i}finally{Q=t,Le=r,ji(e),e.flags&=-3}}function vr(e,n=!1){const{dep:t,prevSub:r,nextSub:i}=e;if(r&&(r.nextSub=i,e.prevSub=void 0),i&&(i.prevSub=r,e.nextSub=void 0),t.subs===e&&(t.subs=r,!r&&t.computed)){t.computed.flags&=-5;for(let o=t.computed.deps;o;o=o.nextDep)vr(o,!0)}!n&&!--t.sc&&t.map&&t.map.delete(t.key)}function ds(e){const{prevDep:n,nextDep:t}=e;n&&(n.nextDep=t,e.prevDep=void 0),t&&(t.prevDep=n,e.nextDep=void 0)}let Le=!0;const zi=[];function Qe(){zi.push(Le),Le=!1}function Je(){const e=zi.pop();Le=e===void 0?!0:e}function Wr(e){const{cleanup:n}=e;if(e.cleanup=void 0,n){const t=Q;Q=void 0;try{n()}finally{Q=t}}}let et=0;class us{constructor(n,t){this.sub=n,this.dep=t,this.version=t.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class Er{constructor(n){this.computed=n,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(n){if(!Q||!Le||Q===this.computed)return;let t=this.activeLink;if(t===void 0||t.sub!==Q)t=this.activeLink=new us(Q,this),Q.deps?(t.prevDep=Q.depsTail,Q.depsTail.nextDep=t,Q.depsTail=t):Q.deps=Q.depsTail=t,Xi(t);else if(t.version===-1&&(t.version=this.version,t.nextDep)){const r=t.nextDep;r.prevDep=t.prevDep,t.prevDep&&(t.prevDep.nextDep=r),t.prevDep=Q.depsTail,t.nextDep=void 0,Q.depsTail.nextDep=t,Q.depsTail=t,Q.deps===t&&(Q.deps=r)}return t}trigger(n){this.version++,et++,this.notify(n)}notify(n){br();try{for(let t=this.subs;t;t=t.prevSub)t.sub.notify()&&t.sub.dep.notify()}finally{xr()}}}function Xi(e){if(e.dep.sc++,e.sub.flags&4){const n=e.dep.computed;if(n&&!e.dep.subs){n.flags|=20;for(let r=n.deps;r;r=r.nextDep)Xi(r)}const t=e.dep.subs;t!==e&&(e.prevSub=t,t&&(t.nextSub=e)),e.dep.subs=e}}const tr=new WeakMap,xn=Symbol(""),rr=Symbol(""),nt=Symbol("");function ce(e,n,t){if(Le&&Q){let r=tr.get(e);r||tr.set(e,r=new Map);let i=r.get(t);i||(r.set(t,i=new Er),i.map=r,i.key=t),i.track()}}function qe(e,n,t,r,i,o){const s=tr.get(e);if(!s){et++;return}const a=l=>{l&&l.trigger()};if(br(),n==="clear")s.forEach(a);else{const l=B(e),u=l&&yr(t);if(l&&t==="length"){const f=Number(r);s.forEach((_,p)=>{(p==="length"||p===nt||!hn(p)&&p>=f)&&a(_)})}else switch((t!==void 0||s.has(void 0))&&a(s.get(t)),u&&a(s.get(nt)),n){case"add":l?u&&a(s.get("length")):(a(s.get(xn)),Dn(e)&&a(s.get(rr)));break;case"delete":l||(a(s.get(xn)),Dn(e)&&a(s.get(rr)));break;case"set":Dn(e)&&a(s.get(xn));break}}xr()}function An(e){const n=z(e);return n===e?n:(ce(n,"iterate",nt),Ae(e)?n:n.map(De))}function Dt(e){return ce(e=z(e),"iterate",nt),e}function an(e,n){return en(e)?vn(e)?Gn(De(n)):Gn(n):De(n)}const _s={__proto__:null,[Symbol.iterator](){return Vt(this,Symbol.iterator,e=>an(this,e))},concat(...e){return An(this).concat(...e.map(n=>B(n)?An(n):n))},entries(){return Vt(this,"entries",e=>(e[1]=an(this,e[1]),e))},every(e,n){return Ye(this,"every",e,n,void 0,arguments)},filter(e,n){return Ye(this,"filter",e,n,t=>t.map(r=>an(this,r)),arguments)},find(e,n){return Ye(this,"find",e,n,t=>an(this,t),arguments)},findIndex(e,n){return Ye(this,"findIndex",e,n,void 0,arguments)},findLast(e,n){return Ye(this,"findLast",e,n,t=>an(this,t),arguments)},findLastIndex(e,n){return Ye(this,"findLastIndex",e,n,void 0,arguments)},forEach(e,n){return Ye(this,"forEach",e,n,void 0,arguments)},includes(...e){return zt(this,"includes",e)},indexOf(...e){return zt(this,"indexOf",e)},join(e){return An(this).join(e)},lastIndexOf(...e){return zt(this,"lastIndexOf",e)},map(e,n){return Ye(this,"map",e,n,void 0,arguments)},pop(){return Un(this,"pop")},push(...e){return Un(this,"push",e)},reduce(e,...n){return Ur(this,"reduce",e,n)},reduceRight(e,...n){return Ur(this,"reduceRight",e,n)},shift(){return Un(this,"shift")},some(e,n){return Ye(this,"some",e,n,void 0,arguments)},splice(...e){return Un(this,"splice",e)},toReversed(){return An(this).toReversed()},toSorted(e){return An(this).toSorted(e)},toSpliced(...e){return An(this).toSpliced(...e)},unshift(...e){return Un(this,"unshift",e)},values(){return Vt(this,"values",e=>an(this,e))}};function Vt(e,n,t){const r=Dt(e),i=r[n]();return r!==e&&!Ae(e)&&(i._next=i.next,i.next=()=>{const o=i._next();return o.done||(o.value=t(o.value)),o}),i}const hs=Array.prototype;function Ye(e,n,t,r,i,o){const s=Dt(e),a=s!==e&&!Ae(e),l=s[n];if(l!==hs[n]){const _=l.apply(e,o);return a?De(_):_}let u=t;s!==e&&(a?u=function(_,p){return t.call(this,an(e,_),p,e)}:t.length>2&&(u=function(_,p){return t.call(this,_,p,e)}));const f=l.call(s,u,r);return a&&i?i(f):f}function Ur(e,n,t,r){const i=Dt(e);let o=t;return i!==e&&(Ae(e)?t.length>3&&(o=function(s,a,l){return t.call(this,s,a,l,e)}):o=function(s,a,l){return t.call(this,s,an(e,a),l,e)}),i[n](o,...r)}function zt(e,n,t){const r=z(e);ce(r,"iterate",nt);const i=r[n](...t);return(i===-1||i===!1)&&Rr(t[0])?(t[0]=z(t[0]),r[n](...t)):i}function Un(e,n,t=[]){Qe(),br();const r=z(e)[n].apply(e,t);return xr(),Je(),r}const ps=gr("__proto__,__v_isRef,__isVue"),Yi=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(hn));function gs(e){hn(e)||(e=String(e));const n=z(this);return ce(n,"has",e),n.hasOwnProperty(e)}class Ki{constructor(n=!1,t=!1){this._isReadonly=n,this._isShallow=t}get(n,t,r){if(t==="__v_skip")return n.__v_skip;const i=this._isReadonly,o=this._isShallow;if(t==="__v_isReactive")return!i;if(t==="__v_isReadonly")return i;if(t==="__v_isShallow")return o;if(t==="__v_raw")return r===(i?o?Rs:Qi:o?$i:qi).get(n)||Object.getPrototypeOf(n)===Object.getPrototypeOf(r)?n:void 0;const s=B(n);if(!i){let l;if(s&&(l=_s[t]))return l;if(t==="hasOwnProperty")return gs}const a=Reflect.get(n,t,de(n)?n:r);if((hn(t)?Yi.has(t):ps(t))||(i||ce(n,"get",t),o))return a;if(de(a)){const l=s&&yr(t)?a:a.value;return i&&ee(l)?or(l):l}return ee(a)?i?or(a):Nt(a):a}}class Zi extends Ki{constructor(n=!1){super(!1,n)}set(n,t,r,i){let o=n[t];const s=B(n)&&yr(t);if(!this._isShallow){const u=en(o);if(!Ae(r)&&!en(r)&&(o=z(o),r=z(r)),!s&&de(o)&&!de(r))return u||(o.value=r),!0}const a=s?Number(t)<n.length:X(n,t),l=Reflect.set(n,t,r,de(n)?n:i);return n===z(i)&&(a?un(r,o)&&qe(n,"set",t,r):qe(n,"add",t,r)),l}deleteProperty(n,t){const r=X(n,t);n[t];const i=Reflect.deleteProperty(n,t);return i&&r&&qe(n,"delete",t,void 0),i}has(n,t){const r=Reflect.has(n,t);return(!hn(t)||!Yi.has(t))&&ce(n,"has",t),r}ownKeys(n){return ce(n,"iterate",B(n)?"length":xn),Reflect.ownKeys(n)}}class ms extends Ki{constructor(n=!1){super(!0,n)}set(n,t){return!0}deleteProperty(n,t){return!0}}const ws=new Zi,ys=new ms,bs=new Zi(!0);const ir=e=>e,ft=e=>Reflect.getPrototypeOf(e);function xs(e,n,t){return function(...r){const i=this.__v_raw,o=z(i),s=Dn(o),a=e==="entries"||e===Symbol.iterator&&s,l=e==="keys"&&s,u=i[e](...r),f=t?ir:n?Gn:De;return!n&&ce(o,"iterate",l?rr:xn),{next(){const{value:_,done:p}=u.next();return p?{value:_,done:p}:{value:a?[f(_[0]),f(_[1])]:f(_),done:p}},[Symbol.iterator](){return this}}}}function dt(e){return function(...n){return e==="delete"?!1:e==="clear"?void 0:this}}function vs(e,n){const t={get(i){const o=this.__v_raw,s=z(o),a=z(i);e||(un(i,a)&&ce(s,"get",i),ce(s,"get",a));const{has:l}=ft(s),u=n?ir:e?Gn:De;if(l.call(s,i))return u(o.get(i));if(l.call(s,a))return u(o.get(a));o!==s&&o.get(i)},get size(){const i=this.__v_raw;return!e&&ce(z(i),"iterate",xn),i.size},has(i){const o=this.__v_raw,s=z(o),a=z(i);return e||(un(i,a)&&ce(s,"has",i),ce(s,"has",a)),i===a?o.has(i):o.has(i)||o.has(a)},forEach(i,o){const s=this,a=s.__v_raw,l=z(a),u=n?ir:e?Gn:De;return!e&&ce(l,"iterate",xn),a.forEach((f,_)=>i.call(o,u(f),u(_),s))}};return ue(t,e?{add:dt("add"),set:dt("set"),delete:dt("delete"),clear:dt("clear")}:{add(i){!n&&!Ae(i)&&!en(i)&&(i=z(i));const o=z(this);return ft(o).has.call(o,i)||(o.add(i),qe(o,"add",i,i)),this},set(i,o){!n&&!Ae(o)&&!en(o)&&(o=z(o));const s=z(this),{has:a,get:l}=ft(s);let u=a.call(s,i);u||(i=z(i),u=a.call(s,i));const f=l.call(s,i);return s.set(i,o),u?un(o,f)&&qe(s,"set",i,o):qe(s,"add",i,o),this},delete(i){const o=z(this),{has:s,get:a}=ft(o);let l=s.call(o,i);l||(i=z(i),l=s.call(o,i)),a&&a.call(o,i);const u=o.delete(i);return l&&qe(o,"delete",i,void 0),u},clear(){const i=z(this),o=i.size!==0,s=i.clear();return o&&qe(i,"clear",void 0,void 0),s}}),["keys","values","entries",Symbol.iterator].forEach(i=>{t[i]=xs(i,e,n)}),t}function Tr(e,n){const t=vs(e,n);return(r,i,o)=>i==="__v_isReactive"?!e:i==="__v_isReadonly"?e:i==="__v_raw"?r:Reflect.get(X(t,i)&&i in r?t:r,i,o)}const Es={get:Tr(!1,!1)},Ts={get:Tr(!1,!0)},Ss={get:Tr(!0,!1)};const qi=new WeakMap,$i=new WeakMap,Qi=new WeakMap,Rs=new WeakMap;function As(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Is(e){return e.__v_skip||!Object.isExtensible(e)?0:As(Jo(e))}function Nt(e){return en(e)?e:Sr(e,!1,ws,Es,qi)}function Ji(e){return Sr(e,!1,bs,Ts,$i)}function or(e){return Sr(e,!0,ys,Ss,Qi)}function Sr(e,n,t,r,i){if(!ee(e)||e.__v_raw&&!(n&&e.__v_isReactive))return e;const o=Is(e);if(o===0)return e;const s=i.get(e);if(s)return s;const a=new Proxy(e,o===2?r:t);return i.set(e,a),a}function vn(e){return en(e)?vn(e.__v_raw):!!(e&&e.__v_isReactive)}function en(e){return!!(e&&e.__v_isReadonly)}function Ae(e){return!!(e&&e.__v_isShallow)}function Rr(e){return e?!!e.__v_raw:!1}function z(e){const n=e&&e.__v_raw;return n?z(n):e}function Os(e){return!X(e,"__v_skip")&&Object.isExtensible(e)&&ki(e,"__v_skip",!0),e}const De=e=>ee(e)?Nt(e):e,Gn=e=>ee(e)?or(e):e;function de(e){return e?e.__v_isRef===!0:!1}function tt(e){return eo(e,!1)}function Cs(e){return eo(e,!0)}function eo(e,n){return de(e)?e:new Ls(e,n)}class Ls{constructor(n,t){this.dep=new Er,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=t?n:z(n),this._value=t?n:De(n),this.__v_isShallow=t}get value(){return this.dep.track(),this._value}set value(n){const t=this._rawValue,r=this.__v_isShallow||Ae(n)||en(n);n=r?n:z(n),un(n,t)&&(this._rawValue=n,this._value=r?n:De(n),this.dep.trigger())}}function Nn(e){return de(e)?e.value:e}const Ds={get:(e,n,t)=>n==="__v_raw"?e:Nn(Reflect.get(e,n,t)),set:(e,n,t,r)=>{const i=e[n];return de(i)&&!de(t)?(i.value=t,!0):Reflect.set(e,n,t,r)}};function no(e){return vn(e)?e:new Proxy(e,Ds)}class Ns{constructor(n,t,r){this.fn=n,this.setter=t,this._value=void 0,this.dep=new Er(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=et-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!t,this.isSSR=r}notify(){if(this.flags|=16,!(this.flags&8)&&Q!==this)return Wi(this,!0),!0}get value(){const n=this.dep.track();return Vi(this),n&&(n.version=this.dep.version),this._value}set value(n){this.setter&&this.setter(n)}}function Ps(e,n,t=!1){let r,i;return H(e)?r=e:(r=e.get,i=e.set),new Ns(r,i,t)}const ut={},wt=new WeakMap;let yn;function ks(e,n=!1,t=yn){if(t){let r=wt.get(t);r||wt.set(t,r=[]),r.push(e)}}function Gs(e,n,t=J){const{immediate:r,deep:i,once:o,scheduler:s,augmentJob:a,call:l}=t,u=L=>i?L:Ae(L)||i===!1||i===0?dn(L,1):dn(L);let f,_,p,g,A=!1,O=!1;if(de(e)?(_=()=>e.value,A=Ae(e)):vn(e)?(_=()=>u(e),A=!0):B(e)?(O=!0,A=e.some(L=>vn(L)||Ae(L)),_=()=>e.map(L=>{if(de(L))return L.value;if(vn(L))return u(L);if(H(L))return l?l(L,2):L()})):H(e)?n?_=l?()=>l(e,2):e:_=()=>{if(p){Qe();try{p()}finally{Je()}}const L=yn;yn=f;try{return l?l(e,3,[g]):e(g)}finally{yn=L}}:_=Ve,n&&i){const L=_,q=i===!0?1/0:i;_=()=>dn(L(),q)}const F=fs(),D=()=>{f.stop(),F&&F.active&&wr(F.effects,f)};if(o&&n){const L=n;n=(...q)=>{L(...q),D()}}let C=O?new Array(e.length).fill(ut):ut;const k=L=>{if(!(!(f.flags&1)||!f.dirty&&!L))if(n){const q=f.run();if(i||A||(O?q.some((le,ne)=>un(le,C[ne])):un(q,C))){p&&p();const le=yn;yn=f;try{const ne=[q,C===ut?void 0:O&&C[0]===ut?[]:C,g];C=q,l?l(n,3,ne):n(...ne)}finally{yn=le}}}else f.run()};return a&&a(k),f=new Hi(_),f.scheduler=s?()=>s(k,!1):k,g=L=>ks(L,!1,f),p=f.onStop=()=>{const L=wt.get(f);if(L){if(l)l(L,4);else for(const q of L)q();wt.delete(f)}},n?r?k(!0):C=f.run():s?s(k.bind(null,!0),!0):f.run(),D.pause=f.pause.bind(f),D.resume=f.resume.bind(f),D.stop=D,D}function dn(e,n=1/0,t){if(n<=0||!ee(e)||e.__v_skip||(t=t||new Map,(t.get(e)||0)>=n))return e;if(t.set(e,n),n--,de(e))dn(e.value,n,t);else if(B(e))for(let r=0;r<e.length;r++)dn(e[r],n,t);else if(Li(e)||Dn(e))e.forEach(r=>{dn(r,n,t)});else if(Pi(e)){for(const r in e)dn(e[r],n,t);for(const r of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,r)&&dn(e[r],n,t)}return e}function lt(e,n,t,r){try{return r?e(...r):e()}catch(i){Pt(i,n,t)}}function ze(e,n,t,r){if(H(e)){const i=lt(e,n,t,r);return i&&Di(i)&&i.catch(o=>{Pt(o,n,t)}),i}if(B(e)){const i=[];for(let o=0;o<e.length;o++)i.push(ze(e[o],n,t,r));return i}}function Pt(e,n,t,r=!0){const i=n?n.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:s}=n&&n.appContext.config||J;if(n){let a=n.parent;const l=n.proxy,u=`https://vuejs.org/error-reference/#runtime-${t}`;for(;a;){const f=a.ec;if(f){for(let _=0;_<f.length;_++)if(f[_](e,l,u)===!1)return}a=a.parent}if(o){Qe(),lt(o,null,10,[e,l,u]),Je();return}}Ms(e,t,i,r,s)}function Ms(e,n,t,r=!0,i=!1){if(i)throw e;console.error(e)}const pe=[];let Ue=-1;const Pn=[];let ln=null,In=0;const to=Promise.resolve();let yt=null;function ro(e){const n=yt||to;return e?n.then(this?e.bind(this):e):n}function Bs(e){let n=Ue+1,t=pe.length;for(;n<t;){const r=n+t>>>1,i=pe[r],o=rt(i);o<e||o===e&&i.flags&2?n=r+1:t=r}return n}function Ar(e){if(!(e.flags&1)){const n=rt(e),t=pe[pe.length-1];!t||!(e.flags&2)&&n>=rt(t)?pe.push(e):pe.splice(Bs(n),0,e),e.flags|=1,io()}}function io(){yt||(yt=to.then(so))}function Hs(e){B(e)?Pn.push(...e):ln&&e.id===-1?ln.splice(In+1,0,e):e.flags&1||(Pn.push(e),e.flags|=1),io()}function jr(e,n,t=Ue+1){for(;t<pe.length;t++){const r=pe[t];if(r&&r.flags&2){if(e&&r.id!==e.uid)continue;pe.splice(t,1),t--,r.flags&4&&(r.flags&=-2),r(),r.flags&4||(r.flags&=-2)}}}function oo(e){if(Pn.length){const n=[...new Set(Pn)].sort((t,r)=>rt(t)-rt(r));if(Pn.length=0,ln){ln.push(...n);return}for(ln=n,In=0;In<ln.length;In++){const t=ln[In];t.flags&4&&(t.flags&=-2),t.flags&8||t(),t.flags&=-2}ln=null,In=0}}const rt=e=>e.id==null?e.flags&2?-1:1/0:e.id;function so(e){try{for(Ue=0;Ue<pe.length;Ue++){const n=pe[Ue];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),lt(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;Ue<pe.length;Ue++){const n=pe[Ue];n&&(n.flags&=-2)}Ue=-1,pe.length=0,oo(),yt=null,(pe.length||Pn.length)&&so()}}let Ce=null,ao=null;function bt(e){const n=Ce;return Ce=e,ao=e&&e.type.__scopeId||null,n}function Fs(e,n=Ce,t){if(!n||e._n)return e;const r=(...i)=>{r._d&&Et(-1);const o=bt(n);let s;try{s=e(...i)}finally{bt(o),r._d&&Et(1)}return s};return r._n=!0,r._c=!0,r._d=!0,r}function mn(e,n,t,r){const i=e.dirs,o=n&&n.dirs;for(let s=0;s<i.length;s++){const a=i[s];o&&(a.oldValue=o[s].value);let l=a.dir[r];l&&(Qe(),ze(l,t,8,[e.el,a,e,n]),Je())}}const Ws=Symbol("_vte"),Us=e=>e.__isTeleport,js=Symbol("_leaveCb");function Ir(e,n){e.shapeFlag&6&&e.component?(e.transition=n,Ir(e.component.subTree,n)):e.shapeFlag&128?(e.ssContent.transition=n.clone(e.ssContent),e.ssFallback.transition=n.clone(e.ssFallback)):e.transition=n}function lo(e,n){return H(e)?ue({name:e.name},n,{setup:e}):e}function co(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}const xt=new WeakMap;function Zn(e,n,t,r,i=!1){if(B(e)){e.forEach((A,O)=>Zn(A,n&&(B(n)?n[O]:n),t,r,i));return}if(qn(r)&&!i){r.shapeFlag&512&&r.type.__asyncResolved&&r.component.subTree.component&&Zn(e,n,t,r.component.subTree);return}const o=r.shapeFlag&4?Pr(r.component):r.el,s=i?null:o,{i:a,r:l}=e,u=n&&n.r,f=a.refs===J?a.refs={}:a.refs,_=a.setupState,p=z(_),g=_===J?Ci:A=>X(p,A);if(u!=null&&u!==l){if(Vr(n),oe(u))f[u]=null,g(u)&&(_[u]=null);else if(de(u)){u.value=null;const A=n;A.k&&(f[A.k]=null)}}if(H(l))lt(l,a,12,[s,f]);else{const A=oe(l),O=de(l);if(A||O){const F=()=>{if(e.f){const D=A?g(l)?_[l]:f[l]:l.value;if(i)B(D)&&wr(D,o);else if(B(D))D.includes(o)||D.push(o);else if(A)f[l]=[o],g(l)&&(_[l]=f[l]);else{const C=[o];l.value=C,e.k&&(f[e.k]=C)}}else A?(f[l]=s,g(l)&&(_[l]=s)):O&&(l.value=s,e.k&&(f[e.k]=s))};if(s){const D=()=>{F(),xt.delete(e)};D.id=-1,xt.set(e,D),Ee(D,t)}else Vr(e),F()}}}function Vr(e){const n=xt.get(e);n&&(n.flags|=8,xt.delete(e))}Ct().requestIdleCallback;Ct().cancelIdleCallback;const qn=e=>!!e.type.__asyncLoader,fo=e=>e.type.__isKeepAlive;function Vs(e,n){uo(e,"a",n)}function zs(e,n){uo(e,"da",n)}function uo(e,n,t=fe){const r=e.__wdc||(e.__wdc=()=>{let i=t;for(;i;){if(i.isDeactivated)return;i=i.parent}return e()});if(kt(n,r,t),t){let i=t.parent;for(;i&&i.parent;)fo(i.parent.vnode)&&Xs(r,n,t,i),i=i.parent}}function Xs(e,n,t,r){const i=kt(n,e,r,!0);Cr(()=>{wr(r[n],i)},t)}function kt(e,n,t=fe,r=!1){if(t){const i=t[e]||(t[e]=[]),o=n.__weh||(n.__weh=(...s)=>{Qe();const a=ct(t),l=ze(n,t,e,s);return a(),Je(),l});return r?i.unshift(o):i.push(o),o}}const nn=e=>(n,t=fe)=>{(!ot||e==="sp")&&kt(e,(...r)=>n(...r),t)},Ys=nn("bm"),Or=nn("m"),Ks=nn("bu"),Zs=nn("u"),qs=nn("bum"),Cr=nn("um"),$s=nn("sp"),Qs=nn("rtg"),Js=nn("rtc");function ea(e,n=fe){kt("ec",e,n)}const na="components";function ta(e,n){return ia(na,e,!0,n)||e}const ra=Symbol.for("v-ndc");function ia(e,n,t=!0,r=!1){const i=Ce||fe;if(i){const o=i.type;{const a=Xa(o,!1);if(a&&(a===n||a===Ie(n)||a===Ot(Ie(n))))return o}const s=zr(i[e]||o[e],n)||zr(i.appContext[e],n);return!s&&r?o:s}}function zr(e,n){return e&&(e[n]||e[Ie(n)]||e[Ot(Ie(n))])}function Cn(e,n,t,r){let i;const o=t,s=B(e);if(s||oe(e)){const a=s&&vn(e);let l=!1,u=!1;a&&(l=!Ae(e),u=en(e),e=Dt(e)),i=new Array(e.length);for(let f=0,_=e.length;f<_;f++)i[f]=n(l?u?Gn(De(e[f])):De(e[f]):e[f],f,void 0,o)}else if(typeof e=="number"){i=new Array(e);for(let a=0;a<e;a++)i[a]=n(a+1,a,void 0,o)}else if(ee(e))if(e[Symbol.iterator])i=Array.from(e,(a,l)=>n(a,l,void 0,o));else{const a=Object.keys(e);i=new Array(a.length);for(let l=0,u=a.length;l<u;l++){const f=a[l];i[l]=n(e[f],f,l,o)}}else i=[];return i}const sr=e=>e?Po(e)?Pr(e):sr(e.parent):null,$n=ue(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>sr(e.parent),$root:e=>sr(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>ho(e),$forceUpdate:e=>e.f||(e.f=()=>{Ar(e.update)}),$nextTick:e=>e.n||(e.n=ro.bind(e.proxy)),$watch:e=>pa.bind(e)}),Xt=(e,n)=>e!==J&&!e.__isScriptSetup&&X(e,n),oa={get({_:e},n){if(n==="__v_skip")return!0;const{ctx:t,setupState:r,data:i,props:o,accessCache:s,type:a,appContext:l}=e;if(n[0]!=="$"){const p=s[n];if(p!==void 0)switch(p){case 1:return r[n];case 2:return i[n];case 4:return t[n];case 3:return o[n]}else{if(Xt(r,n))return s[n]=1,r[n];if(i!==J&&X(i,n))return s[n]=2,i[n];if(X(o,n))return s[n]=3,o[n];if(t!==J&&X(t,n))return s[n]=4,t[n];ar&&(s[n]=0)}}const u=$n[n];let f,_;if(u)return n==="$attrs"&&ce(e.attrs,"get",""),u(e);if((f=a.__cssModules)&&(f=f[n]))return f;if(t!==J&&X(t,n))return s[n]=4,t[n];if(_=l.config.globalProperties,X(_,n))return _[n]},set({_:e},n,t){const{data:r,setupState:i,ctx:o}=e;return Xt(i,n)?(i[n]=t,!0):r!==J&&X(r,n)?(r[n]=t,!0):X(e.props,n)||n[0]==="$"&&n.slice(1)in e?!1:(o[n]=t,!0)},has({_:{data:e,setupState:n,accessCache:t,ctx:r,appContext:i,props:o,type:s}},a){let l;return!!(t[a]||e!==J&&a[0]!=="$"&&X(e,a)||Xt(n,a)||X(o,a)||X(r,a)||X($n,a)||X(i.config.globalProperties,a)||(l=s.__cssModules)&&l[a])},defineProperty(e,n,t){return t.get!=null?e._.accessCache[n]=0:X(t,"value")&&this.set(e,n,t.value,null),Reflect.defineProperty(e,n,t)}};function Xr(e){return B(e)?e.reduce((n,t)=>(n[t]=null,n),{}):e}let ar=!0;function sa(e){const n=ho(e),t=e.proxy,r=e.ctx;ar=!1,n.beforeCreate&&Yr(n.beforeCreate,e,"bc");const{data:i,computed:o,methods:s,watch:a,provide:l,inject:u,created:f,beforeMount:_,mounted:p,beforeUpdate:g,updated:A,activated:O,deactivated:F,beforeDestroy:D,beforeUnmount:C,destroyed:k,unmounted:L,render:q,renderTracked:le,renderTriggered:ne,errorCaptured:Pe,serverPrefetch:tn,expose:ke,inheritAttrs:rn,components:pn,directives:Ge,filters:Fn}=n;if(u&&aa(u,r,null),s)for(const Z in s){const j=s[Z];H(j)&&(r[Z]=j.bind(t))}if(i){const Z=i.call(t,t);ee(Z)&&(e.data=Nt(Z))}if(ar=!0,o)for(const Z in o){const j=o[Z],Xe=H(j)?j.bind(t,t):H(j.get)?j.get.bind(t,t):Ve,on=!H(j)&&H(j.set)?j.set.bind(t):Ve,Me=Re({get:Xe,set:on});Object.defineProperty(r,Z,{enumerable:!0,configurable:!0,get:()=>Me.value,set:me=>Me.value=me})}if(a)for(const Z in a)_o(a[Z],r,t,Z);if(l){const Z=H(l)?l.call(t):l;Reflect.ownKeys(Z).forEach(j=>{ht(j,Z[j])})}f&&Yr(f,e,"c");function ae(Z,j){B(j)?j.forEach(Xe=>Z(Xe.bind(t))):j&&Z(j.bind(t))}if(ae(Ys,_),ae(Or,p),ae(Ks,g),ae(Zs,A),ae(Vs,O),ae(zs,F),ae(ea,Pe),ae(Js,le),ae(Qs,ne),ae(qs,C),ae(Cr,L),ae($s,tn),B(ke))if(ke.length){const Z=e.exposed||(e.exposed={});ke.forEach(j=>{Object.defineProperty(Z,j,{get:()=>t[j],set:Xe=>t[j]=Xe,enumerable:!0})})}else e.exposed||(e.exposed={});q&&e.render===Ve&&(e.render=q),rn!=null&&(e.inheritAttrs=rn),pn&&(e.components=pn),Ge&&(e.directives=Ge),tn&&co(e)}function aa(e,n,t=Ve){B(e)&&(e=lr(e));for(const r in e){const i=e[r];let o;ee(i)?"default"in i?o=$e(i.from||r,i.default,!0):o=$e(i.from||r):o=$e(i),de(o)?Object.defineProperty(n,r,{enumerable:!0,configurable:!0,get:()=>o.value,set:s=>o.value=s}):n[r]=o}}function Yr(e,n,t){ze(B(e)?e.map(r=>r.bind(n.proxy)):e.bind(n.proxy),n,t)}function _o(e,n,t,r){let i=r.includes(".")?mo(t,r):()=>t[r];if(oe(e)){const o=n[e];H(o)&&pt(i,o)}else if(H(e))pt(i,e.bind(t));else if(ee(e))if(B(e))e.forEach(o=>_o(o,n,t,r));else{const o=H(e.handler)?e.handler.bind(t):n[e.handler];H(o)&&pt(i,o,e)}}function ho(e){const n=e.type,{mixins:t,extends:r}=n,{mixins:i,optionsCache:o,config:{optionMergeStrategies:s}}=e.appContext,a=o.get(n);let l;return a?l=a:!i.length&&!t&&!r?l=n:(l={},i.length&&i.forEach(u=>vt(l,u,s,!0)),vt(l,n,s)),ee(n)&&o.set(n,l),l}function vt(e,n,t,r=!1){const{mixins:i,extends:o}=n;o&&vt(e,o,t,!0),i&&i.forEach(s=>vt(e,s,t,!0));for(const s in n)if(!(r&&s==="expose")){const a=la[s]||t&&t[s];e[s]=a?a(e[s],n[s]):n[s]}return e}const la={data:Kr,props:Zr,emits:Zr,methods:zn,computed:zn,beforeCreate:_e,created:_e,beforeMount:_e,mounted:_e,beforeUpdate:_e,updated:_e,beforeDestroy:_e,beforeUnmount:_e,destroyed:_e,unmounted:_e,activated:_e,deactivated:_e,errorCaptured:_e,serverPrefetch:_e,components:zn,directives:zn,watch:fa,provide:Kr,inject:ca};function Kr(e,n){return n?e?function(){return ue(H(e)?e.call(this,this):e,H(n)?n.call(this,this):n)}:n:e}function ca(e,n){return zn(lr(e),lr(n))}function lr(e){if(B(e)){const n={};for(let t=0;t<e.length;t++)n[e[t]]=e[t];return n}return e}function _e(e,n){return e?[...new Set([].concat(e,n))]:n}function zn(e,n){return e?ue(Object.create(null),e,n):n}function Zr(e,n){return e?B(e)&&B(n)?[...new Set([...e,...n])]:ue(Object.create(null),Xr(e),Xr(n??{})):n}function fa(e,n){if(!e)return n;if(!n)return e;const t=ue(Object.create(null),e);for(const r in n)t[r]=_e(e[r],n[r]);return t}function po(){return{app:null,config:{isNativeTag:Ci,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let da=0;function ua(e,n){return function(r,i=null){H(r)||(r=ue({},r)),i!=null&&!ee(i)&&(i=null);const o=po(),s=new WeakSet,a=[];let l=!1;const u=o.app={_uid:da++,_component:r,_props:i,_container:null,_context:o,_instance:null,version:Ka,get config(){return o.config},set config(f){},use(f,..._){return s.has(f)||(f&&H(f.install)?(s.add(f),f.install(u,..._)):H(f)&&(s.add(f),f(u,..._))),u},mixin(f){return o.mixins.includes(f)||o.mixins.push(f),u},component(f,_){return _?(o.components[f]=_,u):o.components[f]},directive(f,_){return _?(o.directives[f]=_,u):o.directives[f]},mount(f,_,p){if(!l){const g=u._ceVNode||xe(r,i);return g.appContext=o,p===!0?p="svg":p===!1&&(p=void 0),e(g,f,p),l=!0,u._container=f,f.__vue_app__=u,Pr(g.component)}},onUnmount(f){a.push(f)},unmount(){l&&(ze(a,u._instance,16),e(null,u._container),delete u._container.__vue_app__)},provide(f,_){return o.provides[f]=_,u},runWithContext(f){const _=kn;kn=u;try{return f()}finally{kn=_}}};return u}}let kn=null;function ht(e,n){if(fe){let t=fe.provides;const r=fe.parent&&fe.parent.provides;r===t&&(t=fe.provides=Object.create(r)),t[e]=n}}function $e(e,n,t=!1){const r=Wa();if(r||kn){let i=kn?kn._context.provides:r?r.parent==null||r.ce?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides:void 0;if(i&&e in i)return i[e];if(arguments.length>1)return t&&H(n)?n.call(r&&r.proxy):n}}const _a=Symbol.for("v-scx"),ha=()=>$e(_a);function pt(e,n,t){return go(e,n,t)}function go(e,n,t=J){const{immediate:r,deep:i,flush:o,once:s}=t,a=ue({},t),l=n&&r||!n&&o!=="post";let u;if(ot){if(o==="sync"){const g=ha();u=g.__watcherHandles||(g.__watcherHandles=[])}else if(!l){const g=()=>{};return g.stop=Ve,g.resume=Ve,g.pause=Ve,g}}const f=fe;a.call=(g,A,O)=>ze(g,f,A,O);let _=!1;o==="post"?a.scheduler=g=>{Ee(g,f&&f.suspense)}:o!=="sync"&&(_=!0,a.scheduler=(g,A)=>{A?g():Ar(g)}),a.augmentJob=g=>{n&&(g.flags|=4),_&&(g.flags|=2,f&&(g.id=f.uid,g.i=f))};const p=Gs(e,n,a);return ot&&(u?u.push(p):l&&p()),p}function pa(e,n,t){const r=this.proxy,i=oe(e)?e.includes(".")?mo(r,e):()=>r[e]:e.bind(r,r);let o;H(n)?o=n:(o=n.handler,t=n);const s=ct(this),a=go(i,o.bind(r),t);return s(),a}function mo(e,n){const t=n.split(".");return()=>{let r=e;for(let i=0;i<t.length&&r;i++)r=r[t[i]];return r}}const ga=(e,n)=>n==="modelValue"||n==="model-value"?e.modelModifiers:e[`${n}Modifiers`]||e[`${Ie(n)}Modifiers`]||e[`${En(n)}Modifiers`];function ma(e,n,...t){if(e.isUnmounted)return;const r=e.vnode.props||J;let i=t;const o=n.startsWith("update:"),s=o&&ga(r,n.slice(7));s&&(s.trim&&(i=t.map(f=>oe(f)?f.trim():f)),s.number&&(i=t.map(ts)));let a,l=r[a=Ft(n)]||r[a=Ft(Ie(n))];!l&&o&&(l=r[a=Ft(En(n))]),l&&ze(l,e,6,i);const u=r[a+"Once"];if(u){if(!e.emitted)e.emitted={};else if(e.emitted[a])return;e.emitted[a]=!0,ze(u,e,6,i)}}const wa=new WeakMap;function wo(e,n,t=!1){const r=t?wa:n.emitsCache,i=r.get(e);if(i!==void 0)return i;const o=e.emits;let s={},a=!1;if(!H(e)){const l=u=>{const f=wo(u,n,!0);f&&(a=!0,ue(s,f))};!t&&n.mixins.length&&n.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!o&&!a?(ee(e)&&r.set(e,null),null):(B(o)?o.forEach(l=>s[l]=null):ue(s,o),ee(e)&&r.set(e,s),s)}function Gt(e,n){return!e||!Rt(n)?!1:(n=n.slice(2).replace(/Once$/,""),X(e,n[0].toLowerCase()+n.slice(1))||X(e,En(n))||X(e,n))}function qr(e){const{type:n,vnode:t,proxy:r,withProxy:i,propsOptions:[o],slots:s,attrs:a,emit:l,render:u,renderCache:f,props:_,data:p,setupState:g,ctx:A,inheritAttrs:O}=e,F=bt(e);let D,C;try{if(t.shapeFlag&4){const L=i||r,q=L;D=je(u.call(q,L,f,_,g,p,A)),C=a}else{const L=n;D=je(L.length>1?L(_,{attrs:a,slots:s,emit:l}):L(_,null)),C=n.props?a:ya(a)}}catch(L){Qn.length=0,Pt(L,e,1),D=xe(_n)}let k=D;if(C&&O!==!1){const L=Object.keys(C),{shapeFlag:q}=k;L.length&&q&7&&(o&&L.some(mr)&&(C=ba(C,o)),k=Mn(k,C,!1,!0))}return t.dirs&&(k=Mn(k,null,!1,!0),k.dirs=k.dirs?k.dirs.concat(t.dirs):t.dirs),t.transition&&Ir(k,t.transition),D=k,bt(F),D}const ya=e=>{let n;for(const t in e)(t==="class"||t==="style"||Rt(t))&&((n||(n={}))[t]=e[t]);return n},ba=(e,n)=>{const t={};for(const r in e)(!mr(r)||!(r.slice(9)in n))&&(t[r]=e[r]);return t};function xa(e,n,t){const{props:r,children:i,component:o}=e,{props:s,children:a,patchFlag:l}=n,u=o.emitsOptions;if(n.dirs||n.transition)return!0;if(t&&l>=0){if(l&1024)return!0;if(l&16)return r?$r(r,s,u):!!s;if(l&8){const f=n.dynamicProps;for(let _=0;_<f.length;_++){const p=f[_];if(s[p]!==r[p]&&!Gt(u,p))return!0}}}else return(i||a)&&(!a||!a.$stable)?!0:r===s?!1:r?s?$r(r,s,u):!0:!!s;return!1}function $r(e,n,t){const r=Object.keys(n);if(r.length!==Object.keys(e).length)return!0;for(let i=0;i<r.length;i++){const o=r[i];if(n[o]!==e[o]&&!Gt(t,o))return!0}return!1}function va({vnode:e,parent:n},t){for(;n;){const r=n.subTree;if(r.suspense&&r.suspense.activeBranch===e&&(r.el=e.el),r===e)(e=n.vnode).el=t,n=n.parent;else break}}const yo={},bo=()=>Object.create(yo),xo=e=>Object.getPrototypeOf(e)===yo;function Ea(e,n,t,r=!1){const i={},o=bo();e.propsDefaults=Object.create(null),vo(e,n,i,o);for(const s in e.propsOptions[0])s in i||(i[s]=void 0);t?e.props=r?i:Ji(i):e.type.props?e.props=i:e.props=o,e.attrs=o}function Ta(e,n,t,r){const{props:i,attrs:o,vnode:{patchFlag:s}}=e,a=z(i),[l]=e.propsOptions;let u=!1;if((r||s>0)&&!(s&16)){if(s&8){const f=e.vnode.dynamicProps;for(let _=0;_<f.length;_++){let p=f[_];if(Gt(e.emitsOptions,p))continue;const g=n[p];if(l)if(X(o,p))g!==o[p]&&(o[p]=g,u=!0);else{const A=Ie(p);i[A]=cr(l,a,A,g,e,!1)}else g!==o[p]&&(o[p]=g,u=!0)}}}else{vo(e,n,i,o)&&(u=!0);let f;for(const _ in a)(!n||!X(n,_)&&((f=En(_))===_||!X(n,f)))&&(l?t&&(t[_]!==void 0||t[f]!==void 0)&&(i[_]=cr(l,a,_,void 0,e,!0)):delete i[_]);if(o!==a)for(const _ in o)(!n||!X(n,_))&&(delete o[_],u=!0)}u&&qe(e.attrs,"set","")}function vo(e,n,t,r){const[i,o]=e.propsOptions;let s=!1,a;if(n)for(let l in n){if(Xn(l))continue;const u=n[l];let f;i&&X(i,f=Ie(l))?!o||!o.includes(f)?t[f]=u:(a||(a={}))[f]=u:Gt(e.emitsOptions,l)||(!(l in r)||u!==r[l])&&(r[l]=u,s=!0)}if(o){const l=z(t),u=a||J;for(let f=0;f<o.length;f++){const _=o[f];t[_]=cr(i,l,_,u[_],e,!X(u,_))}}return s}function cr(e,n,t,r,i,o){const s=e[t];if(s!=null){const a=X(s,"default");if(a&&r===void 0){const l=s.default;if(s.type!==Function&&!s.skipFactory&&H(l)){const{propsDefaults:u}=i;if(t in u)r=u[t];else{const f=ct(i);r=u[t]=l.call(null,n),f()}}else r=l;i.ce&&i.ce._setProp(t,r)}s[0]&&(o&&!a?r=!1:s[1]&&(r===""||r===En(t))&&(r=!0))}return r}const Sa=new WeakMap;function Eo(e,n,t=!1){const r=t?Sa:n.propsCache,i=r.get(e);if(i)return i;const o=e.props,s={},a=[];let l=!1;if(!H(e)){const f=_=>{l=!0;const[p,g]=Eo(_,n,!0);ue(s,p),g&&a.push(...g)};!t&&n.mixins.length&&n.mixins.forEach(f),e.extends&&f(e.extends),e.mixins&&e.mixins.forEach(f)}if(!o&&!l)return ee(e)&&r.set(e,Ln),Ln;if(B(o))for(let f=0;f<o.length;f++){const _=Ie(o[f]);Qr(_)&&(s[_]=J)}else if(o)for(const f in o){const _=Ie(f);if(Qr(_)){const p=o[f],g=s[_]=B(p)||H(p)?{type:p}:ue({},p),A=g.type;let O=!1,F=!0;if(B(A))for(let D=0;D<A.length;++D){const C=A[D],k=H(C)&&C.name;if(k==="Boolean"){O=!0;break}else k==="String"&&(F=!1)}else O=H(A)&&A.name==="Boolean";g[0]=O,g[1]=F,(O||X(g,"default"))&&a.push(_)}}const u=[s,a];return ee(e)&&r.set(e,u),u}function Qr(e){return e[0]!=="$"&&!Xn(e)}const Lr=e=>e==="_"||e==="_ctx"||e==="$stable",Dr=e=>B(e)?e.map(je):[je(e)],Ra=(e,n,t)=>{if(n._n)return n;const r=Fs((...i)=>Dr(n(...i)),t);return r._c=!1,r},To=(e,n,t)=>{const r=e._ctx;for(const i in e){if(Lr(i))continue;const o=e[i];if(H(o))n[i]=Ra(i,o,r);else if(o!=null){const s=Dr(o);n[i]=()=>s}}},So=(e,n)=>{const t=Dr(n);e.slots.default=()=>t},Ro=(e,n,t)=>{for(const r in n)(t||!Lr(r))&&(e[r]=n[r])},Aa=(e,n,t)=>{const r=e.slots=bo();if(e.vnode.shapeFlag&32){const i=n._;i?(Ro(r,n,t),t&&ki(r,"_",i,!0)):To(n,r)}else n&&So(e,n)},Ia=(e,n,t)=>{const{vnode:r,slots:i}=e;let o=!0,s=J;if(r.shapeFlag&32){const a=n._;a?t&&a===1?o=!1:Ro(i,n,t):(o=!n.$stable,To(n,i)),s=n}else n&&(So(e,n),s={default:1});if(o)for(const a in i)!Lr(a)&&s[a]==null&&delete i[a]},Ee=Na;function Oa(e){return Ca(e)}function Ca(e,n){const t=Ct();t.__VUE__=!0;const{insert:r,remove:i,patchProp:o,createElement:s,createText:a,createComment:l,setText:u,setElementText:f,parentNode:_,nextSibling:p,setScopeId:g=Ve,insertStaticContent:A}=e,O=(c,d,h,w=null,b=null,m=null,T=void 0,E=null,v=!!d.dynamicChildren)=>{if(c===d)return;c&&!jn(c,d)&&(w=y(c),me(c,b,m,!0),c=null),d.patchFlag===-2&&(v=!1,d.dynamicChildren=null);const{type:x,ref:G,shapeFlag:R}=d;switch(x){case Mt:F(c,d,h,w);break;case _n:D(c,d,h,w);break;case Kt:c==null&&C(d,h,w,T);break;case ge:pn(c,d,h,w,b,m,T,E,v);break;default:R&1?q(c,d,h,w,b,m,T,E,v):R&6?Ge(c,d,h,w,b,m,T,E,v):(R&64||R&128)&&x.process(c,d,h,w,b,m,T,E,v,N)}G!=null&&b?Zn(G,c&&c.ref,m,d||c,!d):G==null&&c&&c.ref!=null&&Zn(c.ref,null,m,c,!0)},F=(c,d,h,w)=>{if(c==null)r(d.el=a(d.children),h,w);else{const b=d.el=c.el;d.children!==c.children&&u(b,d.children)}},D=(c,d,h,w)=>{c==null?r(d.el=l(d.children||""),h,w):d.el=c.el},C=(c,d,h,w)=>{[c.el,c.anchor]=A(c.children,d,h,w,c.el,c.anchor)},k=({el:c,anchor:d},h,w)=>{let b;for(;c&&c!==d;)b=p(c),r(c,h,w),c=b;r(d,h,w)},L=({el:c,anchor:d})=>{let h;for(;c&&c!==d;)h=p(c),i(c),c=h;i(d)},q=(c,d,h,w,b,m,T,E,v)=>{if(d.type==="svg"?T="svg":d.type==="math"&&(T="mathml"),c==null)le(d,h,w,b,m,T,E,v);else{const x=c.el&&c.el._isVueCE?c.el:null;try{x&&x._beginPatch(),tn(c,d,b,m,T,E,v)}finally{x&&x._endPatch()}}},le=(c,d,h,w,b,m,T,E)=>{let v,x;const{props:G,shapeFlag:R,transition:P,dirs:M}=c;if(v=c.el=s(c.type,m,G&&G.is,G),R&8?f(v,c.children):R&16&&Pe(c.children,v,null,w,b,Yt(c,m),T,E),M&&mn(c,null,w,"created"),ne(v,c,c.scopeId,T,w),G){for(const $ in G)$!=="value"&&!Xn($)&&o(v,$,null,G[$],m,w);"value"in G&&o(v,"value",null,G.value,m),(x=G.onVnodeBeforeMount)&&We(x,w,c)}M&&mn(c,null,w,"beforeMount");const U=La(b,P);U&&P.beforeEnter(v),r(v,d,h),((x=G&&G.onVnodeMounted)||U||M)&&Ee(()=>{x&&We(x,w,c),U&&P.enter(v),M&&mn(c,null,w,"mounted")},b)},ne=(c,d,h,w,b)=>{if(h&&g(c,h),w)for(let m=0;m<w.length;m++)g(c,w[m]);if(b){let m=b.subTree;if(d===m||Oo(m.type)&&(m.ssContent===d||m.ssFallback===d)){const T=b.vnode;ne(c,T,T.scopeId,T.slotScopeIds,b.parent)}}},Pe=(c,d,h,w,b,m,T,E,v=0)=>{for(let x=v;x<c.length;x++){const G=c[x]=E?cn(c[x]):je(c[x]);O(null,G,d,h,w,b,m,T,E)}},tn=(c,d,h,w,b,m,T)=>{const E=d.el=c.el;let{patchFlag:v,dynamicChildren:x,dirs:G}=d;v|=c.patchFlag&16;const R=c.props||J,P=d.props||J;let M;if(h&&wn(h,!1),(M=P.onVnodeBeforeUpdate)&&We(M,h,d,c),G&&mn(d,c,h,"beforeUpdate"),h&&wn(h,!0),(R.innerHTML&&P.innerHTML==null||R.textContent&&P.textContent==null)&&f(E,""),x?ke(c.dynamicChildren,x,E,h,w,Yt(d,b),m):T||j(c,d,E,null,h,w,Yt(d,b),m,!1),v>0){if(v&16)rn(E,R,P,h,b);else if(v&2&&R.class!==P.class&&o(E,"class",null,P.class,b),v&4&&o(E,"style",R.style,P.style,b),v&8){const U=d.dynamicProps;for(let $=0;$<U.length;$++){const Y=U[$],we=R[Y],ye=P[Y];(ye!==we||Y==="value")&&o(E,Y,we,ye,b,h)}}v&1&&c.children!==d.children&&f(E,d.children)}else!T&&x==null&&rn(E,R,P,h,b);((M=P.onVnodeUpdated)||G)&&Ee(()=>{M&&We(M,h,d,c),G&&mn(d,c,h,"updated")},w)},ke=(c,d,h,w,b,m,T)=>{for(let E=0;E<d.length;E++){const v=c[E],x=d[E],G=v.el&&(v.type===ge||!jn(v,x)||v.shapeFlag&198)?_(v.el):h;O(v,x,G,null,w,b,m,T,!0)}},rn=(c,d,h,w,b)=>{if(d!==h){if(d!==J)for(const m in d)!Xn(m)&&!(m in h)&&o(c,m,d[m],null,b,w);for(const m in h){if(Xn(m))continue;const T=h[m],E=d[m];T!==E&&m!=="value"&&o(c,m,E,T,b,w)}"value"in h&&o(c,"value",d.value,h.value,b)}},pn=(c,d,h,w,b,m,T,E,v)=>{const x=d.el=c?c.el:a(""),G=d.anchor=c?c.anchor:a("");let{patchFlag:R,dynamicChildren:P,slotScopeIds:M}=d;M&&(E=E?E.concat(M):M),c==null?(r(x,h,w),r(G,h,w),Pe(d.children||[],h,G,b,m,T,E,v)):R>0&&R&64&&P&&c.dynamicChildren?(ke(c.dynamicChildren,P,h,b,m,T,E),(d.key!=null||b&&d===b.subTree)&&Ao(c,d,!0)):j(c,d,h,G,b,m,T,E,v)},Ge=(c,d,h,w,b,m,T,E,v)=>{d.slotScopeIds=E,c==null?d.shapeFlag&512?b.ctx.activate(d,h,w,T,v):Fn(d,h,w,b,m,T,v):Tn(c,d,v)},Fn=(c,d,h,w,b,m,T)=>{const E=c.component=Fa(c,w,b);if(fo(c)&&(E.ctx.renderer=N),Ua(E,!1,T),E.asyncDep){if(b&&b.registerDep(E,ae,T),!c.el){const v=E.subTree=xe(_n);D(null,v,d,h),c.placeholder=v.el}}else ae(E,c,d,h,b,m,T)},Tn=(c,d,h)=>{const w=d.component=c.component;if(xa(c,d,h))if(w.asyncDep&&!w.asyncResolved){Z(w,d,h);return}else w.next=d,w.update();else d.el=c.el,w.vnode=d},ae=(c,d,h,w,b,m,T)=>{const E=()=>{if(c.isMounted){let{next:R,bu:P,u:M,parent:U,vnode:$}=c;{const He=Io(c);if(He){R&&(R.el=$.el,Z(c,R,T)),He.asyncDep.then(()=>{c.isUnmounted||E()});return}}let Y=R,we;wn(c,!1),R?(R.el=$.el,Z(c,R,T)):R=$,P&&Wt(P),(we=R.props&&R.props.onVnodeBeforeUpdate)&&We(we,U,R,$),wn(c,!0);const ye=qr(c),Be=c.subTree;c.subTree=ye,O(Be,ye,_(Be.el),y(Be),c,b,m),R.el=ye.el,Y===null&&va(c,ye.el),M&&Ee(M,b),(we=R.props&&R.props.onVnodeUpdated)&&Ee(()=>We(we,U,R,$),b)}else{let R;const{el:P,props:M}=d,{bm:U,m:$,parent:Y,root:we,type:ye}=c,Be=qn(d);wn(c,!1),U&&Wt(U),!Be&&(R=M&&M.onVnodeBeforeMount)&&We(R,Y,d),wn(c,!0);{we.ce&&we.ce._def.shadowRoot!==!1&&we.ce._injectChildStyle(ye);const He=c.subTree=qr(c);O(null,He,h,w,c,b,m),d.el=He.el}if($&&Ee($,b),!Be&&(R=M&&M.onVnodeMounted)){const He=d;Ee(()=>We(R,Y,He),b)}(d.shapeFlag&256||Y&&qn(Y.vnode)&&Y.vnode.shapeFlag&256)&&c.a&&Ee(c.a,b),c.isMounted=!0,d=h=w=null}};c.scope.on();const v=c.effect=new Hi(E);c.scope.off();const x=c.update=v.run.bind(v),G=c.job=v.runIfDirty.bind(v);G.i=c,G.id=c.uid,v.scheduler=()=>Ar(G),wn(c,!0),x()},Z=(c,d,h)=>{d.component=c;const w=c.vnode.props;c.vnode=d,c.next=null,Ta(c,d.props,w,h),Ia(c,d.children,h),Qe(),jr(c),Je()},j=(c,d,h,w,b,m,T,E,v=!1)=>{const x=c&&c.children,G=c?c.shapeFlag:0,R=d.children,{patchFlag:P,shapeFlag:M}=d;if(P>0){if(P&128){on(x,R,h,w,b,m,T,E,v);return}else if(P&256){Xe(x,R,h,w,b,m,T,E,v);return}}M&8?(G&16&&Se(x,b,m),R!==x&&f(h,R)):G&16?M&16?on(x,R,h,w,b,m,T,E,v):Se(x,b,m,!0):(G&8&&f(h,""),M&16&&Pe(R,h,w,b,m,T,E,v))},Xe=(c,d,h,w,b,m,T,E,v)=>{c=c||Ln,d=d||Ln;const x=c.length,G=d.length,R=Math.min(x,G);let P;for(P=0;P<R;P++){const M=d[P]=v?cn(d[P]):je(d[P]);O(c[P],M,h,null,b,m,T,E,v)}x>G?Se(c,b,m,!0,!1,R):Pe(d,h,w,b,m,T,E,v,R)},on=(c,d,h,w,b,m,T,E,v)=>{let x=0;const G=d.length;let R=c.length-1,P=G-1;for(;x<=R&&x<=P;){const M=c[x],U=d[x]=v?cn(d[x]):je(d[x]);if(jn(M,U))O(M,U,h,null,b,m,T,E,v);else break;x++}for(;x<=R&&x<=P;){const M=c[R],U=d[P]=v?cn(d[P]):je(d[P]);if(jn(M,U))O(M,U,h,null,b,m,T,E,v);else break;R--,P--}if(x>R){if(x<=P){const M=P+1,U=M<G?d[M].el:w;for(;x<=P;)O(null,d[x]=v?cn(d[x]):je(d[x]),h,U,b,m,T,E,v),x++}}else if(x>P)for(;x<=R;)me(c[x],b,m,!0),x++;else{const M=x,U=x,$=new Map;for(x=U;x<=P;x++){const ve=d[x]=v?cn(d[x]):je(d[x]);ve.key!=null&&$.set(ve.key,x)}let Y,we=0;const ye=P-U+1;let Be=!1,He=0;const Wn=new Array(ye);for(x=0;x<ye;x++)Wn[x]=0;for(x=M;x<=R;x++){const ve=c[x];if(we>=ye){me(ve,b,m,!0);continue}let Fe;if(ve.key!=null)Fe=$.get(ve.key);else for(Y=U;Y<=P;Y++)if(Wn[Y-U]===0&&jn(ve,d[Y])){Fe=Y;break}Fe===void 0?me(ve,b,m,!0):(Wn[Fe-U]=x+1,Fe>=He?He=Fe:Be=!0,O(ve,d[Fe],h,null,b,m,T,E,v),we++)}const Mr=Be?Da(Wn):Ln;for(Y=Mr.length-1,x=ye-1;x>=0;x--){const ve=U+x,Fe=d[ve],Br=d[ve+1],Hr=ve+1<G?Br.el||Br.placeholder:w;Wn[x]===0?O(null,Fe,h,Hr,b,m,T,E,v):Be&&(Y<0||x!==Mr[Y]?Me(Fe,h,Hr,2):Y--)}}},Me=(c,d,h,w,b=null)=>{const{el:m,type:T,transition:E,children:v,shapeFlag:x}=c;if(x&6){Me(c.component.subTree,d,h,w);return}if(x&128){c.suspense.move(d,h,w);return}if(x&64){T.move(c,d,h,N);return}if(T===ge){r(m,d,h);for(let R=0;R<v.length;R++)Me(v[R],d,h,w);r(c.anchor,d,h);return}if(T===Kt){k(c,d,h);return}if(w!==2&&x&1&&E)if(w===0)E.beforeEnter(m),r(m,d,h),Ee(()=>E.enter(m),b);else{const{leave:R,delayLeave:P,afterLeave:M}=E,U=()=>{c.ctx.isUnmounted?i(m):r(m,d,h)},$=()=>{m._isLeaving&&m[js](!0),R(m,()=>{U(),M&&M()})};P?P(m,U,$):$()}else r(m,d,h)},me=(c,d,h,w=!1,b=!1)=>{const{type:m,props:T,ref:E,children:v,dynamicChildren:x,shapeFlag:G,patchFlag:R,dirs:P,cacheIndex:M}=c;if(R===-2&&(b=!1),E!=null&&(Qe(),Zn(E,null,h,c,!0),Je()),M!=null&&(d.renderCache[M]=void 0),G&256){d.ctx.deactivate(c);return}const U=G&1&&P,$=!qn(c);let Y;if($&&(Y=T&&T.onVnodeBeforeUnmount)&&We(Y,d,c),G&6)gn(c.component,h,w);else{if(G&128){c.suspense.unmount(h,w);return}U&&mn(c,null,d,"beforeUnmount"),G&64?c.type.remove(c,d,h,N,w):x&&!x.hasOnce&&(m!==ge||R>0&&R&64)?Se(x,d,h,!1,!0):(m===ge&&R&384||!b&&G&16)&&Se(v,d,h),w&&Sn(c)}($&&(Y=T&&T.onVnodeUnmounted)||U)&&Ee(()=>{Y&&We(Y,d,c),U&&mn(c,null,d,"unmounted")},h)},Sn=c=>{const{type:d,el:h,anchor:w,transition:b}=c;if(d===ge){Rn(h,w);return}if(d===Kt){L(c);return}const m=()=>{i(h),b&&!b.persisted&&b.afterLeave&&b.afterLeave()};if(c.shapeFlag&1&&b&&!b.persisted){const{leave:T,delayLeave:E}=b,v=()=>T(h,m);E?E(c.el,m,v):v()}else m()},Rn=(c,d)=>{let h;for(;c!==d;)h=p(c),i(c),c=h;i(d)},gn=(c,d,h)=>{const{bum:w,scope:b,job:m,subTree:T,um:E,m:v,a:x}=c;Jr(v),Jr(x),w&&Wt(w),b.stop(),m&&(m.flags|=8,me(T,c,d,h)),E&&Ee(E,d),Ee(()=>{c.isUnmounted=!0},d)},Se=(c,d,h,w=!1,b=!1,m=0)=>{for(let T=m;T<c.length;T++)me(c[T],d,h,w,b)},y=c=>{if(c.shapeFlag&6)return y(c.component.subTree);if(c.shapeFlag&128)return c.suspense.next();const d=p(c.anchor||c.el),h=d&&d[Ws];return h?p(h):d};let I=!1;const S=(c,d,h)=>{c==null?d._vnode&&me(d._vnode,null,null,!0):O(d._vnode||null,c,d,null,null,null,h),d._vnode=c,I||(I=!0,jr(),oo(),I=!1)},N={p:O,um:me,m:Me,r:Sn,mt:Fn,mc:Pe,pc:j,pbc:ke,n:y,o:e};return{render:S,hydrate:void 0,createApp:ua(S)}}function Yt({type:e,props:n},t){return t==="svg"&&e==="foreignObject"||t==="mathml"&&e==="annotation-xml"&&n&&n.encoding&&n.encoding.includes("html")?void 0:t}function wn({effect:e,job:n},t){t?(e.flags|=32,n.flags|=4):(e.flags&=-33,n.flags&=-5)}function La(e,n){return(!e||e&&!e.pendingBranch)&&n&&!n.persisted}function Ao(e,n,t=!1){const r=e.children,i=n.children;if(B(r)&&B(i))for(let o=0;o<r.length;o++){const s=r[o];let a=i[o];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=i[o]=cn(i[o]),a.el=s.el),!t&&a.patchFlag!==-2&&Ao(s,a)),a.type===Mt&&a.patchFlag!==-1&&(a.el=s.el),a.type===_n&&!a.el&&(a.el=s.el)}}function Da(e){const n=e.slice(),t=[0];let r,i,o,s,a;const l=e.length;for(r=0;r<l;r++){const u=e[r];if(u!==0){if(i=t[t.length-1],e[i]<u){n[r]=i,t.push(r);continue}for(o=0,s=t.length-1;o<s;)a=o+s>>1,e[t[a]]<u?o=a+1:s=a;u<e[t[o]]&&(o>0&&(n[r]=t[o-1]),t[o]=r)}}for(o=t.length,s=t[o-1];o-- >0;)t[o]=s,s=n[s];return t}function Io(e){const n=e.subTree.component;if(n)return n.asyncDep&&!n.asyncResolved?n:Io(n)}function Jr(e){if(e)for(let n=0;n<e.length;n++)e[n].flags|=8}const Oo=e=>e.__isSuspense;function Na(e,n){n&&n.pendingBranch?B(e)?n.effects.push(...e):n.effects.push(e):Hs(e)}const ge=Symbol.for("v-fgt"),Mt=Symbol.for("v-txt"),_n=Symbol.for("v-cmt"),Kt=Symbol.for("v-stc"),Qn=[];let Te=null;function te(e=!1){Qn.push(Te=e?null:[])}function Pa(){Qn.pop(),Te=Qn[Qn.length-1]||null}let it=1;function Et(e,n=!1){it+=e,e<0&&Te&&n&&(Te.hasOnce=!0)}function Co(e){return e.dynamicChildren=it>0?Te||Ln:null,Pa(),it>0&&Te&&Te.push(e),e}function ie(e,n,t,r,i,o){return Co(K(e,n,t,r,i,o,!0))}function Lo(e,n,t,r,i){return Co(xe(e,n,t,r,i,!0))}function Tt(e){return e?e.__v_isVNode===!0:!1}function jn(e,n){return e.type===n.type&&e.key===n.key}const Do=({key:e})=>e??null,gt=({ref:e,ref_key:n,ref_for:t})=>(typeof e=="number"&&(e=""+e),e!=null?oe(e)||de(e)||H(e)?{i:Ce,r:e,k:n,f:!!t}:e:null);function K(e,n=null,t=null,r=0,i=null,o=e===ge?0:1,s=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:n,key:n&&Do(n),ref:n&&gt(n),scopeId:ao,slotScopeIds:null,children:t,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:r,dynamicProps:i,dynamicChildren:null,appContext:null,ctx:Ce};return a?(Nr(l,t),o&128&&e.normalize(l)):t&&(l.shapeFlag|=oe(t)?8:16),it>0&&!s&&Te&&(l.patchFlag>0||o&6)&&l.patchFlag!==32&&Te.push(l),l}const xe=ka;function ka(e,n=null,t=null,r=0,i=null,o=!1){if((!e||e===ra)&&(e=_n),Tt(e)){const a=Mn(e,n,!0);return t&&Nr(a,t),it>0&&!o&&Te&&(a.shapeFlag&6?Te[Te.indexOf(e)]=a:Te.push(a)),a.patchFlag=-2,a}if(Ya(e)&&(e=e.__vccOpts),n){n=Ga(n);let{class:a,style:l}=n;a&&!oe(a)&&(n.class=at(a)),ee(l)&&(Rr(l)&&!B(l)&&(l=ue({},l)),n.style=Lt(l))}const s=oe(e)?1:Oo(e)?128:Us(e)?64:ee(e)?4:H(e)?2:0;return K(e,n,t,r,i,s,o,!0)}function Ga(e){return e?Rr(e)||xo(e)?ue({},e):e:null}function Mn(e,n,t=!1,r=!1){const{props:i,ref:o,patchFlag:s,children:a,transition:l}=e,u=n?Ma(i||{},n):i,f={__v_isVNode:!0,__v_skip:!0,type:e.type,props:u,key:u&&Do(u),ref:n&&n.ref?t&&o?B(o)?o.concat(gt(n)):[o,gt(n)]:gt(n):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:a,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:n&&e.type!==ge?s===-1?16:s|16:s,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:l,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Mn(e.ssContent),ssFallback:e.ssFallback&&Mn(e.ssFallback),placeholder:e.placeholder,el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return l&&r&&Ir(f,l.clone(f)),f}function No(e=" ",n=0){return xe(Mt,null,e,n)}function _t(e="",n=!1){return n?(te(),Lo(_n,null,e)):xe(_n,null,e)}function je(e){return e==null||typeof e=="boolean"?xe(_n):B(e)?xe(ge,null,e.slice()):Tt(e)?cn(e):xe(Mt,null,String(e))}function cn(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Mn(e)}function Nr(e,n){let t=0;const{shapeFlag:r}=e;if(n==null)n=null;else if(B(n))t=16;else if(typeof n=="object")if(r&65){const i=n.default;i&&(i._c&&(i._d=!1),Nr(e,i()),i._c&&(i._d=!0));return}else{t=32;const i=n._;!i&&!xo(n)?n._ctx=Ce:i===3&&Ce&&(Ce.slots._===1?n._=1:(n._=2,e.patchFlag|=1024))}else H(n)?(n={default:n,_ctx:Ce},t=32):(n=String(n),r&64?(t=16,n=[No(n)]):t=8);e.children=n,e.shapeFlag|=t}function Ma(...e){const n={};for(let t=0;t<e.length;t++){const r=e[t];for(const i in r)if(i==="class")n.class!==r.class&&(n.class=at([n.class,r.class]));else if(i==="style")n.style=Lt([n.style,r.style]);else if(Rt(i)){const o=n[i],s=r[i];s&&o!==s&&!(B(o)&&o.includes(s))&&(n[i]=o?[].concat(o,s):s)}else i!==""&&(n[i]=r[i])}return n}function We(e,n,t,r=null){ze(e,n,7,[t,r])}const Ba=po();let Ha=0;function Fa(e,n,t){const r=e.type,i=(n?n.appContext:e.appContext)||Ba,o={uid:Ha++,vnode:e,type:r,parent:n,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new cs(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:n?n.provides:Object.create(i.provides),ids:n?n.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Eo(r,i),emitsOptions:wo(r,i),emit:null,emitted:null,propsDefaults:J,inheritAttrs:r.inheritAttrs,ctx:J,data:J,props:J,attrs:J,slots:J,refs:J,setupState:J,setupContext:null,suspense:t,suspenseId:t?t.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=n?n.root:o,o.emit=ma.bind(null,o),e.ce&&e.ce(o),o}let fe=null;const Wa=()=>fe||Ce;let St,fr;{const e=Ct(),n=(t,r)=>{let i;return(i=e[t])||(i=e[t]=[]),i.push(r),o=>{i.length>1?i.forEach(s=>s(o)):i[0](o)}};St=n("__VUE_INSTANCE_SETTERS__",t=>fe=t),fr=n("__VUE_SSR_SETTERS__",t=>ot=t)}const ct=e=>{const n=fe;return St(e),e.scope.on(),()=>{e.scope.off(),St(n)}},ei=()=>{fe&&fe.scope.off(),St(null)};function Po(e){return e.vnode.shapeFlag&4}let ot=!1;function Ua(e,n=!1,t=!1){n&&fr(n);const{props:r,children:i}=e.vnode,o=Po(e);Ea(e,r,o,n),Aa(e,i,t||n);const s=o?ja(e,n):void 0;return n&&fr(!1),s}function ja(e,n){const t=e.type;e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,oa);const{setup:r}=t;if(r){Qe();const i=e.setupContext=r.length>1?za(e):null,o=ct(e),s=lt(r,e,0,[e.props,i]),a=Di(s);if(Je(),o(),(a||e.sp)&&!qn(e)&&co(e),a){if(s.then(ei,ei),n)return s.then(l=>{ni(e,l)}).catch(l=>{Pt(l,e,0)});e.asyncDep=s}else ni(e,s)}else ko(e)}function ni(e,n,t){H(n)?e.type.__ssrInlineRender?e.ssrRender=n:e.render=n:ee(n)&&(e.setupState=no(n)),ko(e)}function ko(e,n,t){const r=e.type;e.render||(e.render=r.render||Ve);{const i=ct(e);Qe();try{sa(e)}finally{Je(),i()}}}const Va={get(e,n){return ce(e,"get",""),e[n]}};function za(e){const n=t=>{e.exposed=t||{}};return{attrs:new Proxy(e.attrs,Va),slots:e.slots,emit:e.emit,expose:n}}function Pr(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(no(Os(e.exposed)),{get(n,t){if(t in n)return n[t];if(t in $n)return $n[t](e)},has(n,t){return t in n||t in $n}})):e.proxy}function Xa(e,n=!0){return H(e)?e.displayName||e.name:e.name||n&&e.__name}function Ya(e){return H(e)&&"__vccOpts"in e}const Re=(e,n)=>Ps(e,n,ot);function Go(e,n,t){try{Et(-1);const r=arguments.length;return r===2?ee(n)&&!B(n)?Tt(n)?xe(e,null,[n]):xe(e,n):xe(e,null,n):(r>3?t=Array.prototype.slice.call(arguments,2):r===3&&Tt(t)&&(t=[t]),xe(e,n,t))}finally{Et(1)}}const Ka="3.5.25";let dr;const ti=typeof window<"u"&&window.trustedTypes;if(ti)try{dr=ti.createPolicy("vue",{createHTML:e=>e})}catch{}const Mo=dr?e=>dr.createHTML(e):e=>e,Za="http://www.w3.org/2000/svg",qa="http://www.w3.org/1998/Math/MathML",Ze=typeof document<"u"?document:null,ri=Ze&&Ze.createElement("template"),$a={insert:(e,n,t)=>{n.insertBefore(e,t||null)},remove:e=>{const n=e.parentNode;n&&n.removeChild(e)},createElement:(e,n,t,r)=>{const i=n==="svg"?Ze.createElementNS(Za,e):n==="mathml"?Ze.createElementNS(qa,e):t?Ze.createElement(e,{is:t}):Ze.createElement(e);return e==="select"&&r&&r.multiple!=null&&i.setAttribute("multiple",r.multiple),i},createText:e=>Ze.createTextNode(e),createComment:e=>Ze.createComment(e),setText:(e,n)=>{e.nodeValue=n},setElementText:(e,n)=>{e.textContent=n},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Ze.querySelector(e),setScopeId(e,n){e.setAttribute(n,"")},insertStaticContent(e,n,t,r,i,o){const s=t?t.previousSibling:n.lastChild;if(i&&(i===o||i.nextSibling))for(;n.insertBefore(i.cloneNode(!0),t),!(i===o||!(i=i.nextSibling)););else{ri.innerHTML=Mo(r==="svg"?`<svg>${e}</svg>`:r==="mathml"?`<math>${e}</math>`:e);const a=ri.content;if(r==="svg"||r==="mathml"){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}n.insertBefore(a,t)}return[s?s.nextSibling:n.firstChild,t?t.previousSibling:n.lastChild]}},Qa=Symbol("_vtc");function Ja(e,n,t){const r=e[Qa];r&&(n=(n?[n,...r]:[...r]).join(" ")),n==null?e.removeAttribute("class"):t?e.setAttribute("class",n):e.className=n}const ii=Symbol("_vod"),el=Symbol("_vsh"),nl=Symbol(""),tl=/(?:^|;)\s*display\s*:/;function rl(e,n,t){const r=e.style,i=oe(t);let o=!1;if(t&&!i){if(n)if(oe(n))for(const s of n.split(";")){const a=s.slice(0,s.indexOf(":")).trim();t[a]==null&&mt(r,a,"")}else for(const s in n)t[s]==null&&mt(r,s,"");for(const s in t)s==="display"&&(o=!0),mt(r,s,t[s])}else if(i){if(n!==t){const s=r[nl];s&&(t+=";"+s),r.cssText=t,o=tl.test(t)}}else n&&e.removeAttribute("style");ii in e&&(e[ii]=o?r.display:"",e[el]&&(r.display="none"))}const oi=/\s*!important$/;function mt(e,n,t){if(B(t))t.forEach(r=>mt(e,n,r));else if(t==null&&(t=""),n.startsWith("--"))e.setProperty(n,t);else{const r=il(e,n);oi.test(t)?e.setProperty(En(r),t.replace(oi,""),"important"):e[r]=t}}const si=["Webkit","Moz","ms"],Zt={};function il(e,n){const t=Zt[n];if(t)return t;let r=Ie(n);if(r!=="filter"&&r in e)return Zt[n]=r;r=Ot(r);for(let i=0;i<si.length;i++){const o=si[i]+r;if(o in e)return Zt[n]=o}return n}const ai="http://www.w3.org/1999/xlink";function li(e,n,t,r,i,o=ls(n)){r&&n.startsWith("xlink:")?t==null?e.removeAttributeNS(ai,n.slice(6,n.length)):e.setAttributeNS(ai,n,t):t==null||o&&!Gi(t)?e.removeAttribute(n):e.setAttribute(n,o?"":hn(t)?String(t):t)}function ci(e,n,t,r,i){if(n==="innerHTML"||n==="textContent"){t!=null&&(e[n]=n==="innerHTML"?Mo(t):t);return}const o=e.tagName;if(n==="value"&&o!=="PROGRESS"&&!o.includes("-")){const a=o==="OPTION"?e.getAttribute("value")||"":e.value,l=t==null?e.type==="checkbox"?"on":"":String(t);(a!==l||!("_value"in e))&&(e.value=l),t==null&&e.removeAttribute(n),e._value=t;return}let s=!1;if(t===""||t==null){const a=typeof e[n];a==="boolean"?t=Gi(t):t==null&&a==="string"?(t="",s=!0):a==="number"&&(t=0,s=!0)}try{e[n]=t}catch{}s&&e.removeAttribute(i||n)}function ol(e,n,t,r){e.addEventListener(n,t,r)}function sl(e,n,t,r){e.removeEventListener(n,t,r)}const fi=Symbol("_vei");function al(e,n,t,r,i=null){const o=e[fi]||(e[fi]={}),s=o[n];if(r&&s)s.value=r;else{const[a,l]=ll(n);if(r){const u=o[n]=dl(r,i);ol(e,a,u,l)}else s&&(sl(e,a,s,l),o[n]=void 0)}}const di=/(?:Once|Passive|Capture)$/;function ll(e){let n;if(di.test(e)){n={};let r;for(;r=e.match(di);)e=e.slice(0,e.length-r[0].length),n[r[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):En(e.slice(2)),n]}let qt=0;const cl=Promise.resolve(),fl=()=>qt||(cl.then(()=>qt=0),qt=Date.now());function dl(e,n){const t=r=>{if(!r._vts)r._vts=Date.now();else if(r._vts<=t.attached)return;ze(ul(r,t.value),n,5,[r])};return t.value=e,t.attached=fl(),t}function ul(e,n){if(B(n)){const t=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{t.call(e),e._stopped=!0},n.map(r=>i=>!i._stopped&&r&&r(i))}else return n}const ui=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,_l=(e,n,t,r,i,o)=>{const s=i==="svg";n==="class"?Ja(e,r,s):n==="style"?rl(e,t,r):Rt(n)?mr(n)||al(e,n,t,r,o):(n[0]==="."?(n=n.slice(1),!0):n[0]==="^"?(n=n.slice(1),!1):hl(e,n,r,s))?(ci(e,n,r),!e.tagName.includes("-")&&(n==="value"||n==="checked"||n==="selected")&&li(e,n,r,s,o,n!=="value")):e._isVueCE&&(/[A-Z]/.test(n)||!oe(r))?ci(e,Ie(n),r,o,n):(n==="true-value"?e._trueValue=r:n==="false-value"&&(e._falseValue=r),li(e,n,r,s))};function hl(e,n,t,r){if(r)return!!(n==="innerHTML"||n==="textContent"||n in e&&ui(n)&&H(t));if(n==="spellcheck"||n==="draggable"||n==="translate"||n==="autocorrect"||n==="sandbox"&&e.tagName==="IFRAME"||n==="form"||n==="list"&&e.tagName==="INPUT"||n==="type"&&e.tagName==="TEXTAREA")return!1;if(n==="width"||n==="height"){const i=e.tagName;if(i==="IMG"||i==="VIDEO"||i==="CANVAS"||i==="SOURCE")return!1}return ui(n)&&oe(t)?!1:n in e}const pl=["ctrl","shift","alt","meta"],gl={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,n)=>pl.some(t=>e[`${t}Key`]&&!n.includes(t))},ml=(e,n)=>{const t=e._withMods||(e._withMods={}),r=n.join(".");return t[r]||(t[r]=((i,...o)=>{for(let s=0;s<n.length;s++){const a=gl[n[s]];if(a&&a(i,n))return}return e(i,...o)}))},wl=ue({patchProp:_l},$a);let _i;function yl(){return _i||(_i=Oa(wl))}const bl=((...e)=>{const n=yl().createApp(...e),{mount:t}=n;return n.mount=r=>{const i=vl(r);if(!i)return;const o=n._component;!H(o)&&!o.render&&!o.template&&(o.template=i.innerHTML),i.nodeType===1&&(i.textContent="");const s=t(i,!1,xl(i));return i instanceof Element&&(i.removeAttribute("v-cloak"),i.setAttribute("data-v-app","")),s},n});function xl(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function vl(e){return oe(e)?document.querySelector(e):e}const On=typeof document<"u";function Bo(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function El(e){return e.__esModule||e[Symbol.toStringTag]==="Module"||e.default&&Bo(e.default)}const V=Object.assign;function $t(e,n){const t={};for(const r in n){const i=n[r];t[r]=Ne(i)?i.map(e):e(i)}return t}const Jn=()=>{},Ne=Array.isArray;function hi(e,n){const t={};for(const r in e)t[r]=r in n?n[r]:e[r];return t}const Ho=/#/g,Tl=/&/g,Sl=/\//g,Rl=/=/g,Al=/\?/g,Fo=/\+/g,Il=/%5B/g,Ol=/%5D/g,Wo=/%5E/g,Cl=/%60/g,Uo=/%7B/g,Ll=/%7C/g,jo=/%7D/g,Dl=/%20/g;function kr(e){return e==null?"":encodeURI(""+e).replace(Ll,"|").replace(Il,"[").replace(Ol,"]")}function Nl(e){return kr(e).replace(Uo,"{").replace(jo,"}").replace(Wo,"^")}function ur(e){return kr(e).replace(Fo,"%2B").replace(Dl,"+").replace(Ho,"%23").replace(Tl,"%26").replace(Cl,"`").replace(Uo,"{").replace(jo,"}").replace(Wo,"^")}function Pl(e){return ur(e).replace(Rl,"%3D")}function kl(e){return kr(e).replace(Ho,"%23").replace(Al,"%3F")}function Gl(e){return kl(e).replace(Sl,"%2F")}function st(e){if(e==null)return null;try{return decodeURIComponent(""+e)}catch{}return""+e}const Ml=/\/$/,Bl=e=>e.replace(Ml,"");function Qt(e,n,t="/"){let r,i={},o="",s="";const a=n.indexOf("#");let l=n.indexOf("?");return l=a>=0&&l>a?-1:l,l>=0&&(r=n.slice(0,l),o=n.slice(l,a>0?a:n.length),i=e(o.slice(1))),a>=0&&(r=r||n.slice(0,a),s=n.slice(a,n.length)),r=Ul(r??n,t),{fullPath:r+o+s,path:r,query:i,hash:st(s)}}function Hl(e,n){const t=n.query?e(n.query):"";return n.path+(t&&"?")+t+(n.hash||"")}function pi(e,n){return!n||!e.toLowerCase().startsWith(n.toLowerCase())?e:e.slice(n.length)||"/"}function Fl(e,n,t){const r=n.matched.length-1,i=t.matched.length-1;return r>-1&&r===i&&Bn(n.matched[r],t.matched[i])&&Vo(n.params,t.params)&&e(n.query)===e(t.query)&&n.hash===t.hash}function Bn(e,n){return(e.aliasOf||e)===(n.aliasOf||n)}function Vo(e,n){if(Object.keys(e).length!==Object.keys(n).length)return!1;for(var t in e)if(!Wl(e[t],n[t]))return!1;return!0}function Wl(e,n){return Ne(e)?gi(e,n):Ne(n)?gi(n,e):e?.valueOf()===n?.valueOf()}function gi(e,n){return Ne(n)?e.length===n.length&&e.every((t,r)=>t===n[r]):e.length===1&&e[0]===n}function Ul(e,n){if(e.startsWith("/"))return e;if(!e)return n;const t=n.split("/"),r=e.split("/"),i=r[r.length-1];(i===".."||i===".")&&r.push("");let o=t.length-1,s,a;for(s=0;s<r.length;s++)if(a=r[s],a!==".")if(a==="..")o>1&&o--;else break;return t.slice(0,o).join("/")+"/"+r.slice(s).join("/")}const sn={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0};let _r=(function(e){return e.pop="pop",e.push="push",e})({}),Jt=(function(e){return e.back="back",e.forward="forward",e.unknown="",e})({});function jl(e){if(!e)if(On){const n=document.querySelector("base");e=n&&n.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),Bl(e)}const Vl=/^[^#]+#/;function zl(e,n){return e.replace(Vl,"#")+n}function Xl(e,n){const t=document.documentElement.getBoundingClientRect(),r=e.getBoundingClientRect();return{behavior:n.behavior,left:r.left-t.left-(n.left||0),top:r.top-t.top-(n.top||0)}}const Bt=()=>({left:window.scrollX,top:window.scrollY});function Yl(e){let n;if("el"in e){const t=e.el,r=typeof t=="string"&&t.startsWith("#"),i=typeof t=="string"?r?document.getElementById(t.slice(1)):document.querySelector(t):t;if(!i)return;n=Xl(i,e)}else n=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(n):window.scrollTo(n.left!=null?n.left:window.scrollX,n.top!=null?n.top:window.scrollY)}function mi(e,n){return(history.state?history.state.position-n:-1)+e}const hr=new Map;function Kl(e,n){hr.set(e,n)}function Zl(e){const n=hr.get(e);return hr.delete(e),n}function ql(e){return typeof e=="string"||e&&typeof e=="object"}function zo(e){return typeof e=="string"||typeof e=="symbol"}let re=(function(e){return e[e.MATCHER_NOT_FOUND=1]="MATCHER_NOT_FOUND",e[e.NAVIGATION_GUARD_REDIRECT=2]="NAVIGATION_GUARD_REDIRECT",e[e.NAVIGATION_ABORTED=4]="NAVIGATION_ABORTED",e[e.NAVIGATION_CANCELLED=8]="NAVIGATION_CANCELLED",e[e.NAVIGATION_DUPLICATED=16]="NAVIGATION_DUPLICATED",e})({});const Xo=Symbol("");re.MATCHER_NOT_FOUND+"",re.NAVIGATION_GUARD_REDIRECT+"",re.NAVIGATION_ABORTED+"",re.NAVIGATION_CANCELLED+"",re.NAVIGATION_DUPLICATED+"";function Hn(e,n){return V(new Error,{type:e,[Xo]:!0},n)}function Ke(e,n){return e instanceof Error&&Xo in e&&(n==null||!!(e.type&n))}const $l=["params","query","hash"];function Ql(e){if(typeof e=="string")return e;if(e.path!=null)return e.path;const n={};for(const t of $l)t in e&&(n[t]=e[t]);return JSON.stringify(n,null,2)}function Jl(e){const n={};if(e===""||e==="?")return n;const t=(e[0]==="?"?e.slice(1):e).split("&");for(let r=0;r<t.length;++r){const i=t[r].replace(Fo," "),o=i.indexOf("="),s=st(o<0?i:i.slice(0,o)),a=o<0?null:st(i.slice(o+1));if(s in n){let l=n[s];Ne(l)||(l=n[s]=[l]),l.push(a)}else n[s]=a}return n}function wi(e){let n="";for(let t in e){const r=e[t];if(t=Pl(t),r==null){r!==void 0&&(n+=(n.length?"&":"")+t);continue}(Ne(r)?r.map(i=>i&&ur(i)):[r&&ur(r)]).forEach(i=>{i!==void 0&&(n+=(n.length?"&":"")+t,i!=null&&(n+="="+i))})}return n}function ec(e){const n={};for(const t in e){const r=e[t];r!==void 0&&(n[t]=Ne(r)?r.map(i=>i==null?null:""+i):r==null?r:""+r)}return n}const nc=Symbol(""),yi=Symbol(""),Gr=Symbol(""),Yo=Symbol(""),pr=Symbol("");function Vn(){let e=[];function n(r){return e.push(r),()=>{const i=e.indexOf(r);i>-1&&e.splice(i,1)}}function t(){e=[]}return{add:n,list:()=>e.slice(),reset:t}}function fn(e,n,t,r,i,o=s=>s()){const s=r&&(r.enterCallbacks[i]=r.enterCallbacks[i]||[]);return()=>new Promise((a,l)=>{const u=p=>{p===!1?l(Hn(re.NAVIGATION_ABORTED,{from:t,to:n})):p instanceof Error?l(p):ql(p)?l(Hn(re.NAVIGATION_GUARD_REDIRECT,{from:n,to:p})):(s&&r.enterCallbacks[i]===s&&typeof p=="function"&&s.push(p),a())},f=o(()=>e.call(r&&r.instances[i],n,t,u));let _=Promise.resolve(f);e.length<3&&(_=_.then(u)),_.catch(p=>l(p))})}function er(e,n,t,r,i=o=>o()){const o=[];for(const s of e)for(const a in s.components){let l=s.components[a];if(!(n!=="beforeRouteEnter"&&!s.instances[a]))if(Bo(l)){const u=(l.__vccOpts||l)[n];u&&o.push(fn(u,t,r,s,a,i))}else{let u=l();o.push(()=>u.then(f=>{if(!f)throw new Error(`Couldn't resolve component "${a}" at "${s.path}"`);const _=El(f)?f.default:f;s.mods[a]=f,s.components[a]=_;const p=(_.__vccOpts||_)[n];return p&&fn(p,t,r,s,a,i)()}))}}return o}function tc(e,n){const t=[],r=[],i=[],o=Math.max(n.matched.length,e.matched.length);for(let s=0;s<o;s++){const a=n.matched[s];a&&(e.matched.find(u=>Bn(u,a))?r.push(a):t.push(a));const l=e.matched[s];l&&(n.matched.find(u=>Bn(u,l))||i.push(l))}return[t,r,i]}let rc=()=>location.protocol+"//"+location.host;function Ko(e,n){const{pathname:t,search:r,hash:i}=n,o=e.indexOf("#");if(o>-1){let s=i.includes(e.slice(o))?e.slice(o).length:1,a=i.slice(s);return a[0]!=="/"&&(a="/"+a),pi(a,"")}return pi(t,e)+r+i}function ic(e,n,t,r){let i=[],o=[],s=null;const a=({state:p})=>{const g=Ko(e,location),A=t.value,O=n.value;let F=0;if(p){if(t.value=g,n.value=p,s&&s===A){s=null;return}F=O?p.position-O.position:0}else r(g);i.forEach(D=>{D(t.value,A,{delta:F,type:_r.pop,direction:F?F>0?Jt.forward:Jt.back:Jt.unknown})})};function l(){s=t.value}function u(p){i.push(p);const g=()=>{const A=i.indexOf(p);A>-1&&i.splice(A,1)};return o.push(g),g}function f(){if(document.visibilityState==="hidden"){const{history:p}=window;if(!p.state)return;p.replaceState(V({},p.state,{scroll:Bt()}),"")}}function _(){for(const p of o)p();o=[],window.removeEventListener("popstate",a),window.removeEventListener("pagehide",f),document.removeEventListener("visibilitychange",f)}return window.addEventListener("popstate",a),window.addEventListener("pagehide",f),document.addEventListener("visibilitychange",f),{pauseListeners:l,listen:u,destroy:_}}function bi(e,n,t,r=!1,i=!1){return{back:e,current:n,forward:t,replaced:r,position:window.history.length,scroll:i?Bt():null}}function oc(e){const{history:n,location:t}=window,r={value:Ko(e,t)},i={value:n.state};i.value||o(r.value,{back:null,current:r.value,forward:null,position:n.length-1,replaced:!0,scroll:null},!0);function o(l,u,f){const _=e.indexOf("#"),p=_>-1?(t.host&&document.querySelector("base")?e:e.slice(_))+l:rc()+e+l;try{n[f?"replaceState":"pushState"](u,"",p),i.value=u}catch(g){console.error(g),t[f?"replace":"assign"](p)}}function s(l,u){o(l,V({},n.state,bi(i.value.back,l,i.value.forward,!0),u,{position:i.value.position}),!0),r.value=l}function a(l,u){const f=V({},i.value,n.state,{forward:l,scroll:Bt()});o(f.current,f,!0),o(l,V({},bi(r.value,l,null),{position:f.position+1},u),!1),r.value=l}return{location:r,state:i,push:a,replace:s}}function sc(e){e=jl(e);const n=oc(e),t=ic(e,n.state,n.location,n.replace);function r(o,s=!0){s||t.pauseListeners(),history.go(o)}const i=V({location:"",base:e,go:r,createHref:zl.bind(null,e)},n,t);return Object.defineProperty(i,"location",{enumerable:!0,get:()=>n.location.value}),Object.defineProperty(i,"state",{enumerable:!0,get:()=>n.state.value}),i}function ac(e){return e=location.host?e||location.pathname+location.search:"",e.includes("#")||(e+="#"),sc(e)}let bn=(function(e){return e[e.Static=0]="Static",e[e.Param=1]="Param",e[e.Group=2]="Group",e})({});var se=(function(e){return e[e.Static=0]="Static",e[e.Param=1]="Param",e[e.ParamRegExp=2]="ParamRegExp",e[e.ParamRegExpEnd=3]="ParamRegExpEnd",e[e.EscapeNext=4]="EscapeNext",e})(se||{});const lc={type:bn.Static,value:""},cc=/[a-zA-Z0-9_]/;function fc(e){if(!e)return[[]];if(e==="/")return[[lc]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function n(g){throw new Error(`ERR (${t})/"${u}": ${g}`)}let t=se.Static,r=t;const i=[];let o;function s(){o&&i.push(o),o=[]}let a=0,l,u="",f="";function _(){u&&(t===se.Static?o.push({type:bn.Static,value:u}):t===se.Param||t===se.ParamRegExp||t===se.ParamRegExpEnd?(o.length>1&&(l==="*"||l==="+")&&n(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`),o.push({type:bn.Param,value:u,regexp:f,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):n("Invalid state to consume buffer"),u="")}function p(){u+=l}for(;a<e.length;){if(l=e[a++],l==="\\"&&t!==se.ParamRegExp){r=t,t=se.EscapeNext;continue}switch(t){case se.Static:l==="/"?(u&&_(),s()):l===":"?(_(),t=se.Param):p();break;case se.EscapeNext:p(),t=r;break;case se.Param:l==="("?t=se.ParamRegExp:cc.test(l)?p():(_(),t=se.Static,l!=="*"&&l!=="?"&&l!=="+"&&a--);break;case se.ParamRegExp:l===")"?f[f.length-1]=="\\"?f=f.slice(0,-1)+l:t=se.ParamRegExpEnd:f+=l;break;case se.ParamRegExpEnd:_(),t=se.Static,l!=="*"&&l!=="?"&&l!=="+"&&a--,f="";break;default:n("Unknown state");break}}return t===se.ParamRegExp&&n(`Unfinished custom RegExp for param "${u}"`),_(),s(),i}const xi="[^/]+?",dc={sensitive:!1,strict:!1,start:!0,end:!0};var he=(function(e){return e[e._multiplier=10]="_multiplier",e[e.Root=90]="Root",e[e.Segment=40]="Segment",e[e.SubSegment=30]="SubSegment",e[e.Static=40]="Static",e[e.Dynamic=20]="Dynamic",e[e.BonusCustomRegExp=10]="BonusCustomRegExp",e[e.BonusWildcard=-50]="BonusWildcard",e[e.BonusRepeatable=-20]="BonusRepeatable",e[e.BonusOptional=-8]="BonusOptional",e[e.BonusStrict=.7000000000000001]="BonusStrict",e[e.BonusCaseSensitive=.25]="BonusCaseSensitive",e})(he||{});const uc=/[.+*?^${}()[\]/\\]/g;function _c(e,n){const t=V({},dc,n),r=[];let i=t.start?"^":"";const o=[];for(const u of e){const f=u.length?[]:[he.Root];t.strict&&!u.length&&(i+="/");for(let _=0;_<u.length;_++){const p=u[_];let g=he.Segment+(t.sensitive?he.BonusCaseSensitive:0);if(p.type===bn.Static)_||(i+="/"),i+=p.value.replace(uc,"\\$&"),g+=he.Static;else if(p.type===bn.Param){const{value:A,repeatable:O,optional:F,regexp:D}=p;o.push({name:A,repeatable:O,optional:F});const C=D||xi;if(C!==xi){g+=he.BonusCustomRegExp;try{`${C}`}catch(L){throw new Error(`Invalid custom RegExp for param "${A}" (${C}): `+L.message)}}let k=O?`((?:${C})(?:/(?:${C}))*)`:`(${C})`;_||(k=F&&u.length<2?`(?:/${k})`:"/"+k),F&&(k+="?"),i+=k,g+=he.Dynamic,F&&(g+=he.BonusOptional),O&&(g+=he.BonusRepeatable),C===".*"&&(g+=he.BonusWildcard)}f.push(g)}r.push(f)}if(t.strict&&t.end){const u=r.length-1;r[u][r[u].length-1]+=he.BonusStrict}t.strict||(i+="/?"),t.end?i+="$":t.strict&&!i.endsWith("/")&&(i+="(?:/|$)");const s=new RegExp(i,t.sensitive?"":"i");function a(u){const f=u.match(s),_={};if(!f)return null;for(let p=1;p<f.length;p++){const g=f[p]||"",A=o[p-1];_[A.name]=g&&A.repeatable?g.split("/"):g}return _}function l(u){let f="",_=!1;for(const p of e){(!_||!f.endsWith("/"))&&(f+="/"),_=!1;for(const g of p)if(g.type===bn.Static)f+=g.value;else if(g.type===bn.Param){const{value:A,repeatable:O,optional:F}=g,D=A in u?u[A]:"";if(Ne(D)&&!O)throw new Error(`Provided param "${A}" is an array but it is not repeatable (* or + modifiers)`);const C=Ne(D)?D.join("/"):D;if(!C)if(F)p.length<2&&(f.endsWith("/")?f=f.slice(0,-1):_=!0);else throw new Error(`Missing required param "${A}"`);f+=C}}return f||"/"}return{re:s,score:r,keys:o,parse:a,stringify:l}}function hc(e,n){let t=0;for(;t<e.length&&t<n.length;){const r=n[t]-e[t];if(r)return r;t++}return e.length<n.length?e.length===1&&e[0]===he.Static+he.Segment?-1:1:e.length>n.length?n.length===1&&n[0]===he.Static+he.Segment?1:-1:0}function Zo(e,n){let t=0;const r=e.score,i=n.score;for(;t<r.length&&t<i.length;){const o=hc(r[t],i[t]);if(o)return o;t++}if(Math.abs(i.length-r.length)===1){if(vi(r))return 1;if(vi(i))return-1}return i.length-r.length}function vi(e){const n=e[e.length-1];return e.length>0&&n[n.length-1]<0}const pc={strict:!1,end:!0,sensitive:!1};function gc(e,n,t){const r=_c(fc(e.path),t),i=V(r,{record:e,parent:n,children:[],alias:[]});return n&&!i.record.aliasOf==!n.record.aliasOf&&n.children.push(i),i}function mc(e,n){const t=[],r=new Map;n=hi(pc,n);function i(_){return r.get(_)}function o(_,p,g){const A=!g,O=Ti(_);O.aliasOf=g&&g.record;const F=hi(n,_),D=[O];if("alias"in _){const L=typeof _.alias=="string"?[_.alias]:_.alias;for(const q of L)D.push(Ti(V({},O,{components:g?g.record.components:O.components,path:q,aliasOf:g?g.record:O})))}let C,k;for(const L of D){const{path:q}=L;if(p&&q[0]!=="/"){const le=p.record.path,ne=le[le.length-1]==="/"?"":"/";L.path=p.record.path+(q&&ne+q)}if(C=gc(L,p,F),g?g.alias.push(C):(k=k||C,k!==C&&k.alias.push(C),A&&_.name&&!Si(C)&&s(_.name)),qo(C)&&l(C),O.children){const le=O.children;for(let ne=0;ne<le.length;ne++)o(le[ne],C,g&&g.children[ne])}g=g||C}return k?()=>{s(k)}:Jn}function s(_){if(zo(_)){const p=r.get(_);p&&(r.delete(_),t.splice(t.indexOf(p),1),p.children.forEach(s),p.alias.forEach(s))}else{const p=t.indexOf(_);p>-1&&(t.splice(p,1),_.record.name&&r.delete(_.record.name),_.children.forEach(s),_.alias.forEach(s))}}function a(){return t}function l(_){const p=bc(_,t);t.splice(p,0,_),_.record.name&&!Si(_)&&r.set(_.record.name,_)}function u(_,p){let g,A={},O,F;if("name"in _&&_.name){if(g=r.get(_.name),!g)throw Hn(re.MATCHER_NOT_FOUND,{location:_});F=g.record.name,A=V(Ei(p.params,g.keys.filter(k=>!k.optional).concat(g.parent?g.parent.keys.filter(k=>k.optional):[]).map(k=>k.name)),_.params&&Ei(_.params,g.keys.map(k=>k.name))),O=g.stringify(A)}else if(_.path!=null)O=_.path,g=t.find(k=>k.re.test(O)),g&&(A=g.parse(O),F=g.record.name);else{if(g=p.name?r.get(p.name):t.find(k=>k.re.test(p.path)),!g)throw Hn(re.MATCHER_NOT_FOUND,{location:_,currentLocation:p});F=g.record.name,A=V({},p.params,_.params),O=g.stringify(A)}const D=[];let C=g;for(;C;)D.unshift(C.record),C=C.parent;return{name:F,path:O,params:A,matched:D,meta:yc(D)}}e.forEach(_=>o(_));function f(){t.length=0,r.clear()}return{addRoute:o,resolve:u,removeRoute:s,clearRoutes:f,getRoutes:a,getRecordMatcher:i}}function Ei(e,n){const t={};for(const r of n)r in e&&(t[r]=e[r]);return t}function Ti(e){const n={path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:e.aliasOf,beforeEnter:e.beforeEnter,props:wc(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}};return Object.defineProperty(n,"mods",{value:{}}),n}function wc(e){const n={},t=e.props||!1;if("component"in e)n.default=t;else for(const r in e.components)n[r]=typeof t=="object"?t[r]:t;return n}function Si(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function yc(e){return e.reduce((n,t)=>V(n,t.meta),{})}function bc(e,n){let t=0,r=n.length;for(;t!==r;){const o=t+r>>1;Zo(e,n[o])<0?r=o:t=o+1}const i=xc(e);return i&&(r=n.lastIndexOf(i,r-1)),r}function xc(e){let n=e;for(;n=n.parent;)if(qo(n)&&Zo(e,n)===0)return n}function qo({record:e}){return!!(e.name||e.components&&Object.keys(e.components).length||e.redirect)}function Ri(e){const n=$e(Gr),t=$e(Yo),r=Re(()=>{const l=Nn(e.to);return n.resolve(l)}),i=Re(()=>{const{matched:l}=r.value,{length:u}=l,f=l[u-1],_=t.matched;if(!f||!_.length)return-1;const p=_.findIndex(Bn.bind(null,f));if(p>-1)return p;const g=Ai(l[u-2]);return u>1&&Ai(f)===g&&_[_.length-1].path!==g?_.findIndex(Bn.bind(null,l[u-2])):p}),o=Re(()=>i.value>-1&&Rc(t.params,r.value.params)),s=Re(()=>i.value>-1&&i.value===t.matched.length-1&&Vo(t.params,r.value.params));function a(l={}){if(Sc(l)){const u=n[Nn(e.replace)?"replace":"push"](Nn(e.to)).catch(Jn);return e.viewTransition&&typeof document<"u"&&"startViewTransition"in document&&document.startViewTransition(()=>u),u}return Promise.resolve()}return{route:r,href:Re(()=>r.value.href),isActive:o,isExactActive:s,navigate:a}}function vc(e){return e.length===1?e[0]:e}const Ec=lo({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"},viewTransition:Boolean},useLink:Ri,setup(e,{slots:n}){const t=Nt(Ri(e)),{options:r}=$e(Gr),i=Re(()=>({[Ii(e.activeClass,r.linkActiveClass,"router-link-active")]:t.isActive,[Ii(e.exactActiveClass,r.linkExactActiveClass,"router-link-exact-active")]:t.isExactActive}));return()=>{const o=n.default&&vc(n.default(t));return e.custom?o:Go("a",{"aria-current":t.isExactActive?e.ariaCurrentValue:null,href:t.href,onClick:t.navigate,class:i.value},o)}}}),Tc=Ec;function Sc(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const n=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(n))return}return e.preventDefault&&e.preventDefault(),!0}}function Rc(e,n){for(const t in n){const r=n[t],i=e[t];if(typeof r=="string"){if(r!==i)return!1}else if(!Ne(i)||i.length!==r.length||r.some((o,s)=>o.valueOf()!==i[s].valueOf()))return!1}return!0}function Ai(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Ii=(e,n,t)=>e??n??t,Ac=lo({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:n,slots:t}){const r=$e(pr),i=Re(()=>e.route||r.value),o=$e(yi,0),s=Re(()=>{let u=Nn(o);const{matched:f}=i.value;let _;for(;(_=f[u])&&!_.components;)u++;return u}),a=Re(()=>i.value.matched[s.value]);ht(yi,Re(()=>s.value+1)),ht(nc,a),ht(pr,i);const l=tt();return pt(()=>[l.value,a.value,e.name],([u,f,_],[p,g,A])=>{f&&(f.instances[_]=u,g&&g!==f&&u&&u===p&&(f.leaveGuards.size||(f.leaveGuards=g.leaveGuards),f.updateGuards.size||(f.updateGuards=g.updateGuards))),u&&f&&(!g||!Bn(f,g)||!p)&&(f.enterCallbacks[_]||[]).forEach(O=>O(u))},{flush:"post"}),()=>{const u=i.value,f=e.name,_=a.value,p=_&&_.components[f];if(!p)return Oi(t.default,{Component:p,route:u});const g=_.props[f],A=g?g===!0?u.params:typeof g=="function"?g(u):g:null,F=Go(p,V({},A,n,{onVnodeUnmounted:D=>{D.component.isUnmounted&&(_.instances[f]=null)},ref:l}));return Oi(t.default,{Component:F,route:u})||F}}});function Oi(e,n){if(!e)return null;const t=e(n);return t.length===1?t[0]:t}const Ic=Ac;function Oc(e){const n=mc(e.routes,e),t=e.parseQuery||Jl,r=e.stringifyQuery||wi,i=e.history,o=Vn(),s=Vn(),a=Vn(),l=Cs(sn);let u=sn;On&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const f=$t.bind(null,y=>""+y),_=$t.bind(null,Gl),p=$t.bind(null,st);function g(y,I){let S,N;return zo(y)?(S=n.getRecordMatcher(y),N=I):N=y,n.addRoute(N,S)}function A(y){const I=n.getRecordMatcher(y);I&&n.removeRoute(I)}function O(){return n.getRoutes().map(y=>y.record)}function F(y){return!!n.getRecordMatcher(y)}function D(y,I){if(I=V({},I||l.value),typeof y=="string"){const h=Qt(t,y,I.path),w=n.resolve({path:h.path},I),b=i.createHref(h.fullPath);return V(h,w,{params:p(w.params),hash:st(h.hash),redirectedFrom:void 0,href:b})}let S;if(y.path!=null)S=V({},y,{path:Qt(t,y.path,I.path).path});else{const h=V({},y.params);for(const w in h)h[w]==null&&delete h[w];S=V({},y,{params:_(h)}),I.params=_(I.params)}const N=n.resolve(S,I),W=y.hash||"";N.params=f(p(N.params));const c=Hl(r,V({},y,{hash:Nl(W),path:N.path})),d=i.createHref(c);return V({fullPath:c,hash:W,query:r===wi?ec(y.query):y.query||{}},N,{redirectedFrom:void 0,href:d})}function C(y){return typeof y=="string"?Qt(t,y,l.value.path):V({},y)}function k(y,I){if(u!==y)return Hn(re.NAVIGATION_CANCELLED,{from:I,to:y})}function L(y){return ne(y)}function q(y){return L(V(C(y),{replace:!0}))}function le(y,I){const S=y.matched[y.matched.length-1];if(S&&S.redirect){const{redirect:N}=S;let W=typeof N=="function"?N(y,I):N;return typeof W=="string"&&(W=W.includes("?")||W.includes("#")?W=C(W):{path:W},W.params={}),V({query:y.query,hash:y.hash,params:W.path!=null?{}:y.params},W)}}function ne(y,I){const S=u=D(y),N=l.value,W=y.state,c=y.force,d=y.replace===!0,h=le(S,N);if(h)return ne(V(C(h),{state:typeof h=="object"?V({},W,h.state):W,force:c,replace:d}),I||S);const w=S;w.redirectedFrom=I;let b;return!c&&Fl(r,N,S)&&(b=Hn(re.NAVIGATION_DUPLICATED,{to:w,from:N}),Me(N,N,!0,!1)),(b?Promise.resolve(b):ke(w,N)).catch(m=>Ke(m)?Ke(m,re.NAVIGATION_GUARD_REDIRECT)?m:on(m):j(m,w,N)).then(m=>{if(m){if(Ke(m,re.NAVIGATION_GUARD_REDIRECT))return ne(V({replace:d},C(m.to),{state:typeof m.to=="object"?V({},W,m.to.state):W,force:c}),I||w)}else m=pn(w,N,!0,d,W);return rn(w,N,m),m})}function Pe(y,I){const S=k(y,I);return S?Promise.reject(S):Promise.resolve()}function tn(y){const I=Rn.values().next().value;return I&&typeof I.runWithContext=="function"?I.runWithContext(y):y()}function ke(y,I){let S;const[N,W,c]=tc(y,I);S=er(N.reverse(),"beforeRouteLeave",y,I);for(const h of N)h.leaveGuards.forEach(w=>{S.push(fn(w,y,I))});const d=Pe.bind(null,y,I);return S.push(d),Se(S).then(()=>{S=[];for(const h of o.list())S.push(fn(h,y,I));return S.push(d),Se(S)}).then(()=>{S=er(W,"beforeRouteUpdate",y,I);for(const h of W)h.updateGuards.forEach(w=>{S.push(fn(w,y,I))});return S.push(d),Se(S)}).then(()=>{S=[];for(const h of c)if(h.beforeEnter)if(Ne(h.beforeEnter))for(const w of h.beforeEnter)S.push(fn(w,y,I));else S.push(fn(h.beforeEnter,y,I));return S.push(d),Se(S)}).then(()=>(y.matched.forEach(h=>h.enterCallbacks={}),S=er(c,"beforeRouteEnter",y,I,tn),S.push(d),Se(S))).then(()=>{S=[];for(const h of s.list())S.push(fn(h,y,I));return S.push(d),Se(S)}).catch(h=>Ke(h,re.NAVIGATION_CANCELLED)?h:Promise.reject(h))}function rn(y,I,S){a.list().forEach(N=>tn(()=>N(y,I,S)))}function pn(y,I,S,N,W){const c=k(y,I);if(c)return c;const d=I===sn,h=On?history.state:{};S&&(N||d?i.replace(y.fullPath,V({scroll:d&&h&&h.scroll},W)):i.push(y.fullPath,W)),l.value=y,Me(y,I,S,d),on()}let Ge;function Fn(){Ge||(Ge=i.listen((y,I,S)=>{if(!gn.listening)return;const N=D(y),W=le(N,gn.currentRoute.value);if(W){ne(V(W,{replace:!0,force:!0}),N).catch(Jn);return}u=N;const c=l.value;On&&Kl(mi(c.fullPath,S.delta),Bt()),ke(N,c).catch(d=>Ke(d,re.NAVIGATION_ABORTED|re.NAVIGATION_CANCELLED)?d:Ke(d,re.NAVIGATION_GUARD_REDIRECT)?(ne(V(C(d.to),{force:!0}),N).then(h=>{Ke(h,re.NAVIGATION_ABORTED|re.NAVIGATION_DUPLICATED)&&!S.delta&&S.type===_r.pop&&i.go(-1,!1)}).catch(Jn),Promise.reject()):(S.delta&&i.go(-S.delta,!1),j(d,N,c))).then(d=>{d=d||pn(N,c,!1),d&&(S.delta&&!Ke(d,re.NAVIGATION_CANCELLED)?i.go(-S.delta,!1):S.type===_r.pop&&Ke(d,re.NAVIGATION_ABORTED|re.NAVIGATION_DUPLICATED)&&i.go(-1,!1)),rn(N,c,d)}).catch(Jn)}))}let Tn=Vn(),ae=Vn(),Z;function j(y,I,S){on(y);const N=ae.list();return N.length?N.forEach(W=>W(y,I,S)):console.error(y),Promise.reject(y)}function Xe(){return Z&&l.value!==sn?Promise.resolve():new Promise((y,I)=>{Tn.add([y,I])})}function on(y){return Z||(Z=!y,Fn(),Tn.list().forEach(([I,S])=>y?S(y):I()),Tn.reset()),y}function Me(y,I,S,N){const{scrollBehavior:W}=e;if(!On||!W)return Promise.resolve();const c=!S&&Zl(mi(y.fullPath,0))||(N||!S)&&history.state&&history.state.scroll||null;return ro().then(()=>W(y,I,c)).then(d=>d&&Yl(d)).catch(d=>j(d,y,I))}const me=y=>i.go(y);let Sn;const Rn=new Set,gn={currentRoute:l,listening:!0,addRoute:g,removeRoute:A,clearRoutes:n.clearRoutes,hasRoute:F,getRoutes:O,resolve:D,options:e,push:L,replace:q,go:me,back:()=>me(-1),forward:()=>me(1),beforeEach:o.add,beforeResolve:s.add,afterEach:a.add,onError:ae.add,isReady:Xe,install(y){y.component("RouterLink",Tc),y.component("RouterView",Ic),y.config.globalProperties.$router=gn,Object.defineProperty(y.config.globalProperties,"$route",{enumerable:!0,get:()=>Nn(l)}),On&&!Sn&&l.value===sn&&(Sn=!0,L(i.location).catch(N=>{}));const I={};for(const N in sn)Object.defineProperty(I,N,{get:()=>l.value[N],enumerable:!0});y.provide(Gr,gn),y.provide(Yo,Ji(I)),y.provide(pr,l);const S=y.unmount;Rn.add(y),y.unmount=function(){Rn.delete(y),Rn.size<1&&(u=sn,Ge&&Ge(),Ge=null,l.value=sn,Sn=!1,Z=!1),S()}}};function Se(y){return y.reduce((I,S)=>I.then(()=>tn(S)),Promise.resolve())}return gn}const Ht=(e,n)=>{const t=e.__vccOpts||e;for(const[r,i]of n)t[r]=i;return t},Cc={};function Lc(e,n){const t=ta("router-view");return te(),Lo(t)}const Dc=Ht(Cc,[["render",Lc]]),Nc={class:"navbar"},Pc={class:"navbar-content"},kc={class:"nav-links"},Gc=["href","onClick"],Mc={__name:"Navbar",props:{sections:{type:Array,required:!0}},setup(e){const n=e,t=tt(""),r=o=>{const s=document.getElementById(o);if(s){const l=s.offsetTop-70;window.scrollTo({top:l,behavior:"smooth"})}},i=()=>{const s=window.scrollY+70+100;for(let a=n.sections.length-1;a>=0;a--){const l=document.getElementById(n.sections[a].id);if(l&&l.offsetTop<=s){t.value=n.sections[a].id;break}}};return Or(()=>{window.addEventListener("scroll",i),i()}),Cr(()=>{window.removeEventListener("scroll",i)}),(o,s)=>(te(),ie("nav",Nc,[K("div",Pc,[s[0]||(s[0]=K("h1",{class:"navbar-title"},"Balloons",-1)),K("ul",kc,[(te(!0),ie(ge,null,Cn(e.sections,a=>(te(),ie("li",{key:a.id},[K("a",{href:`#${a.id}`,onClick:ml(l=>r(a.id),["prevent"]),class:at({active:t.value===a.id})},Oe(a.title),11,Gc)]))),128))])])]))}},Bc=Ht(Mc,[["__scopeId","data-v-79040f32"]]),Hc="Cornell Tower Defence",Fc="Matthew Chen, Rishi Yennu",Wc=JSON.parse(`[{"id":"demo-video","title":"Demo Video","subsections":[{"title":"","content":"<div style=\\"max-width: 800px; margin: 2rem auto;\\"><div style=\\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\\"><iframe style=\\"position: absolute; top: 0; left: 0; width: 100%; height: 100%;\\" src=\\"https://www.youtube.com/embed/jrui2HFuquc\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\\" allowfullscreen></iframe></div></div>"}]},{"id":"intro","title":"Intro","subsections":[{"content":"Experience the thrill of playing a tower defence game through a physical interface made with the RP2350 microcontroller!"},{"title":"Summary","content":"We wanted to explore how tangible interaction can make technology more engaging and inclusive. By combining physical play with digital simulation, it demonstrates how embedded systems can foster creativity and curiosity about engineering and design. The project encourages hands-on experimentation, which can inspire accessible interfaces for individuals who learn best through tactile experiences.\\n\\nThus, we built a replica of <a href='#monkey-gameplay'>Balloons Tower Defence (BTD)</a>. Originally by Ninja Kiwi, this game involves preventing balloons from reaching an end position, and, if enough balloons get through, the player loses. We used the RP2350 for its additional memory to support key technical implementations such as the double buffer and the 256-color VGA. After spending weeks working on this, we were able to deliver a responsive and (more importantly) fun experience for users.","images":[{"id":"monkey-gameplay","src":"monkey-gameplay.jpg","alt":"Monkey gameplay","caption":"Screenshot of Bloons Tower Defence gameplay","width":"60%"},{"id":"game-interface","src":"game-interface.png","alt":"Game interface","caption":"Game interface","width":"50%"},{"id":"physical-input-interface","src":"physical-print.png","alt":"Physical input interface","caption":"Physical input interface","width":"30%"}]}]},{"id":"high-level-design","title":"High Level Design","subsections":[{"title":"Rationale and Sources","content":"We originally had no idea how we could build a physical interface that would be able to keep track of the position of multiple objects accurately at the same time without exceeding the monetary constraint. However, we ran into a BTD map that is shaped like a <a href='#btd-grid-map'>grid</a>. We realized that technically many of the maps in BTD could be laid out on a grid (as they are just paths with corners). Thus, we decided that we can constrain the interface to work with grids. This way we were able to take advantage of cheap sensors like Analog Hall Effect sensors, while creating complex and interesting paths for the user to experience.","images":[{"id":"btd-grid-map","src":"btd-grid-map.png","alt":"BTD grid map","caption":"BTD grid map","width":"100%"},{"id":"btd-grid-like-map","src":"grid-like-map.png","alt":"BTD grid like map","caption":"Doesn't this just look like it can be placed on a grid?","width":"40%"}]},{"title":"Background Math","content":"In order to make the game efficient to run, we needed to use fix15 arithmetic in order to use less cycles on the RP2350. The range for this was more than enough for our purposes as the constraints for values were well within [-32768, 32767]. In addition, we used simple distance formulas like Euclidean distance for actions like monkeys ranges and collision detection. We also used linear algebra for sprite manipulation (like the sprite rotation, which is also in fix15)."},{"title":"Logical Structure","content":"For our game, we have the following states:\\n1. START_SCREEN: Title screen, waiting for the start button.\\n2. BEFORE_FOUND: Shows paths, waits for player to press start.\\n3. ROUND_ACTIVE: Balloons spawning/moving, darts start firing.\\n4. ROUND_ENDED: All balloon cleared, transitions to next level.\\n5. GAME_WON: All 6 levels completed.\\n6. GAME_LOST: Health becomes less than or equal to 0.\\n\\nWe took advantage of the two cores found on the RP2350:\\n\\nCore 0:\\n protothread_animate_monkeys: Renders all game objects (30ms)\\n protothread_balloon_update: Updates balloon positions (30ms)\\n protothread_balloon_spawner: Spawns balloons with 500ms delay\\n protothread_monkey_logic: Targeting logic (100ms)\\n\\nCore 1:\\n protothread_dart_logic: Dart movement/collision (30ms)\\n protothread_read_board: Reads 44 multiplexed capacitive sensors (10ms)\\n protothread_game_logic: Button handling, state transitions (10ms)","images":[{"id":"lifecycle","src":"lifecycle.png","alt":"Game Lifecycle","caption":"Game Lifecycle","width":"50%"}]},{"title":"Hardware/Software Tradeoffs","content":"Hardware Component Decisions and Tradeoffs:<table style=\\"border-collapse: collapse; width: 100%; border: 1px solid #000;\\"><thead><tr><th style=\\"border: 1px solid #000; padding: 8px; text-align: left;\\">Component</th><th style=\\"border: 1px solid #000; padding: 8px; text-align: left;\\">Decision</th><th style=\\"border: 1px solid #000; padding: 8px; text-align: left;\\">Tradeoffs</th></tr></thead><tbody><tr><td style=\\"border: 1px solid #000; padding: 8px;\\">VGA Display</td><td style=\\"border: 1px solid #000; padding: 8px;\\">320x240 resolution at 33 fps, 256 colors</td><td style=\\"border: 1px solid #000; padding: 8px;\\">Lower resolution, but eliminated the need for external display controllers</td></tr><tr><td style=\\"border: 1px solid #000; padding: 8px;\\">Audio PWM</td><td style=\\"border: 1px solid #000; padding: 8px;\\">8-bit audio at 44.1 kHz, implemented via GPIO PWM</td><td style=\\"border: 1px solid #000; padding: 8px;\\">Saved GPIO pins compared to using an SPI DAC, but resulted in limited audio fidelity</td></tr><tr><td style=\\"border: 1px solid #000; padding: 8px;\\">Capacitive Sensors</td><td style=\\"border: 1px solid #000; padding: 8px;\\">16 tiles implemented via a 2x Multiplexer (MUX)</td><td style=\\"border: 1px solid #000; padding: 8px;\\">Multiplexing helped save GPIO pins (using only 6 pins total), but introduced additional latency</td></tr><tr><td style=\\"border: 1px solid #000; padding: 8px;\\">PIO State Machines</td><td style=\\"border: 1px solid #000; padding: 8px;\\">4x PIO state machines used for VGA timing</td><td style=\\"border: 1px solid #000; padding: 8px;\\">Offloaded synchronization signals from the CPU, which enabled dual-core gameplay</td></tr><tr><td style=\\"border: 1px solid #000; padding: 8px;\\">DMA Channels</td><td style=\\"border: 1px solid #000; padding: 8px;\\">4x DMA channels used, with 2 of them specifically for line doubling</td><td style=\\"border: 1px solid #000; padding: 8px;\\">Provided automatic framebuffer transfer and allowed for CPU-free rendering</td></tr></tbody></table>\\n\\nIn order to work better on the microcontroller's limited hardware, we wrote specific software optimizations:\\n1. Selective redrawing: Only clears and redraws specific regions of the screen, rather than redrawing the entire screen.\\n2. Fixed point math: Used fixed-point arithmetic instead of floating-point for performance and resource savings.\\n3. Multi-core and multithreading: Leveraged multiple cores and threads for parallel processing.\\n\\nMemory Constraints:\\n Total RAM: 520 KB\\n VGA Buffers: 76,800 bytes  2 = 153.6 KB\\n Balloons: 28 bytes  60 = 1.68 KB\\n Darts: 16 bytes  50 = 0.8 KB\\n Leftover memory: 363.92 KB"}]},{"id":"program-hardware-design","title":"Program/Hardware Design","subsections":[{"title":"Program Details","content":"<em><u>Path Generation</u></em>\\n\\nThe game centers around a grid, and paths are being generated on top of the grid lines. Before making any paths, we pick a side of the grid, choose an intersection on that side, and mark that position as the starting point. Then, we would go to the opposite side and choose an intersection on that side (at uniform randomness), and mark that at the end point.\\n\\nWe then use the A* algorithm to create the path. We treat each intersection as a node in the algorithm and find a path from the start to the end positions through these intersection points. However, A* algorithm deterministically finds a shortest path between the start and end point. Thus, we included a randomness factor that would cause the algorithm to take an non-optimal path: adding random extra cost between 0.5 and 1.5, but still having a preference for shortest path by 25% offset. These values were not only picked through trial and error, but it fits into fixed-point arithmetic.\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">fix15 random_factor = int2fix15(1) + (fix15)((rand() % 100 - 50) * 327); // ~0.5 to 1.5 range\\ntentative_g = tentative_g + (tentative_g >> 2);\\ntentative_g = multfix15(tentative_g, random_factor);</code></pre>\\n\\nOnce we have a path, we draw lines from each intersection point, and, for the start and end position, we draw a color dot to make it clear where the start and ends are.\\n\\n<em><u>Double Buffer</u></em>\\n\\nThe VGA display system employs a double-buffering strategy to eliminate screen tearing and flickering during animation. The system maintains two complete frame buffers in RAM and uses Direct Memory Access (DMA) to automatically scan out pixel data while the CPU draws to the other buffer. Our resolution output is 320x240 pixels with 8 bit color (256 colors).\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">unsigned char vga_data_array[TXCOUNT]; // Front buffer (76,800 bytes)\\nunsigned char vga_back_buffer[TXCOUNT]; // Back buffer (76,800 bytes)\\nunsigned char *draw_buffer = vga_back_buffer; // Active drawing target</code></pre>\\n\\nFor our double buffer strategy, we use drawing operations like <code>drawPixel</code>, <code>fillRect</code>, <code>draw_sprite</code> to write exclusively to the back buffer. When a complete frame is ready, <code>swapBuffers()</code> copies the new back buffer to the VGA buffer. The front buffer is continuously scanned out by two DMA operating in a ping-pong configuration. So, while the DMA scans out the front buffer, the CPU is freely able to modify the back buffer without causing visual artifacts like flickering.\\n\\nInvolving a double buffer needs us to keep track of 3 frames of position history for each moving object. Take the balloon data structure for example:\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">typedef struct {\\n  int16_t draw_x, draw_y; // Current frame position\\n  int16_t prev_draw_x, prev_draw_y; // 1 frame ago\\n  int16_t prev_prev_draw_x; // 2 frames ago\\n  int16_t prev_prev_draw_y;\\n  // ...\\n} Balloon;</code></pre>\\n\\nTaking into account this example:\\n Frame N: Draw to buffer A (displays buffer B)\\n Frame N+1: Draw to buffer B (display buffer A)  Overwrites frame N-1\\n Frame N+2: Draw to buffer A (display buffer B)  Must clear frame N\\n\\nWhen drawing frame N+2 to buffer A, the sprite at the frame N position is still <a href=#cutouts-problem>visible cutouts</a> (last drawn to buffer A). The code must clear <code>prev_prev_draw_x/y</code> before drawing the new position. So, with the additional maintenance, we modify our drawing code:\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">// STEP 1: Calculate new draw positions\\nfor (balloon in balloons) {\\n  balloon.draw_x = (int16_t)balloon.x - (BALLOON_WIDTH / 2);\\n  balloon.draw_y = (int16_t)balloon.y - (BALLOON_HEIGHT / 2);\\n}\\n// STEP 2: Clear old positions (prev_prev = 2 frames ago)\\nclear_and_restore_balloon_positions();\\n// STEP 3: Shift position history\\nfor (balloon in balloons) {\\n  balloon.prev_prev_draw_x = balloon.prev_draw_x;\\n  balloon.prev_prev_draw_y = balloon.prev_draw_y;\\n  balloon.prev_draw_x = balloon.draw_x;\\n  balloon.prev_draw_y = balloon.draw_y;\\n}\\n// STEP 4: Draw new positions\\ndraw_balloons();\\nswapBuffers();</code></pre>\\n\\n<em><u>Pixel Clearing</u></em>\\n\\nTo work with the 32x32 sprites created, we couldn't just use a rectangular region clearing because it creates <a href=#cutouts-problem>visible cutouts</a> when sprites start overlapping with each other. Thus, we wrote a new function called <code>clear_sprite_shape(...)</code> that specifically clears non-transparent pixels. This approach prevents rectangular holes when sprites overlap with each other.\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">void clear_sprite_shape(...) {\\n  for (each pixel in sprite) {\\n    if (pixel == transparent_color) continue;\\n    // Rebuild background: grass > grid lines > base color\\n    color = BG_COLOR;\\n    if (pixel overlaps grass_sprite) color = grass_pixel;\\n    if (pixel on grid_line) color = WHITE;\\n    drawPixel(px, py, color);\\n  }\\n}</code></pre>\\n\\n<em><u>Sprite Manipulation</u></em>\\n\\nThe sprite system provides efficient rendering of 2D game assets (balloons, monkeys, grass tiles) with support for transparency and real-time rotation. All sprite data is stored in flash memory (marked with <code>PROGMEM</code>) and uses fixed-point arithmetic for rotation calculations. In order to make these sprites, we need to convert a PNG file into the 2D array, which can be done using <a href=\\"https://notisrac.github.io/FileToCArray/\\" target=\\"_blank\\">https://notisrac.github.io/FileToCArray/</a>.\\n\\nSprites are stored as flat 1D arrays of 8-bit color values in row-major order:\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">static const uint8_t monkey_body[] PROGMEM = {\\n  0x00, 0x00, 0x00, ..., // Row 0 (32 pixels)\\n  0x00, 0x00, 0xad, ..., // Row 1\\n  // ... 32 rows total\\n};</code></pre>\\n\\nWe have a function to draw sprites that don't need to be rotated:\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">void draw_sprite(int x, int y, const uint8_t *sprite, int width, int height, uint8_t transparent_color)</code></pre>\\n1. Iterate through each pixel in row-major order\\n2. Skip pixels matching <code>transparent_color</code> (i.e., 0x00 for black backgrounds)\\n3. Bounds-check screen coordinates (0-319, 0-239)\\n4. Call <code>drawPixel()</code> for visible, non-transparent pixels\\n\\nHowever, the more interesting function is the <code>draw_sprite_rotated()</code> which renders sprites with arbitrary rotation angles using inverse inverse transformation and fixed-point arithmetic.\\n\\n<strong>Sine/Cosine Lookup Table:</strong>\\n\\nPre-calculated at startup via <code>sprite_init()</code>\\n360-entry table (1 resolution)\\nFixed-point format (fix15) avoids runtime <code>sinf()</code>/<code>cosf()</code> calls\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">sin_table[i] = float2fix15(sinf(angle_rad));</code></pre>\\n\\n<strong>Bounding Box Calculation:</strong>\\n\\nRotates all 4 sprite corners to find screen-space extents\\nMinimizes pixel iteration (only scans rotated bounding box)\\nExample: 3232 sprite at 45 has ~4545 bounding box (2,025 pixels instead of full screen)\\nInverse Rotation Mapping (sprites.c:140-178):\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">// For each screen pixel (screen_x, screen_y):\\nrel_x = screen_x - center_x\\nrel_y = screen_y - center_y\\n// Apply inverse rotation matrix:\\nsrc_x = rel_x * cos() + rel_y * sin() + sprite_width/2\\nsrc_y = -rel_x * sin() + rel_y * cos() + sprite_height/2\\n// Fetch pixel from source sprite at (src_x, src_y)</code></pre>\\n\\n<strong>Optimization:</strong>\\nRow-Level Caching: The Y-component of the inverse transform is constant across each row, so it's pre-calculated once per scanline:\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">for (int screen_y = start_y; screen_y <= end_y; screen_y++) {\\n  fix15 y_cos = multfix15(rel_y_fixed, sin_angle); // Cache for row\\n  fix15 y_sin = multfix15(rel_y_fixed, cos_angle);\\n  for (int screen_x = start_x; screen_x <= end_x; screen_x++) {\\n    // Re-use y_cos, y_sin for all pixels in this row\\n  }\\n}</code></pre>\\n\\nImpact: Reduces 2 multiplications per pixel to ~1.5 on average (33% speedup)\\n\\n<em><u>Monkey Targeting and Dart Shooting</u></em>\\n\\nIn our tower defense game, the main gameplay functionality involves the monkeys placed on the grid automatically aiming towards the balloons that traverse through their paths and shooting a dart to pop them. The implementation of these two features involved first creating separate structs for the Monkeys and Darts to store their x and y positions, angles, and other information.\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">typedef struct {\\n  fix15 x;\\n  fix15 y;\\n  char type;     // MonkeyType\\n  int16_t angle; // degrees\\n  uint8_t range; // how far away\\n  bool active;\\n  bool detected_target;\\n  uint8_t dart_cooldown;\\n} Monkey;</code></pre>\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">typedef struct {\\n  float x;\\n  float y;\\n  int16_t draw_x; // top-left corner\\n  int16_t draw_y;\\n  int16_t prev_draw_x; // draw position from 1 frame ago\\n  int16_t prev_draw_y;\\n  int16_t prev_prev_draw_x; // draw position from 2 frames ago (for double buffering)\\n  int16_t prev_prev_draw_y;\\n  uint8_t path_index;\\n  uint8_t current_waypoint;\\n  bool active;\\n  bool spawned;\\n  char balloon_type;\\n  uint8_t speed;\\n} Balloon;</code></pre>\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">typedef struct {\\n  fix15 x;\\n  fix15 y;\\n  int16_t angle; // degrees\\n  bool active;\\n  fix15 prev_x;\\n  fix15 prev_y;\\n  fix15 prev_prev_x; // position from 2 frames ago (for double buffering)\\n  fix15 prev_prev_y;\\n} Dart;</code></pre>\\n\\nTo calculate the targeting for a monkey, we first need to find the closest balloon in proximity to the monkey, as we only want a monkey to target the balloon that is closest to it. We do this by just iterating through all the active balloons for a specific monkey and then choosing the one that is currently the closest. After calculating that, we then find the angle that the monkey needs to turn to by taking the tangent between the difference in x and y coordinates for the monkey and the closest balloon. One thing to note is that the 0 angle of the monkey is defined as facing up; therefore, an additional 90-degree rotation is required for the targeting to be completely accurate. We additionally create a separate thread for this monkey logic that specifically just iterates through all the monkeys and finds the closest balloon for each monkey, altering the angles for the monkeys while doing so.\\n\\n<pre style=\\"background: #f5f5f5; padding: 1rem; border-radius: 4px; overflow-x: auto;\\"><code class=\\"language-c\\">void target_closest_balloons(volatile Monkey *m) {\\n  // for the given monkey, finds the closest balloon and set the angle to face that balloon\\n  Balloon *closest = NULL;\\n  fix15 mindist = float2fix15(10000.0f);\\n  for (int i = 0; i < MAX_BALLOONS; i++) {\\n    Balloon *b = &balloons[i];\\n    if (b->active) {\\n      fix15 balloonx = float2fix15(b->x);\\n      fix15 balloony = float2fix15(b->y);\\n      fix15 dist = sqrtfix(multfix15((balloonx - m->x), (balloonx - m->x)) + multfix15((balloony - m->y), (balloony - m->y)));\\n      if (closest == b) {\\n        mindist = dist;\\n      }\\n      if (dist < mindist) {\\n        mindist = dist;\\n        closest = b;\\n      }\\n    }\\n  }\\n  m->detected_target = false;\\n  if (closest != NULL && closest->active && fix2int15(mindist) < m->range) {\\n    m->detected_target = true;\\n    fix15 balloonx = float2fix15(closest->x);\\n    fix15 balloony = float2fix15(closest->y);\\n    fix15 xdiff = balloonx - m->x;\\n    fix15 ydiff = balloony - m->y;\\n    fix15 anglerad = float2fix15(atan2f(fix2float15(ydiff), fix2float15(xdiff))) + float2fix15(PI);\\n    m->angle = (fix2int15(multfix15(anglerad, float2fix15(180.0f / PI))) - 90) % 360;\\n    if (m->angle < 0) {\\n      m->angle += 360;\\n    }\\n  }\\n}</code></pre>\\n\\nAfter targeting the closest balloon, the monkey now needs to be able to throw a dart towards it. Similar to the monkey targeting logic, this dart logic will also be on a separate thread, but running on a lower time because the throw rate is timed based on the delay time of the thread. The way it works is that for a specific monkey, there is a dart cooldown field that needs to count to zero for it to create a new dart to throw, and each monkey has its own cooldown. For the dart-throwing logic itself, this first involved initializing a new Dart object every time the dart thread ran for each of the monkeys on the grid. The way we were able to prevent an overuse of memory was by creating a static for the darts and just assigning the new darts to the array. That way, the memory is automatically managed and freed when a Dart is replaced. After the dart is created and spawned onto the screen, it updates its position by using the monkey's angle and follows in that direction until it either goes offscreen and deactivates or collides with a balloon. Since we did not want the darts to leave a trail behind, we needed a way to clear the path it leaves behind as it travels linearly. We were able to do this for the darts by keeping track of the two previous x and y positions and using those positions to redraw the background in the shape of the dart behind it.","images":[{"id":"cutouts-problem","src":"visible-cutouts.png","alt":"Cutout problem","caption":"Cutout artifacts problem","width":"50%"}]},{"title":"Hardware Details","content":"The hardware of the project involves creating a grid where game pieces can be placed in order to have it correspond with the positions on the VGA output screen. To do this, we needed a way to sense the pieces on a board so that the RP2350 could take the input. Our idea for this was to use Analog Hall Effect sensors, as they were both low in cost and very effective in sensing a magnetic field. Another option we had in mind for the sensors was RFID, as it allows for the unique identification of game pieces. However, it was far too costly for our budget and would consume too much power for the RP2350 to handle. Therefore, our final decision was to use Hall effect sensors along with magnets in each of the pieces in order to sense the different positions on our board.\\n\\nFor the <a href=#3d-renders-board>hardware design</a> of the board/grid, three main requirements were necessary for our use case:\\n1. The <a href=#grid-layout>board</a> needed to support 32 analog hall effect sensors in 16 grid positions, so that each position on the board corresponded to a grid position on the screen. The reason why there are 32 analog hall effect sensors is that we wanted to have 2 sensors for each grid position, so that we can read from both the x and y axes of the board.\\n2. The board needed to have a way to insert game pieces that have magnets for the analog hall effect sensors to read.\\n3. The board also needed a way to hold the breadboard with the RP2350 and wire connections, allowing the hall effect sensors easy access to connect to the breadboard for GND, VCC, and output.\\n\\nTo create the board, we decided to design a 3D model of the board using a CAD software known as Onshape and then 3D print that design using PLA filament. In addition to the board itself, seen in the <a href=#3d-renders-board>3D renders</a>, we also designed a <a href=#3d-render-plate>plate</a> where the board can be placed and easily carried around.\\n\\nThis design accomplishes the three requirements we set out: for requirement 1, it has the slots where the analog Hall Effect sensors can be placed so that they're set up to sense in the magnetic field coming from the different game pieces. Next, for requirement 2, the grid itself in the design of the game board has holes where pieces of size 1\\" x 1\\" can be inserted. For requirement 3, we have the lower plate as well as a place in between the supports of the board where a 6\\" x 6\\" breadboard can be placed.\\n\\nAfter 3D printing the board, next came the most tedious aspect of building the hardware for this project, which was mounting the <a href=#analog-hall-effect-sensor>analog Hall Effect sensors</a> onto the board and wiring their connections on the breadboard to provide <a href=#analog-hall-effect-sensor-schematic>GND, VCC, and to connect the output</a> with the multiplexers so that the RP2350 can read from the sensors.\\n\\nThe process began with individually soldering wires to the end pins of the Hall Effect sensors so that the GND, VCC, and OUT connections are long enough to reach where they need to be connected. This process involved cutting and stripping 32 red, black, and yellow wires, which correspond to VCC, GND, and OUT, respectively, and soldering the wire ends to the 3 pins on each of the 32 Hall Effect sensors.\\n\\nFollowing this, the next step was to mount the Hall effect sensors into the slots in each of the 16 grid positions. The hall effect sensor was mounted through the hole in the board where it's pushed up until it reaches the position in the slot seen in the <a href=#3d-renders-board>3D renders</a>. Moreover, the hall effect is kept in place using double-sided tape on the back and electrical tape to hold the wiring in.\\n\\nAfter that step, we needed to connect the VCC and GND wires to the breadpower in order to supply the power and ground to the hall effect sensor. First, we needed to add a jumper cable between each of the power rails so that they would all have power and ground, allowing for the Hall Effect wire connections to be more spread out throughout the breadboard. In addition, we needed to attach the OUT wire of the Hall Effect sensors to the two <a href=#mux>multiplexers</a>, making sure that the different input ports align correctly with the grid positions. For example, grid position 1 of 16 on the board has Hall Effect sensor x0 and y0, which correspond to the C0 on the x and y multiplexers. The x and y multiplexers are referring to the fact that there are Hall effect sensors placed horizontally for x and vertically for y; this is further shown with labels in the <a href=#grid-layout>grid layout</a>. Moreover, the hall effect is kept in place using double-sided tape on the back and electrical tape to hold the wiring in.\\n\\nAfter that step, we needed to connect the VCC and GND wires to the breadboard in order to supply the power and ground to the Hall effect sensor. First, we needed to add a jumper cable between each of the power rails so that they would all have power and ground, allowing for the Hall Effect wire connections to be more spread out throughout the breadboard. In addition, we needed to attach the OUT wire of the Hall Effect sensors to the two multiplexers, making sure that the different input ports align correctly with the grid positions. For example, grid position 1 of 16 on the board has Hall Effect sensor x0 and y0, which correspond to the C0 on the x and y multiplexors. The x and y multiplexers refer to the fact that there are Hall effect sensors placed horizontally for x and vertically for y; this is further shown with labels in <a href=#grid-layout>grid layout</a>.","images":[{"id":"3d-renders-board","src":"3d-renders-board.png","alt":"3D renders of the board","caption":"3D renders of the board","width":"50%"},{"id":"3d-render-plate","src":"plate.png","alt":"3D render of the plate","caption":"3D render of the plate","width":"50%"},{"id":"analog-hall-effect-sensor","src":"analog-render.png","alt":"Analog Hall Effect sensor","caption":"Analog Hall Effect sensor","width":"30%"},{"id":"analog-hall-effect-sensor-schematic","src":"hall-effect-schematic.png","alt":"Schematic of the analog Hall Effect sensor","caption":"Schematic of the analog Hall Effect sensor","width":"10%"},{"id":"grid-layout","src":"grid-layout.png","alt":"Grid layout","caption":"Grid layout","width":"40%"},{"id":"mux","src":"mux.png","alt":"Multiplexer","caption":"Multiplexer","width":"20%"},{"id":"printed-grid","src":"grid-printed.png","alt":"Final grid input","caption":"Final grid input","width":"30%"}]},{"title":"Design and Code References","content":"1. <a href=\\"https://www.youtube.com/watch?v=-L-WgKMFuhE\\" target=\\"_blank\\">A* Pathfinding Algorithm Tutorial</a> - Used to help implement the A* Algorithm for path generation"},{"title":"Things That Didn't Work","content":"We wrote code to include different kinds of monkeys (i.e. Super Monkeys, Tact Shooters, etc), so that the game has more variety. In our design, we knew this was possible because with our two hall effects, we would be able to have 4 distinct states: North-North, South-South, North-South, South-North. We got it to work, but as we debug other issues, we started to see inconsistencies in different tiles and what kind of monkeys get spawned. We realized that as we moved the wiring for hall effects around, we were shifting the hall effects around and they started to misalign. We tried to fix them to the best of our ability, but that proved challenging, since moving those hall effects around also caused some wires to loosen, and, because our encasing made accessing the breadboard difficult, it just kept causing issues. Thus, we had to drop this feature and provide a consistent demo."},{"title":"AI Use Discussion","content":"AI was used to write Python scripts (i.e. convert the WAV sound effect into C array format). We also used AI to help us write web components for this website report."}]},{"id":"results","title":"Results","subsections":[{"title":"Results of this Design","content":"The 320x240 VGA display resolution proved highly effective for sprite-based gameplay despite being significantly lower than modern standards. Testing with multiple participants confirmed that 32x32 pixel sprites remain clearly distinguishable even when overlapping, with the red, blue, and green balloon types easily identifiable during fast-paced gameplay. The double-buffering implementation successfully eliminated all visible tearing and flicker, maintaining a consistent 33 fps (30 ms per frame) even with 60 active balloons, 16 rotating monkeys, and 50 darts simultaneously on screen. Frame time measurements showed an average of 28.3 ms per frame during peak gameplay. The 8-bit color palette (256 colors) provided sufficient color depth for game assets, with the background color (0x95), grass greens (0x50, 0x99, 0xDD), and balloon colors remaining visually distinct across different VGA monitors tested. The sprite transparency system, which skips pixels matching a designated color (0x00 for balloons, 0xFF for grass), successfully prevented the rectangular \\"cutout\\" artifacts that would otherwise occur when sprites overlap. This pixel-level clearing approach, while computationally more expensive than rectangle-based clearing, added only 4.2 ms per frame and was essential for maintaining visual quality when multiple balloons followed crossing paths.\\n\\nThe rotated sprite rendering system successfully achieved smooth, artifact-free rotation of 32x32 pixel monkey sprites across the full 360 range using optimized fixed-point arithmetic and pre-calculated trigonometric lookup tables. During initialization, the <code>sprite_init()</code> function generates a 360-entry sine table with 1 resolution, storing values in fix15 format (15 fractional bits providing 1/32768 precision). This approach eliminates the need for runtime <code>sinf()</code> and <code>cosf()</code> calls, which would be prohibitively expensive on the RP2040's Cortex-M0+ processor lacking hardware floating-point support.\\n\\nThe PWM-based audio playback system achieved decent-quality sound output using only a single GPIO pin, avoiding the need for external DAC hardware. Operating at a 44.1 kHz sample rate with 8-bit resolution, the system generated a PWM carrier frequency of approximately 586 kHz (150 MHz system clock / 256 levels), well above the 20 kHz upper limit of human hearing. During extended play sessions, limited audio artifacts, clicking, or distortion were observed, even when multiple sound effects overlapped."}]},{"id":"conclusions","title":"Conclusions","subsections":[{"title":"","content":"To close out, our original design wasn't a tower defence game; it was originally a City Builder game. However, we found that the original idea wasn't the most fun and would have used up way too much memory for a game that isn't very fun. After switching to the tower defence concept, we believe we succeeded in providing an experience that truly combines a direct physical interface with interesting gameplay.\\n\\nJust like many engineering projects, we were met with multiple problems. Our physical design was excessive and unnecessarily complicated to work with and debug. With 32 hall effects and 3 wires each, we saw a total of 96 wires (just for hall effects) to keep track of and make sure everything works. In addition, due to the fact that there is limited space in our enclosure, we can't always get direct access to the wiring and sometimes would have to unplug and wiring just to get access to the board and fix hardware issues. The solution to this would likely have been developing a PCB: not only would this reduce the amount of wiring, but we could have also reduced the size of our physical input and made our design more portable.\\n\\nOur design adheres to relevant electrical and communication standards to ensure interoperability and safety:\\n <strong>IEEE 754</strong> standards influence numerical precision in the microcontroller's floating-point calculations for rendering and simulation.\\n <strong>ISO 9001 / IEC 61010</strong> principles of quality and electrical safety guide circuit assembly and component selection.\\n The VGA signal follows the <strong>IBM/ANSI VGA 15-pin</strong> analog standard for horizontal and vertical synchronization timing.\\n The Hall sensors operate under <strong>IEC 60529</strong> low-voltage SELV (Safety Extra-Low Voltage) conditions, compliant with 3.3 V logic levels used in embedded systems.\\n\\nOverall, we learned a lot from this project and used many of the techniques and concepts taught in ECE 4760 in our design, and successfully delivered an interactive and fun experience."}]},{"id":"appendix-permissions","title":"Appendix A: Permissions","subsections":[{"title":"Course Website","content":"This group approves this report for inclusion on the course website."},{"title":"YouTube Channel","content":"The group approves the video inclusion on the course YouTube channel."}]},{"id":"references","title":"References","subsections":[{"title":"Data Sheets","content":"1. <a href=\\"https://www.ti.com/lit/ds/symlink/drv5053-q1.pdf\\" target=\\"_blank\\">Analog Hall Effect Sensor (DRV5053-Q1)</a>\\n2. <a href=\\"https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/1918/BOB-09056_Web.pdf\\" target=\\"_blank\\">16-to-1 Multiplexer (CD74HC4067)</a>"},{"title":"Tools","content":"1. <a href=\\"https://www.aseprite.org/\\" target=\\"_blank\\">Aseprite</a> - Used to create art assets\\n2. <a href=\\"https://notisrac.github.io/FileToCArray/\\" target=\\"_blank\\">File to C Array Converter</a> - Used to convert art assets into arrays\\n3. <a href=\\"https://www.onshape.com/en/\\" target=\\"_blank\\">Onshape</a> - Used to create 3D print enclosure and figures"},{"title":"Sound Effects","content":"1. <a href=\\"https://www.youtube.com/watch?v=q8IQWgGZNkA\\" target=\\"_blank\\">BTD Balloon Pop Sound Effect</a>"}]},{"id":"acknowledgements","title":"Acknowledgements","subsections":[{"title":"","content":"We would like to thank our professor Prof. Hunter Adams and Prof. Bruce Land for their guidance and support throughout the project."},{"title":"Individual Contributions","content":"<strong><u>Rishi</u></strong><br>I worked on the hardware design with CAD, wiring, and building the board, and the implementation of the monkey targeting logic and dart throwing logic.<br><br><strong><u>Matthew</u></strong><br>I worked on creating the path generation, art assets, and graphics rendering. I worked on wiring, soldering, and connecting all the pieces of the board."}]}]`),Uc={projectTitle:Hc,teamMembers:Fc,sections:Wc},jc={class:"app"},Vc={class:"content"},zc={class:"project-header"},Xc={class:"team-members"},Yc=["id"],Kc={key:0},Zc=["innerHTML"],qc={key:1,class:"note"},$c={key:2,class:"images-container"},Qc=["id"],Jc=["src","alt"],ef={key:0},nf={__name:"App",setup(e){const n=tt(Uc),t=Re(()=>n.value.sections.map(r=>({id:r.id,title:r.title})));return Or(()=>{document.addEventListener("click",r=>{const i=r.target;if(i.tagName==="A"&&i.getAttribute("href")?.startsWith("#img-")){r.preventDefault();const o=i.getAttribute("href").substring(1),s=document.getElementById(o);if(s){const l=s.offsetTop-80;window.scrollTo({top:l,behavior:"smooth"})}}})}),(r,i)=>(te(),ie("div",jc,[xe(Bc,{sections:t.value},null,8,["sections"]),K("main",Vc,[K("div",zc,[K("h1",null,Oe(n.value.projectTitle),1),K("p",Xc,Oe(n.value.teamMembers),1)]),(te(!0),ie(ge,null,Cn(n.value.sections,o=>(te(),ie("section",{key:o.id,id:o.id,class:"section"},[K("h2",null,Oe(o.title),1),(te(!0),ie(ge,null,Cn(o.subsections,(s,a)=>(te(),ie("div",{key:a,class:"subsection"},[s.title?(te(),ie("h3",Kc,Oe(s.title),1)):_t("",!0),(te(!0),ie(ge,null,Cn(s.content.split(`

`),(l,u)=>(te(),ie("p",{key:u,innerHTML:l.replace(/\n/g,"<br>")},null,8,Zc))),128)),s.note?(te(),ie("p",qc,[K("em",null,"Note: "+Oe(s.note),1)])):_t("",!0),s.images?(te(),ie("div",$c,[(te(!0),ie(ge,null,Cn(s.images,(l,u)=>(te(),ie("figure",{key:u,id:l.id,class:"image-figure",style:Lt(l.width?`max-width: ${l.width}`:"")},[K("img",{src:l.src,alt:l.alt||l.caption,class:"content-image"},null,8,Jc),l.caption?(te(),ie("figcaption",ef,Oe(l.caption),1)):_t("",!0)],12,Qc))),128))])):_t("",!0)]))),128))],8,Yc))),128)),i[0]||(i[0]=K("footer",{class:"footer"},[K("p",null,[No(" 2025 ECE 4760 Final Project | Cornell University | "),K("a",{href:"#/source-code",class:"source-code-link"},"Source code")])],-1))])]))}},tf=Ht(nf,[["__scopeId","data-v-a6f11c8d"]]),rf=`#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include "pico/stdlib.h"
#include "pico/multicore.h"

#include "vga256_graphics.h"
#include "path_generation.h"
#include "audio_playback.h"
#include "sprites.h"
#include "balloon.h"

// hardware
#include "hardware/adc.h"
#include "hardware/clocks.h"

#include "pt_cornell_rp2040_v1_4.h"

/*
Cell Coordinate Mapping
(row, col) to global index
(0,0) -> 0
(0,1) -> 1
(0,2) -> 2
(0,3) -> 3
(1,0) -> 4
(1,1) -> 5
(1,2) -> 6
(1,3) -> 7
(2,0) -> 8
(2,1) -> 9
(2,2) -> 10
(2,3) -> 11
(3,0) -> 12
(3,1) -> 13
(3,2) -> 14
(3,3) -> 15
*/

typedef signed int fix15;
#define multfix15(a, b) ((fix15)((((signed long long)(a)) * ((signed long long)(b))) >> 15))
#define float2fix15(a) ((fix15)((a) * 32768.0))
#define fix2float15(a) ((float)(a) / 32768.0)
#define int2fix15(a) ((fix15)(a << 15))
#define fix2int15(a) ((int)(a >> 15))
#define sqrtfix(a) (float2fix15(sqrtf(fix2float15(a))))
#define divfix(a, b) (fix15)((((signed long long)(a)) << 15) / (b))

#define PI 3.1415926535f

enum GameState
{
    STATE_START_SCREEN = 0,
    STATE_BEFORE_ROUND = 1,
    STATE_ROUND_ACTIVE = 2,
    STATE_ROUND_ENDED = 3,
    STATE_GAME_LOST = 4,
    STATE_GAME_WON = 5
};

// debug
char game_state_str[32];

// Global variable definitions
short game_state = STATE_START_SCREEN;
uint8_t balloon_speeds[3] = {1, 2, 3}; // speeds for red, blue, green balloons
uint8_t monkey_range[2] = {75, 75};    // ranges for dart monkey, tack shooter
uint8_t difficulty_level = 1;
short player_health = 100;
Path paths[MAX_PATHS];
uint8_t path_count = 0;
Balloon balloons[MAX_BALLOONS];
uint8_t remaining_red_balloons_cnt = 0;
uint8_t remaining_blue_balloons_cnt = 0;
uint8_t remaining_green_balloons_cnt = 0;
uint8_t balloon_count = 0;         // number of balloons that have been spawned in the current round
uint8_t balloons_to_spawn = 0;     // total number of balloons TO spawn in the current round
uint8_t next_balloon_to_spawn = 0; // index of the next balloon to spawn
BalloonEndCallback balloon_end_callback = NULL;
volatile Monkey monkeys[ROWS][COLS];
volatile Dart darts[MAX_DARTS];
volatile uint8_t num_darts = 0;

// stupid grass tile shit
volatile uint8_t grass_state[ROWS][COLS];
GrassPosition grass_positions[MAX_GRASS_TILES];
uint8_t grass_tile_count = 0;
bool round_ended = false; // Track if round end has been called for current round

void draw_map()
{
    fillRect(0, 0, 320, 240, BG_COLOR);

    // place_grass(0, 0);
    // place_grass(40, -15);
    // place_grass(150, -10);

    // place_grass(-10, 200);
    // place_grass(-20, 120);

    // place_grass(250, 30);
    // place_grass(257, 64);
    // place_grass(270, 180);

    place_grass_in_cell(0, 1, 4, 0);
    place_grass_in_cell(0, 3, 7, 7);

    place_grass_in_cell(1, 0, 1, 6);
    place_grass_in_cell(1, 2, 6, 1);

    place_grass_in_cell(2, 1, 2, 8);
    place_grass_in_cell(2, 3, -3, 4);

    place_grass_in_cell(3, 0, 8, 8);
    place_grass_in_cell(3, 2, 0, 0);

    draw_grid_lines();
}

void set_balloon_end_callback(BalloonEndCallback callback)
{
    balloon_end_callback = callback;
}

void init_balloon(uint8_t balloon_idx, uint8_t path_idx)
{
    if (balloon_idx >= MAX_BALLOONS || path_idx >= path_count)
    { // out of bounds
        return;
    }

    Path *path = &paths[path_idx];
    if (!path->active || path->waypoint_count == 0)
    {
        return;
    }

    Balloon *b = &balloons[balloon_idx];
    b->x = path->waypoints[0].x;
    b->y = path->waypoints[0].y;
    // draw position (top-left corner of sprite)
    b->draw_x = (int16_t)b->x - (BALLOON_WIDTH / 2);
    b->draw_y = (int16_t)b->y - (BALLOON_HEIGHT / 2);
    // shift
    b->prev_draw_x = b->draw_x;
    b->prev_draw_y = b->draw_y;
    // shift 2 frames ago
    b->prev_prev_draw_x = b->draw_x;
    b->prev_prev_draw_y = b->draw_y;
    b->path_index = path_idx;
    b->current_waypoint = 1;
    b->active = true;
    b->spawned = true;
}

void reset_game()
{
    game_state = STATE_BEFORE_ROUND;
    player_health = 100;
    difficulty_level = 1;

    balloon_count = 0;
    balloons_to_spawn = 0;
    next_balloon_to_spawn = 0;
    round_ended = false; // Reset round end flag

    for (uint8_t i = 0; i < MAX_BALLOONS; i++)
    { // turn off all other balloons
        balloons[i].active = false;
        balloons[i].spawned = false;
    }

    for (uint8_t i = 0; i < MAX_PATHS; i++)
    {
        paths[i].active = false;
    }
    path_count = 0;

    for (uint8_t row = 0; row < ROWS; row++)
    {
        for (uint8_t col = 0; col < COLS; col++)
        {
            if (monkeys[row][col].active)
            {
                monkeys[row][col].active = false;
            }
        }
    }

    draw_map();
    swapBuffers();
    draw_map();
    swapBuffers();
}

// game states
// show paths where balloons can come from
void on_before_round()
{
    game_state = STATE_BEFORE_ROUND;
    strcpy(game_state_str, "Before");
    // adjust balloon count based on difficulty
    switch (difficulty_level)
    {
    case 1:
        // 10 balloons; only red
        // 1 path
        generate_paths(paths, &path_count, 1);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 10;
        remaining_blue_balloons_cnt = 0;
        remaining_green_balloons_cnt = 0;
        break;
    case 2:
        // 20 balloons; only red
        // 2 paths
        generate_paths(paths, &path_count, 2);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 20;
        remaining_blue_balloons_cnt = 0;
        remaining_green_balloons_cnt = 0;
        break;
    case 3:
        // 30 balloons; red and blue
        // 3 paths
        generate_paths(paths, &path_count, 3);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 15;
        remaining_blue_balloons_cnt = 15;
        remaining_green_balloons_cnt = 0;
        break;
    case 4:
        // 40 balloons; red and blue
        generate_paths(paths, &path_count, 3);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 20;
        remaining_blue_balloons_cnt = 20;
        remaining_green_balloons_cnt = 0;
        break;
    case 5:
        // 50 balloons; red, blue, and green
        generate_paths(paths, &path_count, 3);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 17;
        remaining_blue_balloons_cnt = 17;
        remaining_green_balloons_cnt = 16;
        break;
    case MAX_ROUNDS:
        // 60 balloons; red, blue, and green
        generate_paths(paths, &path_count, 3);
        draw_all_paths(paths, path_count, RED);
        swapBuffers();
        remaining_red_balloons_cnt = 20;
        remaining_blue_balloons_cnt = 20;
        remaining_green_balloons_cnt = 20;
        break;
    }
}

// spawns in the balloons chosen in on_before_round
void on_round_start()
{
    game_state = STATE_ROUND_ACTIVE;
    // TODO: Implement next round logic
    // printf("Starting round with %d red, %d blue, %d green balloons; %d paths\\n", remaining_red_balloons_cnt, remaining_blue_balloons_cnt, remaining_green_balloons_cnt, path_count);
    strcpy(game_state_str, "Start");
    round_ended = false; // Reset round end flag so we can detect the next round end
    spawn_balloons(remaining_red_balloons_cnt, remaining_blue_balloons_cnt, remaining_green_balloons_cnt);
}

bool check_round_end()
{
    if (balloons_to_spawn == 0)
    { // if no balloons to spawn, round has not started --> cannot end
        return false;
    }

    // check if all balloons have been spawned
    if (next_balloon_to_spawn < balloons_to_spawn)
    { // check if all balloons have been spawned
        return false;
    }

    // check if all balloons are inactive (popped or reached the end)
    for (uint8_t i = 0; i < balloon_count; i++)
    {
        if (balloons[i].active)
        {
            return false;
        }
    }

    return true;
}

void on_round_end()
{
    game_state = STATE_ROUND_ENDED;
    // printf("Round ended! All balloons are either popped or reached the end.\\n");
    strcpy(game_state_str, "End");
    round_ended = true;
    difficulty_level++;

    balloon_count = 0;
    balloons_to_spawn = 0;
    next_balloon_to_spawn = 0;

    for (uint8_t i = 0; i < MAX_BALLOONS; i++)
    {
        balloons[i].active = false;
        balloons[i].spawned = false;
    }

    for (uint8_t i = 0; i < MAX_PATHS; i++)
    {
        paths[i].active = false;
    }
    path_count = 0;

    // Check if player has won (completed all rounds)
    if (difficulty_level > MAX_ROUNDS)
    {
        on_win();
        return;
    }

    // clear both display buffers by redrawing the map twice
    draw_map();
    swapBuffers();
    draw_map();
    swapBuffers();

    // Transition to BEFORE_ROUND state so player can press button to start next round
    on_before_round();
    // printf("Round ended, now in STATE_BEFORE_ROUND. Press button to start next round.\\n");
}

void on_win()
{
    game_state = STATE_GAME_WON;
    strcpy(game_state_str, "Won");

    // Deactivate all monkeys
    for (uint8_t row = 0; row < ROWS; row++)
    {
        for (uint8_t col = 0; col < COLS; col++)
        {
            if (monkeys[row][col].active)
            {
                monkeys[row][col].active = false;
            }
        }
    }

    // Deactivate all balloons
    for (uint8_t i = 0; i < MAX_BALLOONS; i++)
    {
        balloons[i].active = false;
        balloons[i].spawned = false;
    }

    // printf("Congratulations! You won by completing all %d levels!\\n", MAX_ROUNDS);
}

void draw_start_screen()
{
    fillRect(0, 0, 320, 240, BLACK);

    setTextSize(2);
    setTextColor2(GREEN, BLACK);

    setCursor(33, 50);
    writeString("CORNELL BALLOON DEFENCE");

    setTextSize(1);
    setTextColor2(YELLOW, BLACK);
    setCursor(100, 140);
    writeString("Press START NEXT ROUND");
    setCursor(125, 155);
    writeString("button to begin");

    setTextSize(1);
    setTextColor2(CYAN, BLACK);
    setCursor(95, 190);
    writeString("Goal: Complete 6 levels!");
}

void draw_win_screen()
{
    fillRect(0, 0, 320, 240, BLACK);

    setTextSize(3);
    setTextColor2(GREEN, BLACK);

    setCursor(100, 50);
    writeString("YOU WON!");

    setTextSize(2);
    setTextColor2(WHITE, BLACK);
    setCursor(75, 100);
    writeString("Congratulations!");

    setTextSize(1);
    setTextColor2(WHITE, BLACK);
    setCursor(95, 140);
    writeString("You completed all 6 levels");
    setCursor(120, 155);
    writeString("and saved the day!");

    setTextSize(1);
    setTextColor2(YELLOW, BLACK);
    setCursor(115, 180);
    writeString("Press RESET button");
    setCursor(130, 195);
    writeString("to play again");
}

void draw_lost_screen()
{
    fillRect(0, 0, 320, 240, BLACK);

    setTextSize(3);
    setTextColor2(RED, BLACK);

    setCursor(90, 60);
    writeString("GAME OVER");

    char level_str[28];
    setTextSize(2);
    setTextColor2(WHITE, BLACK);
    setCursor(75, 100);
    sprintf(level_str, "Level Reached: %d", difficulty_level); // -1 because we increment before losing
    writeString(level_str);

    setTextSize(1);
    setTextColor2(YELLOW, BLACK);
    setCursor(115, 160);
    writeString("Press RESET button");
    setCursor(130, 175);
    writeString("to play again");
}

void on_lose()
{
    if (player_health <= 0)
    {
        game_state = STATE_GAME_LOST;
        strcpy(game_state_str, "Lost");

        for (uint8_t row = 0; row < ROWS; row++)
        {
            for (uint8_t col = 0; col < COLS; col++)
            {
                if (monkeys[row][col].active)
                {
                    monkeys[row][col].active = false;
                }
            }
        }

        for (uint8_t i = 0; i < MAX_BALLOONS; i++)
        {
            balloons[i].active = false;
            balloons[i].spawned = false;
        }

        // printf("Game Over! You reached level %d\\n", difficulty_level - 1);
    }
}

void spawn_balloons(uint8_t red_balloons_cnt, uint8_t blue_balloons_cnt, uint8_t green_balloons_cnt)
{
    uint8_t total_balloons_cnt = red_balloons_cnt + blue_balloons_cnt + green_balloons_cnt;

    if (path_count == 0)
    {
        // printf("Error: No paths generated. Use 'make' command first.\\n");
        return;
    }

    if (total_balloons_cnt > MAX_BALLOONS)
    {
        total_balloons_cnt = MAX_BALLOONS;
    }

    for (uint8_t i = 0; i < MAX_BALLOONS; i++)
    { // turn off all other balloons
        balloons[i].active = false;
        balloons[i].spawned = false;
    }

    balloon_count = total_balloons_cnt;
    balloons_to_spawn = total_balloons_cnt;
    next_balloon_to_spawn = 0;

    uint8_t red_spawned = 0;
    uint8_t blue_spawned = 0;
    uint8_t green_spawned = 0;

    for (uint8_t i = 0; i < total_balloons_cnt; i++)
    {
        // round-robin across paths
        uint8_t path_idx = i % path_count;
        balloons[i].path_index = path_idx;

        // assign balloon type based on available colors
        if (red_spawned < red_balloons_cnt)
        {
            balloons[i].balloon_type = BALLOON_RED;
            red_spawned++;
        }
        else if (blue_spawned < blue_balloons_cnt)
        {
            balloons[i].balloon_type = BALLOON_BLUE;
            blue_spawned++;
        }
        else if (green_spawned < green_balloons_cnt)
        {
            balloons[i].balloon_type = BALLOON_GREEN;
            green_spawned++;
        }

        balloons[i].speed = balloon_speeds[balloons[i].balloon_type];
    }
}

void update_balloons(void)
{
    for (uint8_t i = 0; i < balloon_count; i++)
    {
        Balloon *b = &balloons[i];
        if (!b->active)
            continue;

        Path *path = &paths[b->path_index];
        if (!path->active)
        {
            b->active = false;
            continue;
        }

        if (b->current_waypoint >= path->waypoint_count)
        {
            b->active = false;
            if (balloon_end_callback != NULL)
            {
                balloon_end_callback(i, b->path_index);
            }
            continue;
        }

        Waypoint *target = &path->waypoints[b->current_waypoint];
        float dx = target->x - b->x;
        float dy = target->y - b->y;
        float distance = sqrtf(dx * dx + dy * dy);

        // Note: prev positions are updated in the animation thread for proper
        // double-buffer tracking (need to track what was drawn to each buffer)

        if (distance < b->speed)
        { // prevent overshooting the target
            b->x = target->x;
            b->y = target->y;
            b->current_waypoint++;
        }
        else
        {
            b->x += (dx / distance) * b->speed;
            b->y += (dy / distance) * b->speed;
        }
    }
}

void target_closest_balloons(volatile Monkey *m)
{
    // for the given monkey, finds the closest ballon and set the angle to face that balloon
    Balloon *closest = NULL;
    fix15 mindist = float2fix15(10000.0f);
    for (int i = 0; i < MAX_BALLOONS; i++)
    {
        Balloon *b = &balloons[i];
        if (b->active)
        {
            fix15 balloonx = float2fix15(b->x);
            fix15 balloony = float2fix15(b->y);
            fix15 dist = sqrtfix(multfix15((balloonx - m->x), (balloonx - m->x)) + multfix15((balloony - m->y), (balloony - m->y)));
            if (closest == b)
            {
                mindist = dist;
            }
            if (dist < mindist)
            {
                mindist = dist;
                closest = b;
            }
        }
    }
    m->detected_target = false;
    if (closest != NULL && closest->active && fix2int15(mindist) < m->range)
    {
        m->detected_target = true;
        fix15 balloonx = float2fix15(closest->x);
        fix15 balloony = float2fix15(closest->y);
        fix15 xdiff = balloonx - m->x;
        fix15 ydiff = balloony - m->y;
        fix15 anglerad = float2fix15(atan2f(fix2float15(ydiff), fix2float15(xdiff))) + float2fix15(PI);
        m->angle = (fix2int15(multfix15(anglerad, float2fix15(180.0f / PI))) - 90) % 360;
        if (m->angle < 0)
        {
            m->angle += 360;
        }
    }
}

void clear_and_restore_balloon_positions(void)
{
    // Clear old balloon positions pixel-by-pixel (only non-transparent pixels)
    // This prevents rectangular cutouts when balloons overlap

    // IMPORTANT: with double buffering, we clear the position from 2 frames ago because that's what was drawn to THIS buffer last time.
    for (uint8_t i = 0; i < balloon_count; i++)
    {
        Balloon *b = &balloons[i];
        if (!b->active)
            continue;

        // Select correct sprite based on balloon type
        const uint8_t *sprite;
        switch (b->balloon_type)
        {
        case BALLOON_BLUE:
            sprite = balloon_blue;
            break;
        case BALLOON_GREEN:
            sprite = balloon_green;
            break;
        case BALLOON_RED:
        default:
            sprite = balloon_red;
            break;
        }

        // clear position from 2 frames ago (prev_prev_draw) - this clears from the current buffer which was last drawn to 2 frames ago
        if (b->prev_prev_draw_x != b->draw_x || b->prev_prev_draw_y != b->draw_y)
        {
            clear_sprite_shape(b->prev_prev_draw_x, b->prev_prev_draw_y, sprite, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
        }
    }

    for (uint8_t i = 0; i < balloon_count; i++)
    { // clear all if balloons are not active
        Balloon *b = &balloons[i];
        if (!b->active && (b->prev_draw_x != 0 || b->prev_draw_y != 0 || b->prev_prev_draw_x != 0 || b->prev_prev_draw_y != 0))
        {
            // Select correct sprite based on balloon type
            const uint8_t *sprite;
            switch (b->balloon_type)
            {
            case BALLOON_BLUE:
                sprite = balloon_blue;
                break;
            case BALLOON_GREEN:
                sprite = balloon_green;
                break;
            case BALLOON_RED:
            default:
                sprite = balloon_red;
                break;
            }

            // clear both prev and prev_prev positions
            if (b->prev_draw_x != 0 || b->prev_draw_y != 0)
            {
                clear_sprite_shape(b->prev_draw_x, b->prev_draw_y, sprite, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
            }

            if (b->prev_prev_draw_x != 0 || b->prev_prev_draw_y != 0)
            {
                clear_sprite_shape(b->prev_prev_draw_x, b->prev_prev_draw_y, sprite, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
            }

            b->prev_draw_x = 0;
            b->prev_draw_y = 0;
            b->prev_prev_draw_x = 0;
            b->prev_prev_draw_y = 0;
        }
    }
}

void draw_balloons(void)
{
    for (uint8_t i = 0; i < balloon_count; i++)
    {
        Balloon *b = &balloons[i];
        if (!b->active)
            continue;

        // Select correct sprite based on balloon type
        const uint8_t *sprite;
        switch (b->balloon_type)
        {
        case BALLOON_BLUE:
            sprite = balloon_blue;
            break;
        case BALLOON_GREEN:
            sprite = balloon_green;
            break;
        case BALLOON_RED:
        default:
            sprite = balloon_red;
            break;
        }

        draw_sprite(b->draw_x, b->draw_y, sprite, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
    }
}

void balloon_pop_callback(uint8_t balloon_index, uint8_t path_index)
{
    Balloon *b = &balloons[balloon_index];
    switch (b->balloon_type)
    {
    case BALLOON_RED:
        if (remaining_red_balloons_cnt > 0)
            remaining_red_balloons_cnt--;
        break;
    case BALLOON_BLUE:
        if (remaining_blue_balloons_cnt > 0)
            remaining_blue_balloons_cnt--;
        break;
    case BALLOON_GREEN:
        if (remaining_green_balloons_cnt > 0)
            remaining_green_balloons_cnt--;
        break;
    default:
        break;
    }

    const uint8_t *sprite;
    switch (b->balloon_type)
    {
    case BALLOON_BLUE:
        sprite = balloon_blue;
        break;
    case BALLOON_GREEN:
        sprite = balloon_green;
        break;
    case BALLOON_RED:
    default:
        sprite = balloon_red;
        break;
    }
}

void draw_game_ui(void)
{
    // clear UI area (top right corner)
    // using a rectangle that covers the UI area
    int16_t ui_x = 260;
    int16_t ui_y = 0;
    int16_t ui_width = 115;
    int16_t ui_height = 240;
    fillRect(ui_x, ui_y, ui_width, ui_height, GRAY2);

    // set text properties
    setTextSize(1);
    setTextColor2(WHITE, GRAY2);

    setCursor(ui_x, ui_y);
    writeString("Level:");
    char level_str[4];
    sprintf(level_str, "%d", difficulty_level);
    setCursor(ui_x + 36, ui_y);
    writeString(level_str);

    setCursor(ui_x, ui_y + 10);
    writeString("HP:");
    char health_str[5];
    sprintf(health_str, "%d", player_health);
    setCursor(ui_x + 36, ui_y + 10);
    writeString(health_str);

    // draw game state debug string
    setCursor(ui_x, ui_y + 20);
    writeString(game_state_str);

    // draw remaining balloons with sprites
    int16_t balloon_y = ui_y + 30;
    int16_t sprite_offset_x = ui_x;
    int16_t text_offset_x = ui_x + 36; // position text after sprite

    if (remaining_red_balloons_cnt > 0)
    {
        draw_sprite(sprite_offset_x, balloon_y, balloon_red, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
        setCursor(text_offset_x, balloon_y + 12);
        char red_str[4];
        sprintf(red_str, "%d", remaining_red_balloons_cnt);
        writeString(red_str);
    }

    if (remaining_blue_balloons_cnt > 0)
    {
        draw_sprite(sprite_offset_x, balloon_y + 36, balloon_blue, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
        setCursor(text_offset_x, balloon_y + 48);
        char blue_str[4];
        sprintf(blue_str, "%d", remaining_blue_balloons_cnt);
        writeString(blue_str);
    }

    if (remaining_green_balloons_cnt > 0)
    {
        draw_sprite(sprite_offset_x, balloon_y + 72, balloon_green, BALLOON_WIDTH, BALLOON_HEIGHT, 0x00);
        setCursor(text_offset_x, balloon_y + 84);
        char green_str[4];
        sprintf(green_str, "%d", remaining_green_balloons_cnt);
        writeString(green_str);
    }
}

void on_balloon_pop(uint8_t balloon_index)
{
    // Only decrement balloon count when popped by dart (no health reduction)
    Balloon *b = &balloons[balloon_index];
    switch (b->balloon_type)
    {
    case BALLOON_RED:
        if (remaining_red_balloons_cnt > 0)
            remaining_red_balloons_cnt--;
        break;
    case BALLOON_BLUE:
        if (remaining_blue_balloons_cnt > 0)
            remaining_blue_balloons_cnt--;
        break;
    case BALLOON_GREEN:
        if (remaining_green_balloons_cnt > 0)
            remaining_green_balloons_cnt--;
        break;
    default:
        break;
    }

    // Play pop sound effect
    audio_play_sound_effect();
}

void on_balloon_end(uint8_t balloon_index, uint8_t path_index)
{
    // reduce player health and count when balloon reaches end
    Balloon *b = &balloons[balloon_index];
    switch (b->balloon_type)
    {
    case BALLOON_RED:
        if (remaining_red_balloons_cnt > 0)
            remaining_red_balloons_cnt--;
        if (player_health >= 5)
            player_health -= 5;
        break;
    case BALLOON_BLUE:
        if (remaining_blue_balloons_cnt > 0)
            remaining_blue_balloons_cnt--;
        if (player_health >= 10)
            player_health -= 10;
        break;
    case BALLOON_GREEN:
        if (remaining_green_balloons_cnt > 0)
            remaining_green_balloons_cnt--;
        if (player_health >= 20)
            player_health -= 20;
        break;
    default:
        break;
    }
    // printf("Balloon %d DESPAWNED after completing path %d\\n", balloon_index, path_index);
}

// redraw background elements (paths and grass) in a specific rectangular area
void redraw_background_area(int16_t x, int16_t y, int16_t width, int16_t height)
{
    fillRect(x, y, width, height, BG_COLOR);

    // redraw any paths that intersect this area
    for (uint8_t p = 0; p < path_count; p++)
    {
        Path *path = &paths[p];
        if (!path->active)
            continue;

        for (uint8_t w = 0; w < path->waypoint_count - 1; w++)
        {
            int16_t x1 = path->waypoints[w].x;
            int16_t y1 = path->waypoints[w].y;
            int16_t x2 = path->waypoints[w + 1].x;
            int16_t y2 = path->waypoints[w + 1].y;

            // check if this line segment might intersect the clearing area
            int16_t min_x = (x1 < x2) ? x1 : x2;
            int16_t max_x = (x1 > x2) ? x1 : x2;
            int16_t min_y = (y1 < y2) ? y1 : y2;
            int16_t max_y = (y1 > y2) ? y1 : y2;

            // expand bounds to account for line width (use 3 pixel margin for thick lines)
            if (max_x >= x - 3 && min_x <= x + width + 3 &&
                max_y >= y - 3 && min_y <= y + height + 3)
            {
                drawLine(x1, y1, x2, y2, RED);
            }
        }

        // redraw start indicator if it intersects the clearing area
        if (path->waypoint_count > 0)
        {
            int16_t start_x = path->waypoints[0].x;
            int16_t start_y = path->waypoints[0].y;
            if (start_x + 4 >= x && start_x - 4 <= x + width &&
                start_y + 4 >= y && start_y - 4 <= y + height)
            {
                fillCircle(start_x, start_y, 4, GREEN);
            }
        }

        // redraw end indicator if it intersects the clearing area
        if (path->waypoint_count > 1)
        {
            int16_t end_x = path->waypoints[path->waypoint_count - 1].x;
            int16_t end_y = path->waypoints[path->waypoint_count - 1].y;
            if (end_x + 4 >= x && end_x - 4 <= x + width &&
                end_y + 4 >= y && end_y - 4 <= y + height)
            {
                fillCircle(end_x, end_y, 4, BLUE);
            }
        }
    }

    // redraw any grass that intersects this area
    for (uint8_t i = 0; i < grass_tile_count; i++)
    {
        int16_t grass_x = GRID_START_X + grass_positions[i].x;
        int16_t grass_y = GRID_START_Y + grass_positions[i].y;

        // check if grass intersects clearing area (with 1 pixel tolerance)
        if (grass_x < x + width + 1 && grass_x + GRASS_WIDTH > x - 1 &&
            grass_y < y + height + 1 && grass_y + GRASS_HEIGHT > y - 1)
        {
            draw_sprite(grass_x, grass_y, grass, GRASS_WIDTH, GRASS_HEIGHT, 0xFF);
        }
    }

    // redraw grid lines that intersect this area
    uint16_t grid_width = COLS * CELL_SIZE;
    uint16_t grid_height = ROWS * CELL_SIZE;
    int16_t grid_right = GRID_START_X + grid_width;
    int16_t grid_bottom = GRID_START_Y + grid_height;

    // vertical grid lines
    for (uint8_t i = 0; i <= COLS; i++)
    {
        int16_t line_x = GRID_START_X + (i * CELL_SIZE);
        // check if this vertical line intersects the clear area (with small tolerance)
        if (line_x >= x - 1 && line_x <= x + width + 1)
        {
            int16_t start_y = (y < GRID_START_Y) ? GRID_START_Y : y;
            int16_t end_y = (y + height > grid_bottom) ? grid_bottom : (y + height);
            if (start_y < grid_bottom && end_y > GRID_START_Y)
            {
                drawVLine(line_x, start_y, end_y - start_y, WHITE);
            }
        }
    }

    for (uint8_t i = 0; i <= ROWS; i++)
    {
        int16_t line_y = GRID_START_Y + (i * CELL_SIZE);
        // check if this horizontal line intersects the clear area (with small tolerance)
        if (line_y >= y - 1 && line_y <= y + height + 1)
        {
            int16_t start_x = (x < GRID_START_X) ? GRID_START_X : x;
            int16_t end_x = (x + width > grid_right) ? grid_right : (x + width);
            if (start_x < grid_right && end_x > GRID_START_X)
            {
                drawHLine(start_x, line_y, end_x - start_x, WHITE);
            }
        }
    }
}

// Clear only the non-transparent pixels of a sprite by redrawing background pixel-by-pixel
// This prevents the rectangular cutout issue when balloons overlap
void clear_sprite_shape(int16_t x, int16_t y, const uint8_t *sprite, int16_t width, int16_t height, uint8_t transparent_color)
{
    for (int16_t j = 0; j < height; j++)
    {
        for (int16_t i = 0; i < width; i++)
        {
            uint8_t pixel_color = sprite[j * width + i];

            if (pixel_color == transparent_color)
            {
                continue;
            }

            int16_t px = x + i;
            int16_t py = y + j;

            // clear this specific pixel by redrawing what should be underneath
            // start with background color
            uint8_t final_color = BG_COLOR;

            // check if any grass sprite contains this pixel
            for (uint8_t g = 0; g < grass_tile_count; g++)
            {
                int16_t grass_x = GRID_START_X + grass_positions[g].x;
                int16_t grass_y = GRID_START_Y + grass_positions[g].y;

                if (px >= grass_x && px < grass_x + GRASS_WIDTH &&
                    py >= grass_y && py < grass_y + GRASS_HEIGHT)
                {
                    // this pixel is part of a grass sprite
                    int16_t grass_sprite_x = px - grass_x;
                    int16_t grass_sprite_y = py - grass_y;
                    uint8_t grass_pixel = grass[grass_sprite_y * GRASS_WIDTH + grass_sprite_x];
                    if (grass_pixel != 0xFF)
                    {
                        final_color = grass_pixel;
                    }
                }
            }

            // check if on a grid line
            int16_t grid_right = GRID_START_X + (COLS * CELL_SIZE);
            int16_t grid_bottom = GRID_START_Y + (ROWS * CELL_SIZE);

            // check vertical grid lines
            for (uint8_t col = 0; col <= COLS; col++)
            {
                int16_t line_x = GRID_START_X + (col * CELL_SIZE);
                if (px == line_x && py >= GRID_START_Y && py <= grid_bottom)
                {
                    final_color = WHITE;
                }
            }

            // check horizontal grid lines
            for (uint8_t row = 0; row <= ROWS; row++)
            {
                int16_t line_y = GRID_START_Y + (row * CELL_SIZE);
                if (py == line_y && px >= GRID_START_X && px <= grid_right)
                {
                    final_color = WHITE;
                }
            }

            // no redraw path because animation loop will redraw paths every frame

            drawPixel(px, py, final_color);
        }
    }
}

// channel: 0-15
static void mux_select(uint8_t channel)
{
    gpio_put(MUX_S0, channel & 0x1);
    gpio_put(MUX_S1, (channel >> 1) & 0x1);
    gpio_put(MUX_S2, (channel >> 2) & 0x1);
    gpio_put(MUX_S3, (channel >> 3) & 0x1);
}

static uint16_t read_adc(uint8_t adc_input)
{
    adc_select_input(adc_input);
    sleep_us(5);
    return adc_read();
}

void read_tile(uint8_t row, uint8_t col, uint16_t *sensorA_raw, uint16_t *sensorB_raw)
{
    // check for outer bounds
    if (row >= ROWS || col >= COLS)
    {
        *sensorA_raw = 0;
        *sensorB_raw = 0;
        return;
    }

    uint8_t tile_index = row * COLS + col;
    mux_select(tile_index);
    // mux_select(0); // just read channel 0 for testing

    sleep_us(20);

    *sensorA_raw = read_adc(0);
    *sensorB_raw = read_adc(1);
};

static PT_THREAD(protothread_read_board(struct pt *pt))
{
    PT_BEGIN(pt);

    PT_YIELD_usec(1000000); // 0.1s delay

    while (true)
    {
        // Don't allow adding monkeys if game is in special states
        if (game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON && game_state != STATE_START_SCREEN)
        {
            for (uint8_t r = 0; r < ROWS; r++)
            {
                for (uint8_t c = 0; c < COLS; c++)
                {
                    uint16_t a_raw, b_raw;
                    read_tile(r, c, &a_raw, &b_raw);

                    float a_v = a_raw * 3.3f / 4096.0f;
                    float b_v = b_raw * 3.3f / 4096.0f;

                    // less than 700-600 detects
                    // this is check to see if a tile is on
                    if (a_raw < 500 || b_raw < 500 || a_raw > 1800 || b_raw > 1800)
                    {
                        // printf("Tile (%d,%d): A raw=%d (%.2fV), B raw=%d (%.2fV) DETECT\\n", r, c, a_raw, a_v, b_raw, b_v);

                        if (!monkeys[r][c].active)
                        { // monkey exists
                            add_monkey(r, c);
                        }
                    }
                    else
                    {
                        if (monkeys[r][c].active)
                        { // monkey exists
                            delete_monkey(r, c);
                        }
                    }
                    // more than
                    // if (r == 1 && c == 0)
                    // {
                    //     printf("Tile (1,0): A raw=%d, B raw=%d\\n", a_raw, b_raw);
                    // }
                }
            }
        }
        PT_YIELD_usec(10000); // 10ms yield
    }

    PT_END(pt);
}

void draw_grid_lines(void)
{
    uint16_t grid_width = COLS * CELL_SIZE;
    uint16_t grid_height = ROWS * CELL_SIZE;

    for (uint8_t i = 0; i <= COLS; i++)
    { // vertical
        uint16_t x = GRID_START_X + (i * CELL_SIZE);
        drawVLine(x, GRID_START_Y, grid_height, WHITE);
    }

    for (uint8_t i = 0; i <= ROWS; i++)
    { // horizontal
        uint16_t y = GRID_START_Y + (i * CELL_SIZE);
        drawHLine(GRID_START_X, y, grid_width, WHITE);
    }
}

void place_grass(int16_t x, int16_t y)
{
    draw_sprite(x, y, grass, GRASS_WIDTH, GRASS_HEIGHT, 0xFF);

    int16_t grass_left = x;
    int16_t grass_right = x + GRASS_WIDTH;
    int16_t grass_top = y;
    int16_t grass_bottom = y + GRASS_HEIGHT;

    int16_t grid_left = GRID_START_X;
    int16_t grid_right = GRID_START_X + (COLS * CELL_SIZE);
    int16_t grid_top = GRID_START_Y;
    int16_t grid_bottom = GRID_START_Y + (ROWS * CELL_SIZE);

    bool overlaps_grid = (grass_left < grid_right && grass_right > grid_left &&
                          grass_top < grid_bottom && grass_bottom > grid_top);

    if (overlaps_grid && grass_tile_count < MAX_GRASS_TILES)
    {
        grass_positions[grass_tile_count].x = (uint8_t)(x - GRID_START_X);
        grass_positions[grass_tile_count].y = (uint8_t)(y - GRID_START_Y);
        grass_tile_count++;
    }

    for (uint8_t row = 0; row < ROWS; row++)
    {
        for (uint8_t col = 0; col < COLS; col++)
        {
            int16_t cell_left = GRID_START_X + (col * CELL_SIZE);
            int16_t cell_right = cell_left + CELL_SIZE;
            int16_t cell_top = GRID_START_Y + (row * CELL_SIZE);
            int16_t cell_bottom = cell_top + CELL_SIZE;

            if (grass_left < cell_right && grass_right > cell_left &&
                grass_top < cell_bottom && grass_bottom > cell_top)
            {
                grass_state[row][col] = 1;
            }
        }
    }
}

void place_grass_in_cell(uint8_t row, uint8_t col, uint8_t offset_x, uint8_t offset_y)
{
    if (row >= ROWS || col >= COLS)
        return;

    int16_t x = GRID_START_X + (col * CELL_SIZE) + (CELL_SIZE - GRASS_WIDTH) / 2;
    int16_t y = GRID_START_Y + (row * CELL_SIZE) + (CELL_SIZE - GRASS_HEIGHT) / 2;

    place_grass(x + offset_x, y + offset_y);
}

// draws the white grid line for where the monkeys can go
void redraw_cell_grid_lines(short row, short col)
{
    if (row >= ROWS || col >= COLS)
        return;

    uint16_t grid_width = COLS * CELL_SIZE;
    uint16_t grid_height = ROWS * CELL_SIZE;

    uint16_t left_x = GRID_START_X + (col * CELL_SIZE);
    drawVLine(left_x, GRID_START_Y, grid_height, WHITE);

    if (col == COLS - 1)
    {
        uint16_t right_x = GRID_START_X + ((col + 1) * CELL_SIZE);
        drawVLine(right_x, GRID_START_Y, grid_height, WHITE);
    }

    uint16_t top_y = GRID_START_Y + (row * CELL_SIZE);
    drawHLine(GRID_START_X, top_y, grid_width, WHITE);

    if (row == ROWS - 1)
    {
        uint16_t bottom_y = GRID_START_Y + ((row + 1) * CELL_SIZE);
        drawHLine(GRID_START_X, bottom_y, grid_width, WHITE);
    }
}

void redraw_grass_in_cell(short row, short col)
{
    if (row >= ROWS || col >= COLS)
        return;

    if (!grass_state[row][col])
        return;

    int16_t cell_left = GRID_START_X + (col * CELL_SIZE);
    int16_t cell_right = cell_left + CELL_SIZE;
    int16_t cell_top = GRID_START_Y + (row * CELL_SIZE);
    int16_t cell_bottom = cell_top + CELL_SIZE;

    for (uint8_t i = 0; i < grass_tile_count; i++)
    {
        // Convert from relative (stored) to absolute position
        int16_t grass_x = GRID_START_X + grass_positions[i].x;
        int16_t grass_y = GRID_START_Y + grass_positions[i].y;

        int16_t grass_left = grass_x;
        int16_t grass_right = grass_x + GRASS_WIDTH;
        int16_t grass_top = grass_y;
        int16_t grass_bottom = grass_y + GRASS_HEIGHT;

        if (grass_left < cell_right && grass_right > cell_left &&
            grass_top < cell_bottom && grass_bottom > cell_top)
        {
            draw_sprite(grass_x, grass_y, grass, GRASS_WIDTH, GRASS_HEIGHT, 0xFF);
        }
    }

    // Redraw grid lines on top of grass
    redraw_cell_grid_lines(row, col);
}

void clear_cell(short row, short col)
{
    if (row >= ROWS || col >= COLS)
        return;

    uint16_t x = GRID_START_X + (col * CELL_SIZE) + 1;
    uint16_t y = GRID_START_Y + (row * CELL_SIZE) + 1;

    fillRect(x, y, CELL_SIZE - 2, CELL_SIZE - 2, BG_COLOR);

    redraw_grass_in_cell(row, col);
}

void add_monkey(short row, short col)
{
    if (row >= ROWS || col >= COLS)
        return;

    clear_cell(row, col);

    Monkey m = (Monkey){
        .x = int2fix15(GRID_START_X + (col * CELL_SIZE) + (CELL_SIZE / 2)),
        .y = int2fix15(GRID_START_Y + (row * CELL_SIZE) + (CELL_SIZE / 2)),
        .type = DART_MONKEY,
        .angle = 0,
        .range = monkey_range[DART_MONKEY],
    };
    monkeys[row][col] = m;
    monkeys[row][col].active = true;

    // center it
    uint16_t cx = GRID_START_X + (col * CELL_SIZE) + (CELL_SIZE / 2);
    uint16_t cy = GRID_START_Y + (row * CELL_SIZE) + (CELL_SIZE / 2);

    draw_sprite_rotated(fix2int15(monkeys[row][col].x), fix2int15(monkeys[row][col].y), monkey_body, MONKEY_WIDTH, MONKEY_HEIGHT,
                        monkeys[row][col].angle, 0x00);

    draw_sprite_rotated(cx, cy, monkey_body, MONKEY_WIDTH, MONKEY_HEIGHT, monkeys[row][col].angle, 0x00);
    redraw_cell_grid_lines(row, col);

    swapBuffers();
}

void delete_monkey(short row, short col)
{
    if (row < 0 || row >= ROWS || col < 0 || col >= COLS)
        return;
    monkeys[row][col].active = false;
    clear_cell(row, col);
}

void throw_dart(volatile Monkey *m)
{
    if (num_darts >= MAX_DARTS || !m->detected_target)
        return;

    // Calculate starting position at monkey's tip (in direction it's facing)
    float angle_rad = (float)m->angle * (PI / 180.0f);
    fix15 start_x = m->x + float2fix15((MONKEY_WIDTH / 4) * cosf(angle_rad));
    fix15 start_y = m->y + float2fix15((MONKEY_HEIGHT / 4) * sinf(angle_rad));

    Dart d = {
        .active = true,
        .x = start_x,
        .y = start_y,
        .prev_x = start_x,
        .prev_y = start_y,
        .prev_prev_x = start_x,
        .prev_prev_y = start_y,
        .angle = m->angle + 90,
    };

    for (int i = 0; i < MAX_DARTS; i++)
    {
        if (!darts[i].active)
        {
            darts[i] = d;
            num_darts++;

            break;
        }
    }
}

// Clear old dart positions (for double buffering)
// Similar to clear_and_restore_balloon_positions, but for darts
void clear_and_restore_dart_positions(void)
{
    for (int i = 0; i < MAX_DARTS; i++)
    {
        if (!darts[i].active)
            continue;

        // Get position from 2 frames ago (prev_prev) - this is what was drawn to THIS buffer 2 frames ago
        int16_t prev_prev_x = fix2int15(darts[i].prev_prev_x);
        int16_t prev_prev_y = fix2int15(darts[i].prev_prev_y);
        int16_t current_x = fix2int15(darts[i].x);
        int16_t current_y = fix2int15(darts[i].y);

        // Clear position from 2 frames ago if it's different from current position
        if (prev_prev_x != current_x || prev_prev_y != current_y)
        {
            int16_t clear_size = DART_RADIUS * 2 + 2;
            redraw_background_area(prev_prev_x - clear_size / 2, prev_prev_y - clear_size / 2,
                                   clear_size, clear_size);
        }
    }

    // Clear positions for inactive darts
    for (int i = 0; i < MAX_DARTS; i++)
    {
        if (!darts[i].active && (darts[i].prev_x != 0 || darts[i].prev_y != 0 ||
                                 darts[i].prev_prev_x != 0 || darts[i].prev_prev_y != 0))
        {
            // Clear both prev and prev_prev positions
            if (darts[i].prev_x != 0 || darts[i].prev_y != 0)
            {
                int16_t prev_x = fix2int15(darts[i].prev_x);
                int16_t prev_y = fix2int15(darts[i].prev_y);
                int16_t clear_size = DART_RADIUS * 2 + 2;
                redraw_background_area(prev_x - clear_size / 2, prev_y - clear_size / 2,
                                       clear_size, clear_size);
            }

            if (darts[i].prev_prev_x != 0 || darts[i].prev_prev_y != 0)
            {
                int16_t prev_prev_x = fix2int15(darts[i].prev_prev_x);
                int16_t prev_prev_y = fix2int15(darts[i].prev_prev_y);
                int16_t clear_size = DART_RADIUS * 2 + 2;
                redraw_background_area(prev_prev_x - clear_size / 2, prev_prev_y - clear_size / 2,
                                       clear_size, clear_size);
            }

            darts[i].prev_x = 0;
            darts[i].prev_y = 0;
            darts[i].prev_prev_x = 0;
            darts[i].prev_prev_y = 0;
        }
    }
}

// Draw all active darts
void draw_darts(void)
{
    for (int i = 0; i < MAX_DARTS; i++)
    {
        if (!darts[i].active)
            continue;

        int16_t dart_x = fix2int15(darts[i].x);
        int16_t dart_y = fix2int15(darts[i].y);
        fillCircle(dart_x, dart_y, DART_RADIUS, DART_COLOR);
    }
}

void update_darts(void)
{
    for (int i = 0; i < MAX_DARTS; i++)
    {
        if (!darts[i].active)
            continue;

        float dart_x_float = fix2float15(darts[i].x);
        float dart_y_float = fix2float15(darts[i].y);
        float collision_radius_sum = (float)(BALLOON_RADIUS + DART_RADIUS);
        float collision_radius_sum_squared = collision_radius_sum * collision_radius_sum;

        bool collision_detected = false;
        for (uint8_t j = 0; j < balloon_count; j++)
        {
            Balloon *b = &balloons[j];
            if (!b->active)
                continue;

            float dx = dart_x_float - b->x;
            float dy = dart_y_float - b->y;
            float distance_squared = dx * dx + dy * dy;

            if (distance_squared < collision_radius_sum_squared)
            {
                b->active = false;
                darts[i].active = false;
                num_darts--;
                collision_detected = true;

                // Pop the balloon (decrement count, no health reduction)
                on_balloon_pop(j);

                break;
            }
        }

        // move dart forward for next frame (only if no collision and still active)
        if (!collision_detected && darts[i].active)
        {
            float angle_rad = (float)(darts[i].angle) * (PI / 180.0f);
            darts[i].x -= multfix15(DART_SPEED_FIX15, float2fix15(cosf(angle_rad)));
            darts[i].y -= multfix15(DART_SPEED_FIX15, float2fix15(sinf(angle_rad)));

            int16_t next_x = fix2int15(darts[i].x);
            int16_t next_y = fix2int15(darts[i].y);

            // check if dart will be out of bounds next frame
            if (next_x < 0 || next_x >= 320 || next_y < 0 || next_y >= 240)
            {
                darts[i].active = false;
                num_darts--;
            }
        }
    }
}
// redraw all grid content (if clearing the screen)
void redraw_grid_content(void)
{
    for (uint8_t row = 0; row < ROWS; row++)
    {
        for (uint8_t col = 0; col < COLS; col++)
        {
            if (grass_state[row][col])
            {
                redraw_grass_in_cell(row, col);
            }

            if (monkeys[row][col].active)
            {
                uint16_t cx = GRID_START_X + (col * CELL_SIZE) + (CELL_SIZE / 2);
                uint16_t cy = GRID_START_Y + (row * CELL_SIZE) + (CELL_SIZE / 2);
                draw_sprite_rotated(cx, cy, monkey_body, MONKEY_WIDTH, MONKEY_HEIGHT,
                                    monkeys[row][col].angle, 0x00);
                draw_sprite_rotated(cx, cy, monkey_body, MONKEY_WIDTH, MONKEY_HEIGHT, monkeys[row][col].angle, 0x00);
                redraw_cell_grid_lines(row, col);
            }
        }
    }
}

static PT_THREAD(protothread_serial_handler(struct pt *pt))
{
    PT_BEGIN(pt);

    static char input_buffer[32];
    static uint8_t buffer_index = 0;

    printf("\\n=== Balloon Game Controller ===\\n");
    printf("Commands:\\n");
    printf("  add <row> <col>           - Add monkey to cell\\n");
    printf("  clear <row> <col>         - Clear cell\\n");
    printf("  make <num_paths>          - Generate random balloon paths\\n");
    printf("  start <red> <blue> <green> - Spawn balloons along paths\\n");
    printf("Example: make 3\\n");
    printf("Example: start 10 5 3\\n\\n");

    while (true)
    {
        int c = getchar_timeout_us(0);

        if (c != PICO_ERROR_TIMEOUT)
        {
            if (c == '\\n' || c == '\\r')
            {
                if (buffer_index > 0)
                {
                    input_buffer[buffer_index] = '\\0';

                    char cmd[16];
                    int arg1, arg2, arg3;
                    int scan_result = sscanf(input_buffer, "%s %d %d %d", cmd, &arg1, &arg2, &arg3);

                    if (scan_result == 3)
                    {
                        // Two-argument commands
                        if (arg1 >= 0 && arg1 < ROWS && arg2 >= 0 && arg2 < COLS)
                        {
                            if (strcmp(cmd, "add") == 0)
                            {
                                add_monkey(arg1, arg2);
                                printf("Added monkey to cell (%d, %d)\\n", arg1, arg2);
                            }
                            else if (strcmp(cmd, "clear") == 0)
                            {
                                clear_cell(arg1, arg2);
                                swapBuffers();
                                printf("Cleared cell (%d, %d)\\n", arg1, arg2);
                            }
                            else
                            {
                                printf("Unknown command: %s\\n", cmd);
                            }
                        }
                        else
                        {
                            printf("Invalid cell coordinates! Row: 0-%d, Col: 0-%d\\n", ROWS - 1, COLS - 1);
                        }
                    }
                    else if (scan_result == 2)
                    {
                        // One-argument commands
                        if (strcmp(cmd, "make") == 0)
                        {
                            if (arg1 > 0 && arg1 <= MAX_PATHS)
                            {
                                generate_paths(paths, &path_count, arg1);
                                // Draw paths in RED
                                draw_all_paths(paths, path_count, RED);
                                swapBuffers();
                                printf("Generated %d paths\\n", arg1);
                            }
                            else
                            {
                                printf("Invalid path count! Must be 1-%d\\n", MAX_PATHS);
                            }
                        }
                        else
                        {
                            printf("Unknown command: %s\\n", cmd);
                        }
                    }
                    else if (scan_result == 4)
                    {
                        // Three-argument commands
                        if (strcmp(cmd, "start") == 0)
                        {
                            if (arg1 > 0 && arg1 <= MAX_BALLOONS && arg2 >= 0 && arg3 >= 0)
                            {
                                spawn_balloons(arg1, arg2, arg3);
                                printf("Spawned %d red, %d blue, %d green balloons\\n", arg1, arg2, arg3);
                            }
                            else
                            {
                                printf("Invalid balloon counts! Red: 1-%d, Blue/Green: >= 0\\n", MAX_BALLOONS);
                            }
                        }
                        else
                        {
                            printf("Unknown command: %s\\n", cmd);
                        }
                    }
                    else
                    {
                        printf("Invalid command format!\\n");
                    }

                    buffer_index = 0;
                }
            }
            else if (buffer_index < 31)
            {
                input_buffer[buffer_index++] = (char)c;
            }
        }

        PT_YIELD_usec(1000); // 10ms
    }

    PT_END(pt);
}

// this is a thread that does all of the drawing
static PT_THREAD(protothread_anim(struct pt *pt))
{
    PT_BEGIN(pt);

    PT_END(pt);
}

static PT_THREAD(protothread_animate_monkeys(struct pt *pt))
{
    PT_BEGIN(pt);

    while (true)
    {
        // Handle special game states with their own screens
        if (game_state == STATE_START_SCREEN)
        {
            draw_start_screen();
            swapBuffers();
            PT_YIELD_usec(30000); // 30ms (~33 fps)
            continue;
        }

        if (game_state == STATE_GAME_WON)
        {
            draw_win_screen();
            swapBuffers();
            PT_YIELD_usec(30000); // 30ms (~33 fps)
            continue;
        }

        if (game_state == STATE_GAME_LOST)
        {
            draw_lost_screen();
            swapBuffers();
            PT_YIELD_usec(30000); // 30ms (~33 fps)
            continue;
        }

        // DOUBLE BUFFER CLEARING STRATEGY:
        // - Buffer A and B alternate each frame
        // - prev_prev = what we drew to THIS buffer 2 frames ago
        // - prev = what we drew to OTHER buffer 1 frame ago
        // - draw = what we're about to draw NOW
        //
        // Order: Calculate -> Clear prev_prev -> Shift -> Draw

        // STEP 1: Calculate new draw positions from current fix15 positions
        for (uint8_t i = 0; i < balloon_count; i++)
        {
            Balloon *b = &balloons[i];
            if (!b->active)
                continue;

            // Store new draw position (we'll shift it into prev after clearing)
            b->draw_x = (int16_t)b->x - (BALLOON_WIDTH / 2);
            b->draw_y = (int16_t)b->y - (BALLOON_HEIGHT / 2);
        }

        // STEP 2: Clear old balloon positions (prev_prev is what was drawn to THIS buffer 2 frames ago)
        clear_and_restore_balloon_positions();

        // STEP 2b: Clear old dart positions (prev_prev is what was drawn to THIS buffer 2 frames ago)
        clear_and_restore_dart_positions();

        // STEP 3: Shift position history AFTER clearing
        // Now prev_prev will be ready for next time we draw to THIS buffer (in 2 frames)
        for (uint8_t i = 0; i < balloon_count; i++)
        {
            Balloon *b = &balloons[i];
            if (!b->active && !b->spawned)
                continue;

            // Shift: what we're about to draw becomes prev_prev in 2 frames
            b->prev_prev_draw_x = b->prev_draw_x;
            b->prev_prev_draw_y = b->prev_draw_y;
            b->prev_draw_x = b->draw_x;
            b->prev_draw_y = b->draw_y;
        }

        // STEP 3b: Shift dart position history AFTER clearing
        for (int i = 0; i < MAX_DARTS; i++)
        {
            if (!darts[i].active)
                continue;

            // Shift: what we're about to draw becomes prev_prev in 2 frames
            darts[i].prev_prev_x = darts[i].prev_x;
            darts[i].prev_prev_y = darts[i].prev_y;
            darts[i].prev_x = darts[i].x;
            darts[i].prev_y = darts[i].y;
        }

        // STEP 2: Redraw monkeys (they update their own cells)
        for (uint8_t row = 0; row < ROWS; row++)
        {
            for (uint8_t col = 0; col < COLS; col++)
            {
                if (monkeys[row][col].active)
                {
                    volatile Monkey *m = &monkeys[row][col];

                    uint16_t x = GRID_START_X + (col * CELL_SIZE) + 1;
                    uint16_t y = GRID_START_Y + (row * CELL_SIZE) + 1;

                    fillRect(x, y, CELL_SIZE - 2, CELL_SIZE - 2, BG_COLOR);

                    redraw_grass_in_cell(row, col);

                    uint16_t cx = GRID_START_X + (col * CELL_SIZE) + (CELL_SIZE / 2);
                    uint16_t cy = GRID_START_Y + (row * CELL_SIZE) + (CELL_SIZE / 2);
                    draw_sprite_rotated(cx, cy, monkey_body, MONKEY_WIDTH, MONKEY_HEIGHT, m->angle, 0x00);
                    // Draw dart circle at the monkey's gun tip
                    float angle_rad = (float)m->angle * (PI / 180.0f);
                    int16_t dart_offset_x = (int16_t)((MONKEY_WIDTH / 2.5) * cosf(angle_rad));
                    int16_t dart_offset_y = (int16_t)((MONKEY_HEIGHT / 2.5) * sinf(angle_rad));
                    fillCircle(cx + dart_offset_x, cy + dart_offset_y, DART_RADIUS, DART_COLOR);

                    redraw_cell_grid_lines(row, col);
                }
            }
        }

        // STEP 3: Draw ALL paths (ensures paths are UNDER balloons)
        draw_all_paths(paths, path_count, RED);

        // STEP 4: Draw ALL balloons on top (transparent pixels show everything underneath)
        draw_balloons();

        // STEP 4b: Draw ALL darts on top of balloons
        draw_darts();

        // STEP 5: Draw game UI (level, health, remaining balloons)
        draw_game_ui();

        swapBuffers();

        PT_YIELD_usec(30000); // 30ms (~33 fps)
    }

    PT_END(pt);
}

static PT_THREAD(protothread_balloon_update(struct pt *pt))
{
    PT_BEGIN(pt);

    while (true)
    {
        // Don't update balloons if game is in special states
        if (game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON && game_state != STATE_START_SCREEN)
        {
            update_balloons();
        }

        PT_YIELD_usec(30000); // 30ms per update (~33 fps) - synchronized with animation
    }

    PT_END(pt);
}

static PT_THREAD(protothread_monkey_logic(struct pt *pt))
{
    PT_BEGIN(pt);

    while (true)
    {
        // Don't update monkeys if game is in special states
        if (game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON && game_state != STATE_START_SCREEN)
        {
            for (uint8_t row = 0; row < ROWS; row++)
            {
                for (uint8_t col = 0; col < COLS; col++)
                {
                    if (monkeys[row][col].active)
                    {
                        target_closest_balloons(&monkeys[row][col]);
                    }
                }
            }
        }

        PT_YIELD_usec(100000); // 100ms per update (~10 fps)
    }

    PT_END(pt);
}

static PT_THREAD(protothread_dart_logic(struct pt *pt))
{
    PT_BEGIN(pt);
    while (true)
    {
        for (uint8_t row = 0; row < ROWS; row++)
        {
            for (uint8_t col = 0; col < COLS; col++)
            {
                if (monkeys[row][col].active)
                {
                    if (monkeys[row][col].dart_cooldown == 0)
                    {
                        throw_dart(&monkeys[row][col]);

                        monkeys[row][col].dart_cooldown = 10; // Set cooldown
                    }
                    else
                    {
                        monkeys[row][col].dart_cooldown--;
                    }
                }
            }
        }
        update_darts();
        PT_YIELD_usec(30000); // 50ms per update (~20 fps)
    }

    PT_END(pt);
}

static PT_THREAD(protothread_balloon_spawner(struct pt *pt))
{
    PT_BEGIN(pt);

    while (true)
    {
        // Don't spawn balloons if game is in special states
        if (game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON && game_state != STATE_START_SCREEN)
        {
            if (next_balloon_to_spawn < balloons_to_spawn)
            {
                uint8_t idx = next_balloon_to_spawn;
                if (!balloons[idx].spawned)
                {
                    init_balloon(idx, balloons[idx].path_index);
                    // printf("Spawning balloon %d on path %d\\n", idx, balloons[idx].path_index);
                    next_balloon_to_spawn++;

                    PT_YIELD_usec(BALLOON_SPAWN_DELAY_MS * 1000);
                }
            }
            else
            {
                // No balloons to spawn, just yield
                PT_YIELD_usec(100000); // 100ms
            }
        }
        else
        {
            PT_YIELD_usec(100000); // 100ms
        }
    }

    PT_END(pt);
}

static PT_THREAD(protothread_game_logic(struct pt *pt))
{
    PT_BEGIN(pt);

    static bool prev_reset_state = true; // true = high, false = low --> pressed
    static bool prev_start_next_state = true;

    // Start with the start screen instead of immediately showing first round
    // on_before_round(); // removed - now starts with STATE_START_SCREEN

    while (true)
    {
        gpio_put(LED_PIN, !gpio_get(LED_PIN)); // blink

        bool current_reset_state = gpio_get(GAME_RESET_PIN);
        bool current_start_next_state = gpio_get(START_NEXT_ROUND_PIN);

        if (prev_reset_state && !current_reset_state && game_state != STATE_START_SCREEN)
        {
            // pressed game reset
            // printf("Game reset pressed!\\n");
            reset_game(); // This now goes to STATE_START_SCREEN
            on_before_round();
        }

        // Handle start button based on current state
        if (prev_start_next_state && !current_start_next_state)
        {
            // printf("Start button pressed! Current game_state: %d (STATE_BEFORE_ROUND=%d, STATE_ROUND_ACTIVE=%d)\\n",
            //        game_state, STATE_BEFORE_ROUND, STATE_ROUND_ACTIVE);

            if (game_state == STATE_START_SCREEN)
            {
                // Start the game from the start screen
                // printf("Starting game from start screen!\\n");
                game_state = STATE_BEFORE_ROUND;

                // Call on_before_round to set up the level (generates paths, sets balloon counts)
                on_before_round();

                // Now redraw map with paths to BOTH buffers to completely clear start screen
                draw_map();
                draw_all_paths(paths, path_count, RED);
                swapBuffers();
                draw_map();
                draw_all_paths(paths, path_count, RED);
                swapBuffers();
            }
            else if (game_state == STATE_BEFORE_ROUND)
            {
                // pressed to start next round
                // printf("Start next round pressed! round_ended=%d\\n", round_ended);
                on_round_start();
            }
            else
            {
                // printf("Button pressed but game_state is %d (not STATE_START_SCREEN or STATE_BEFORE_ROUND)\\n", game_state);
            }
        }

        // Check for lose condition (but not if already lost or won)
        if (player_health <= 0 && game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON)
        {
            on_lose();
        }

        // Check for round end (but not if lost or won)
        if (!round_ended && check_round_end() && game_state != STATE_GAME_LOST && game_state != STATE_GAME_WON)
        {
            on_round_end();
        }

        prev_reset_state = current_reset_state;
        prev_start_next_state = current_start_next_state;

        PT_YIELD_usec(10000); // 10ms
    }

    PT_END(pt);
}

void core1_main()
{
    gpio_init(MUX_S0);
    gpio_set_dir(MUX_S0, GPIO_OUT);
    gpio_init(MUX_S1);
    gpio_set_dir(MUX_S1, GPIO_OUT);
    gpio_init(MUX_S2);
    gpio_set_dir(MUX_S2, GPIO_OUT);
    gpio_init(MUX_S3);
    gpio_set_dir(MUX_S3, GPIO_OUT);

    adc_init();
    adc_gpio_init(26); // MUX A SIG/OUTPUT
    adc_gpio_init(27); // MUX B SIG/OUTPUT

    pt_add_thread(protothread_read_board);
    pt_add_thread(protothread_game_logic);
    pt_schedule_start;
}

// Main (runs on core 0)
int main()
{
    set_sys_clock_khz(150000, true);
    stdio_init_all();

    initVGA();

    sprite_init();
    draw_map();

    path_init_random(45678);

    // swap buffers to display the initial map
    swapBuffers();

    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    gpio_init(GAME_RESET_PIN);
    gpio_set_dir(GAME_RESET_PIN, GPIO_IN);
    gpio_pull_up(GAME_RESET_PIN);

    gpio_init(START_NEXT_ROUND_PIN);
    gpio_set_dir(START_NEXT_ROUND_PIN, GPIO_IN);
    gpio_pull_up(START_NEXT_ROUND_PIN);

    multicore_reset_core1();
    multicore_launch_core1(&core1_main);

    // Initialize and start audio playback (continuous loop)
    audio_init();
    // audio_start_playback();
    // printf("Audio playback started (continuous loop)\\n");

    // Set up balloon end callback
    set_balloon_end_callback(on_balloon_end);

    // pt_add_thread(protothread_serial_handler);
    pt_add_thread(protothread_balloon_update);
    pt_add_thread(protothread_balloon_spawner);
    pt_add_thread(protothread_animate_monkeys);
    pt_add_thread(protothread_monkey_logic);
    pt_add_thread(protothread_dart_logic);
    pt_schedule_start;
}`,of=`/**
 * Audio playback using the PWN
 *
 * Saves on using GPIO ports compared to using a DAC
 *
 * The system is non-blocking - it uses interrupts to play audio in the background
 * while the main game is running.
 *
 * 128 - silence
 * 0 - mmax negative amplitude
 * 255 - max positive amplitude
 *
 * Mimic a DAC
 *
 * Rapidly toggle a GPIO pin between 0 and 3.3V at very high frequency.
 *
 * By varying the duty cycle very quickly according to your audio samples, we mimic the behavior of a DAC.
 *
 * The repeating timer determines when the PWM duty cycle changes (44.1 kHz). --> 23 microseconds
 * Resolution of 8 bits (0-255) gives us 256 discrete voltage levels.
 */

#include "audio_playback.h"
#include "balloon_pop_audio.h"
#include "pico/stdlib.h"
#include "hardware/pwm.h"
#include "pico/time.h"
#include <stdio.h>

static uint slice_num;
static uint channel;
static volatile bool is_playing = false;
static volatile bool is_looping = false; // true for looping, false for one-shot
static volatile uint32_t sample_index = 0;
static volatile uint32_t sound_length = 0; // Length of current sound effect
static repeating_timer_t audio_timer;

bool audio_timer_callback(repeating_timer_t *rt)
{
  if (is_playing)
  {
    pwm_set_gpio_level(AUDIO_PIN, balloon_pop_audio[sample_index]);

    sample_index++;

    if (is_looping)
    {
      if (sample_index >= AUDIO_NUM_SAMPLES)
      {
        sample_index = 0;
      }
      return true;
    }
    else
    {
      if (sample_index >= sound_length)
      {
        is_playing = false;
        pwm_set_gpio_level(AUDIO_PIN, 128);
        return false;
      }
      return true;
    }
  }
  return false;
}

void audio_init(void)
{
  gpio_set_function(AUDIO_PIN, GPIO_FUNC_PWM);
  slice_num = pwm_gpio_to_slice_num(AUDIO_PIN);
  channel = pwm_gpio_to_channel(AUDIO_PIN);

  // printf("Audio init: GPIO %d, PWM slice %d, channel %d\\n", AUDIO_PIN, slice_num, channel);

  // Configure PWM for audio output
  // PWM frequency should be much higher than audible range
  // System clock is 150 MHz
  // Using wrap of 255 gives us: 150MHz / 256 = ~586 kHz PWM frequency
  pwm_config config = pwm_get_default_config();
  pwm_config_set_clkdiv(&config, 1.0f); // No clock divider for maximum PWM frequency
  pwm_config_set_wrap(&config, 255);    // 8-bit resolution (0-255)
  pwm_init(slice_num, &config, true);

  pwm_set_gpio_level(AUDIO_PIN, 128); // (silence/center)

  is_playing = false;
  sample_index = 0;
}

void audio_start_playback(void)
{
  if (!is_playing)
  {
    is_playing = true;
    is_looping = true;
    sample_index = 0;
    sound_length = AUDIO_NUM_SAMPLES;

    // printf("Starting audio playback: %d samples at 44.1kHz (looping)\\n", AUDIO_NUM_SAMPLES);

    // 1/44100 Hz = ~22.68 microseconds per sample
    add_repeating_timer_us(23, audio_timer_callback, NULL, &audio_timer);

    // printf("Audio timer started\\n");
  }
}

// Play a one-shot sound effect (non-blocking)
void audio_play_sound_effect(void)
{
  if (is_playing)
  {
    cancel_repeating_timer(&audio_timer);
  }

  is_playing = true;
  is_looping = false;
  sample_index = 0;
  sound_length = AUDIO_NUM_SAMPLES;

  add_repeating_timer_us(23, audio_timer_callback, NULL, &audio_timer);
}

void audio_stop_playback(void)
{
  is_playing = false;

  cancel_repeating_timer(&audio_timer);

  // Set PWM to silence (50% duty cycle)
  pwm_set_gpio_level(AUDIO_PIN, 128);
}

bool audio_is_playing(void)
{
  return is_playing;
}
`,sf=`/**
 * Paths are generated on a grid of intersections, not cell centers.
 * Eachg path goes from one edge of the grid to the opposite edge.
 *
 * Randomly select a start edge.
 * End edge is always opposite of the start
 *
 * Picks random intersection points at each edge.
 *
 * First finds a variant shortest path using A* algorithm on the grid intersections.
 * Converts the intersection path to pixel waypoints for the balloon to follow
 *
 * g-cost = how far from start
 * h-cost = manhattan distance to end
 * f-cost = g + h
 *
 * A* picks nodes with lowest f-cost to explore next.
 */

#include "path_generation.h"
#include "vga256_graphics.h"
#include <stdlib.h>
#include <stdio.h>

void path_init_random(uint32_t seed)
{
  srand(seed);
}

// convert grid intersection to pixel coordinates
// grid intersections are at the corners of cells, not centers
void intersection_to_pixel(uint8_t row, uint8_t col, int16_t *x, int16_t *y)
{
  *x = GRID_START_X + (col * CELL_SIZE);
  *y = GRID_START_Y + (row * CELL_SIZE);
}

EdgeType get_opposite_edge(EdgeType edge)
{
  switch (edge)
  {
  case EDGE_TOP:
    return EDGE_BOTTOM;
  case EDGE_BOTTOM:
    return EDGE_TOP;
  case EDGE_LEFT:
    return EDGE_RIGHT;
  case EDGE_RIGHT:
    return EDGE_LEFT;
  }
  return EDGE_TOP; // fallback
}

static void get_random_edge_intersection(EdgeType edge, uint8_t *row, uint8_t *col)
{
  switch (edge)
  {
  case EDGE_TOP:
    *row = 0;
    *col = rand() % (GRID_COLS + 1);
    break;
  case EDGE_BOTTOM:
    *row = GRID_ROWS;
    *col = rand() % (GRID_COLS + 1);
    break;
  case EDGE_LEFT:
    *row = rand() % (GRID_ROWS + 1);
    *col = 0;
    break;
  case EDGE_RIGHT:
    *row = rand() % (GRID_ROWS + 1);
    *col = GRID_COLS;
    break;
  }
}

// A* pathfinding structures
typedef struct
{
  uint8_t row;
  uint8_t col;
  uint8_t parent_row;
  uint8_t parent_col;
  fix15 g_cost; // cost from start (fix15)
  fix15 h_cost; // heuristic cost to end (fix15)
  fix15 f_cost; // g + h (fix15)
  bool visited;
} AStarNode;

// Calculate Manhattan distance heuristic in fix15
static fix15 heuristic(uint8_t row1, uint8_t col1, uint8_t row2, uint8_t col2)
{
  int dr = (int)row1 - (int)row2;
  int dc = (int)col1 - (int)col2;
  if (dr < 0)
    dr = -dr;
  if (dc < 0)
    dc = -dc;
  return int2fix15(dr + dc);
}

// Find shortest path using A* algorithm on grid intersections
// Grid now has (GRID_ROWS+1) x (GRID_COLS+1) intersection points
// g_cost: actual cost initially infinite
// h_cost: manhattan distance to end
// f_cost: total estaimate cost

/**
 * Maintains an "open list" of nodes to explore
 * Repeatedly picks node with lowest f_cost
 * Explores its 4 neighbors (up/down/left/right)
 * Updates costs and parents when better paths are found

 */
static bool find_shortest_path(uint8_t start_row, uint8_t start_col,
                               uint8_t end_row, uint8_t end_col,
                               Waypoint *waypoints, uint8_t *waypoint_count)
{
#define GRID_INTERSECT_ROWS (GRID_ROWS + 1)
#define GRID_INTERSECT_COLS (GRID_COLS + 1)

  AStarNode grid[GRID_INTERSECT_ROWS][GRID_INTERSECT_COLS];
  AStarNode open_list[GRID_INTERSECT_ROWS * GRID_INTERSECT_COLS];
  uint8_t open_count = 0;

  fix15 infinity = 0x7FFFFFFF; // max fix15 value
  for (uint8_t r = 0; r < GRID_INTERSECT_ROWS; r++)
  {
    for (uint8_t c = 0; c < GRID_INTERSECT_COLS; c++)
    {
      grid[r][c].row = r;
      grid[r][c].col = c;
      grid[r][c].g_cost = infinity;
      grid[r][c].h_cost = heuristic(r, c, end_row, end_col);
      grid[r][c].f_cost = grid[r][c].g_cost + grid[r][c].h_cost;
      grid[r][c].visited = false;
      grid[r][c].parent_row = 255;
      grid[r][c].parent_col = 255;
    }
  }

  grid[start_row][start_col].g_cost = 0;
  grid[start_row][start_col].f_cost = grid[start_row][start_col].h_cost;
  open_list[open_count++] = grid[start_row][start_col];

  while (open_count > 0)
  {
    uint8_t current_idx = 0;
    for (uint8_t i = 1; i < open_count; i++)
    {
      if (open_list[i].f_cost < open_list[current_idx].f_cost)
      {
        current_idx = i;
      }
    }

    AStarNode current = open_list[current_idx];

    for (uint8_t i = current_idx; i < open_count - 1; i++)
    {
      open_list[i] = open_list[i + 1];
    }
    open_count--;

    grid[current.row][current.col].visited = true;

    if (current.row == end_row && current.col == end_col)
    {
      // reconstruct path
      uint8_t path_intersections[GRID_INTERSECT_ROWS * GRID_INTERSECT_COLS][2];
      uint8_t path_len = 0;
      uint8_t curr_r = end_row;
      uint8_t curr_c = end_col;

      while (curr_r != start_row || curr_c != start_col)
      {
        path_intersections[path_len][0] = curr_r;
        path_intersections[path_len][1] = curr_c;
        path_len++;

        uint8_t next_r = grid[curr_r][curr_c].parent_row;
        uint8_t next_c = grid[curr_r][curr_c].parent_col;
        curr_r = next_r;
        curr_c = next_c;
      }

      path_intersections[path_len][0] = start_row;
      path_intersections[path_len][1] = start_col;
      path_len++;

      // conver to waypoints
      *waypoint_count = 0;
      for (int i = path_len - 1; i >= 0 && *waypoint_count < MAX_WAYPOINTS_PER_PATH; i--)
      {
        intersection_to_pixel(path_intersections[i][0], path_intersections[i][1],
                              &waypoints[*waypoint_count].x,
                              &waypoints[*waypoint_count].y);
        (*waypoint_count)++;
      }

      return true;
    }

    int8_t dr[] = {-1, 1, 0, 0};
    int8_t dc[] = {0, 0, -1, 1};

    for (uint8_t i = 0; i < 4; i++)
    {
      int8_t new_row = current.row + dr[i];
      int8_t new_col = current.col + dc[i];

      if (new_row < 0 || new_row >= GRID_INTERSECT_ROWS || new_col < 0 || new_col >= GRID_INTERSECT_COLS)
      {
        continue;
      }

      if (grid[new_row][new_col].visited)
      {
        continue;
      }

      fix15 tentative_g = grid[current.row][current.col].g_cost + int2fix15(1);

      // Add random cost to make paths less optimal and more interesting
      // random value (0.5 to 1.5)
      // rand() % 100 gives 0-99
      // (rand() % 100 - 50) gives -50 to +49
      // multiply by 327 to get -16384 to +16003 (~ -0.5 to +0.5 in fix15)

      // 25% is just to discourage paths from being too long
      // The 25% offset shifts the average cost upward,
      // making A* still prefer reasonably short paths while allowing variation.
      fix15 random_factor = int2fix15(1) + (fix15)((rand() % 100 - 50) * 327); // ~0.5 to 1.5 range
      tentative_g = tentative_g + (tentative_g >> 2);                          // Add 25% extra cost to encourage variation (div 4)
      tentative_g = multfix15(tentative_g, random_factor);

      if (tentative_g < grid[new_row][new_col].g_cost)
      {
        grid[new_row][new_col].parent_row = current.row;
        grid[new_row][new_col].parent_col = current.col;
        grid[new_row][new_col].g_cost = tentative_g;
        grid[new_row][new_col].f_cost = tentative_g + grid[new_row][new_col].h_cost;

        bool in_open = false;
        for (uint8_t j = 0; j < open_count; j++)
        {
          if (open_list[j].row == new_row && open_list[j].col == new_col)
          {
            open_list[j] = grid[new_row][new_col];
            in_open = true;
            break;
          }
        }

        if (!in_open && open_count < GRID_INTERSECT_ROWS * GRID_INTERSECT_COLS)
        {
          open_list[open_count++] = grid[new_row][new_col];
        }
      }
    }
  }

  return false; // no path found
}

// add variation to paths while keeping all waypoints on grid intersections
static void add_path_variation(Waypoint *waypoints, uint8_t *waypoint_count)
{
  if (*waypoint_count < 2)
  {
    return; // too short to vary
  }

  Waypoint new_waypoints[MAX_WAYPOINTS_PER_PATH];
  uint8_t new_count = 0;

  for (uint8_t i = 0; i < *waypoint_count - 1 && new_count < MAX_WAYPOINTS_PER_PATH - 4; i++)
  {
    new_waypoints[new_count++] = waypoints[i];

    int16_t dx = waypoints[i + 1].x - waypoints[i].x;
    int16_t dy = waypoints[i + 1].y - waypoints[i].y;

    bool is_horizontal = (dy == 0 && dx != 0);
    bool is_vertical = (dx == 0 && dy != 0);

    if ((is_horizontal && abs(dx) > CELL_SIZE) || (is_vertical && abs(dy) > CELL_SIZE))
    {
      int16_t segment_length = is_horizontal ? abs(dx) : abs(dy);
      int16_t num_cells = segment_length / CELL_SIZE;

      int detour_chance = (num_cells > 2) ? 60 : 40;

      if (rand() % 100 < detour_chance)
      {
        if (is_horizontal)
        {
          int16_t segment_start = waypoints[i].x < waypoints[i + 1].x ? waypoints[i].x : waypoints[i + 1].x;
          int16_t segment_end = waypoints[i].x > waypoints[i + 1].x ? waypoints[i].x : waypoints[i + 1].x;

          int16_t x1 = segment_start + (segment_length / 3);
          int16_t x2 = segment_start + (2 * segment_length / 3);

          x1 = GRID_START_X + (((x1 - GRID_START_X + CELL_SIZE / 2) / CELL_SIZE) * CELL_SIZE);
          x2 = GRID_START_X + (((x2 - GRID_START_X + CELL_SIZE / 2) / CELL_SIZE) * CELL_SIZE);

          int16_t offset = (rand() % 2 + 1) * CELL_SIZE * (rand() % 2 == 0 ? 1 : -1);

          int16_t zig_y = waypoints[i].y + offset;

          if (zig_y >= GRID_START_Y && zig_y <= GRID_START_Y + (GRID_ROWS * CELL_SIZE) &&
              x1 != waypoints[i].x && x2 != waypoints[i + 1].x)
          {
            new_waypoints[new_count].x = x1;
            new_waypoints[new_count].y = waypoints[i].y;
            new_count++;
            new_waypoints[new_count].x = x1;
            new_waypoints[new_count].y = zig_y;
            new_count++;
            new_waypoints[new_count].x = x2;
            new_waypoints[new_count].y = zig_y;
            new_count++;
            new_waypoints[new_count].x = x2;
            new_waypoints[new_count].y = waypoints[i].y;
            new_count++;
          }
        }
        else // is_vertical
        {
          int16_t segment_start = waypoints[i].y < waypoints[i + 1].y ? waypoints[i].y : waypoints[i + 1].y;
          int16_t segment_end = waypoints[i].y > waypoints[i + 1].y ? waypoints[i].y : waypoints[i + 1].y;

          int16_t y1 = segment_start + (segment_length / 3);
          int16_t y2 = segment_start + (2 * segment_length / 3);

          y1 = GRID_START_Y + (((y1 - GRID_START_Y + CELL_SIZE / 2) / CELL_SIZE) * CELL_SIZE);
          y2 = GRID_START_Y + (((y2 - GRID_START_Y + CELL_SIZE / 2) / CELL_SIZE) * CELL_SIZE);

          int16_t offset = (rand() % 2 + 1) * CELL_SIZE * (rand() % 2 == 0 ? 1 : -1);

          int16_t zig_x = waypoints[i].x + offset;

          if (zig_x >= GRID_START_X && zig_x <= GRID_START_X + (GRID_COLS * CELL_SIZE) &&
              y1 != waypoints[i].y && y2 != waypoints[i + 1].y)
          {
            new_waypoints[new_count].x = waypoints[i].x;
            new_waypoints[new_count].y = y1;
            new_count++;
            new_waypoints[new_count].x = zig_x;
            new_waypoints[new_count].y = y1;
            new_count++;
            new_waypoints[new_count].x = zig_x;
            new_waypoints[new_count].y = y2;
            new_count++;
            new_waypoints[new_count].x = waypoints[i].x;
            new_waypoints[new_count].y = y2;
            new_count++;
          }
        }
      }
    }
  }

  if (new_count < MAX_WAYPOINTS_PER_PATH)
  {
    new_waypoints[new_count++] = waypoints[*waypoint_count - 1];
  }

  for (uint8_t i = 0; i < new_count; i++)
  {
    waypoints[i] = new_waypoints[i];
  }
  *waypoint_count = new_count;
}

static void generate_single_path(Path *path)
{
  EdgeType start_edge = rand() % 4;
  EdgeType end_edge = get_opposite_edge(start_edge);

  path->start_edge = start_edge;
  path->end_edge = end_edge;

  uint8_t start_row, start_col, end_row, end_col;
  get_random_edge_intersection(start_edge, &start_row, &start_col);
  get_random_edge_intersection(end_edge, &end_row, &end_col);

  path->waypoint_count = 0;
  bool found = find_shortest_path(start_row, start_col, end_row, end_col,
                                  path->waypoints, &path->waypoint_count);

  if (found)
  {
    add_path_variation(path->waypoints, &path->waypoint_count);
    path->active = true;
  }
  else
  {
    path->active = false;
  }
}

void generate_paths(Path *paths, uint8_t *path_count, uint8_t num_paths)
{
  if (num_paths > MAX_PATHS)
  {
    num_paths = MAX_PATHS;
  }

  for (uint8_t i = 0; i < MAX_PATHS; i++)
  {
    paths[i].active = false;
    paths[i].waypoint_count = 0;
  }

  *path_count = num_paths;

  for (uint8_t i = 0; i < num_paths; i++)
  {
    generate_single_path(&paths[i]);

    // printf("Path %d: ", i);
    // for (uint8_t w = 0; w < paths[i].waypoint_count; w++)
    // {
    //   printf("(%d,%d) ", paths[i].waypoints[w].x, paths[i].waypoints[w].y);
    // }
    // printf("\\n");
  }

  // printf("Generated %d paths\\n", num_paths);
}

void draw_path(const Path *path, uint8_t color)
{
  if (!path->active || path->waypoint_count < 2)
  {
    return;
  }

  for (uint8_t i = 0; i < path->waypoint_count - 1; i++)
  {
    drawLine(path->waypoints[i].x, path->waypoints[i].y, path->waypoints[i + 1].x, path->waypoints[i + 1].y, color);
  }

  if (path->waypoint_count > 0)
  { // start position
    fillCircle(path->waypoints[0].x, path->waypoints[0].y, 4, GREEN);
  }

  if (path->waypoint_count > 1)
  { // end position
    fillCircle(path->waypoints[path->waypoint_count - 1].x, path->waypoints[path->waypoint_count - 1].y, 4, BLUE);
  }
}

void draw_all_paths(const Path *paths, uint8_t path_count, uint8_t color)
{
  for (uint8_t i = 0; i < path_count; i++)
  {
    draw_path(&paths[i], color);
  }
}
`,af=`#include <stdint.h>
#include <math.h>
#include "vga256_graphics.h"
#include "sprites.h"

#define uint8_t unsigned char

typedef signed int fix15;
#define multfix15(a, b) ((fix15)((((signed long long)(a)) * ((signed long long)(b))) >> 15))
#define float2fix15(a) ((fix15)((a) * 32768.0))
#define fix2float15(a) ((float)(a) / 32768.0)
#define int2fix15(a) ((fix15)(a << 15))
#define fix2int15(a) ((int)(a >> 15))
#define divfix(a, b) (fix15)((((signed long long)(a)) << 15) / (b))

#define SINE_TABLE_SIZE 360
static fix15 sin_table[SINE_TABLE_SIZE];
static int sin_table_initialized = 0;

const int SCREEN_WIDTH = 319;
const int SCREEN_HEIGHT = 240;

void sprite_init(void)
{
  if (sin_table_initialized)
    return;

  for (int i = 0; i < SINE_TABLE_SIZE; i++)
  {
    float angle_rad = (float)i * 3.14159265358979323846f / 180.0f;
    sin_table[i] = float2fix15(sinf(angle_rad));
  }

  sin_table_initialized = 1;
}

static inline fix15 fixed_sin_deg(int angle)
{
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return sin_table[angle];
}

// Fast fixed-point cosine function (angle in degrees)
static inline fix15 fixed_cos_deg(int angle)
{
  // cos(x) = sin(x + 90)
  return fixed_sin_deg(angle + 90);
}

// Draw sprite from flash at the given x, y position, in pixels
// (x, y) is the top-left corner where the sprite will be drawn
// sprite = pointer to sprite data array in flash
// width = sprite width in pixels
// height = sprite height in pixels
// transparent_color = color to treat as transparent (will not draw these pixels)
//                     pass -1 (or any value >= 256) to disable transparency
void draw_sprite(int x, int y, const uint8_t *sprite, int width, int height, uint8_t transparent_color)
{
  for (int j = 0; j < height; j++)
  {
    for (int i = 0; i < width; i++)
    {
      uint8_t pixel_color = sprite[j * width + i];

      if (pixel_color == transparent_color)
      {
        continue;
      }

      int draw_x = x + i;
      int draw_y = y + j;

      if (draw_x >= 0 && draw_x < SCREEN_WIDTH && draw_y >= 0 && draw_y < SCREEN_HEIGHT)
      {
        drawPixel(draw_x, draw_y, pixel_color);
      }
    }
  }
}

// Draw sprite with rotation using fix15 arithmetic for better performance
// (x, y) is the center point around which the sprite rotates
// sprite = pointer to sprite data array in flash
// width = sprite width in pixels
// height = sprite height in pixels
// angle_degrees = rotation angle in degrees (clockwise, integer for lookup table)
// transparent_color = color to treat as transparent (will not draw these pixels)
void draw_sprite_rotated(int x, int y, const uint8_t *sprite, int width, int height,
                         int angle_degrees, uint8_t transparent_color)
{
  if (!sin_table_initialized)
    sprite_init();

  fix15 cos_angle = fixed_cos_deg(angle_degrees);
  fix15 sin_angle = fixed_sin_deg(angle_degrees);

  // Calculate sprite half dimensions in fix15
  fix15 half_w = int2fix15(width) >> 1;  // width/2 in fix15
  fix15 half_h = int2fix15(height) >> 1; // height/2 in fix15

  // Calculate the bounding box of the rotated sprite
  // Check all four corners to find the extents
  fix15 corners_x[4] = {-half_w, half_w, half_w, -half_w};
  fix15 corners_y[4] = {-half_h, -half_h, half_h, half_h};

  fix15 min_x = 0, max_x = 0, min_y = 0, max_y = 0;
  for (int i = 0; i < 4; i++)
  {
    fix15 rot_x = multfix15(corners_x[i], cos_angle) - multfix15(corners_y[i], sin_angle);
    fix15 rot_y = multfix15(corners_x[i], sin_angle) + multfix15(corners_y[i], cos_angle);

    if (i == 0)
    {
      min_x = max_x = rot_x;
      min_y = max_y = rot_y;
    }
    else
    {
      if (rot_x < min_x)
        min_x = rot_x;
      if (rot_x > max_x)
        max_x = rot_x;
      if (rot_y < min_y)
        min_y = rot_y;
      if (rot_y > max_y)
        max_y = rot_y;
    }
  }

  // Convert bounding box to integers
  int start_x = x + fix2int15(min_x);
  int end_x = x + fix2int15(max_x);
  int start_y = y + fix2int15(min_y);
  int end_y = y + fix2int15(max_y);

  // Pre-calculate the base relative positions for the inverse rotation
  // This reduces redundant calculations in the inner loop
  for (int screen_y = start_y; screen_y <= end_y; screen_y++)
  {
    // Calculate y component once per row
    fix15 rel_y_fixed = int2fix15(screen_y - y);
    fix15 y_cos = multfix15(rel_y_fixed, sin_angle); // For src_x calculation
    fix15 y_sin = multfix15(rel_y_fixed, cos_angle); // For src_y calculation

    for (int screen_x = start_x; screen_x <= end_x; screen_x++)
    {
      if (screen_x < 0 || screen_x >= SCREEN_WIDTH || screen_y < 0 || screen_y >= SCREEN_HEIGHT)
      {
        continue;
      }

      // Calculate position relative to sprite center in fix15
      fix15 rel_x_fixed = int2fix15(screen_x - x);

      // Apply inverse rotation to find source pixel (fix15 math)
      fix15 src_x_fixed = multfix15(rel_x_fixed, cos_angle) + y_cos + half_w;
      fix15 src_y_fixed = -multfix15(rel_x_fixed, sin_angle) + y_sin + half_h;

      // Convert to integer coordinates (with rounding: add 0.5 in fix15 = 1<<14)
      int src_xi = fix2int15(src_x_fixed + (1 << 14));
      int src_yi = fix2int15(src_y_fixed + (1 << 14));

      // Check if the source coordinates are within the sprite bounds
      if (src_xi >= 0 && src_xi < width && src_yi >= 0 && src_yi < height)
      {
        uint8_t pixel_color = sprite[src_yi * width + src_xi];

        if (pixel_color == transparent_color)
        {
          continue;
        }

        drawPixel(screen_x, screen_y, pixel_color);
      }
    }
  }
}`,lf=`// front_buffer - actrively displayed via DMA\r
// vga_back_buffer - back buffer (where to draw changes)\r
// when the frame is ready, we swap and call swapBuffers()\r
\r
// prevent screen tearing by only swapping after a full frame is drawn\r
// smoother animations\r
// Does take more space and takes time to do so.\r
\r
#include <stdio.h>\r
#include <stdlib.h>\r
#include "pico/stdlib.h"\r
#include "hardware/pio.h"\r
#include "hardware/dma.h"\r
// Our assembled programs:\r
// Each gets the name <pio_filename.pio.h>\r
#include "hsync.pio.h"\r
#include "vsync.pio.h"\r
#include "rgb.pio.h"\r
#include "rgb2.pio.h"\r
// #include "rgb2.pio.h"\r
//  Header file\r
#include "vga256_graphics.h"\r
// Font file\r
#include "glcdfont.c"\r
\r
// VGA timing constants\r
#define H_ACTIVE 655   // (active + frontporch - 1) - one cycle delay for mov\r
#define V_ACTIVE 479   // (active - 1)\r
#define RGB_ACTIVE 319 // (horizontal active)/2 - 1\r
// #define RGB_ACTIVE 639 // change to this if 1 pixel/byte\r
\r
// Length of the pixel array, and number of DMA transfers\r
#define TXCOUNT 76800 // Total pixels 320x240 (since we have 2 pixels per byte)\r
\r
// Double buffering: front buffer (displayed) and back buffer (drawn to)\r
// Pixel color array that is DMA's to the PIO machines and\r
// a pointer to the ADDRESS of this color array.\r
// Note that this array is automatically initialized to all 0's (black)\r
unsigned char vga_data_array[TXCOUNT];        // Front buffer (displayed)\r
unsigned char vga_back_buffer[TXCOUNT];       // Back buffer (drawn to)\r
unsigned char *draw_buffer = vga_back_buffer; // Pointer to the buffer we draw to\r
// points to address storing pointer to screen array\r
char *address_pointer = &vga_data_array[0];\r
\r
// For drawLine\r
#define swap(a, b) \\\r
  {                \\\r
    short t = a;   \\\r
    a = b;         \\\r
    b = t;         \\\r
  }\r
\r
// For writing text\r
#define tabspace 4 // number of spaces for a tab\r
\r
// For accessing the font library\r
#define pgm_read_byte(addr) (*(const unsigned char *)(addr))\r
\r
// For drawing characters\r
unsigned short cursor_y, cursor_x, textsize;\r
char textcolor, textbgcolor, wrap;\r
\r
// Screen width/height\r
#define _width 640\r
#define _height 480\r
\r
void initVGA()\r
{\r
  // Choose which PIO instance to use (there are two instances, each with 4 state machines)\r
  PIO pio = pio0;\r
\r
  // Our assembled program needs to be loaded into this PIO's instruction\r
  // memory. This SDK function will find a location (offset) in the\r
  // instruction memory where there is enough space for our program. We need\r
  // to remember these locations!\r
  //\r
  // We only have 32 instructions to spend! If the PIO programs contain more than\r
  // 32 instructions, then an error message will get thrown at these lines of code.\r
  //\r
  // The program name comes from the .program part of the pio file\r
  // and is of the form <program name_program>\r
  uint hsync_offset = pio_add_program(pio, &hsync_program);\r
  uint vsync_offset = pio_add_program(pio, &vsync_program);\r
  uint rgb_offset = pio_add_program(pio, &rgb_program);\r
  uint rgb2_offset = pio_add_program(pio, &rgb2_program);\r
\r
  // Manually select a few state machines from pio instance pio0.\r
  uint hsync_sm = 0;\r
  uint vsync_sm = 1;\r
  uint rgb_sm = 2;\r
  uint rgb_sm3 = 3;\r
\r
  // Call the initialization functions that are defined within each PIO file.\r
  // Why not create these programs here? By putting the initialization function in\r
  // the pio file, then all information about how to use/setup that state machine\r
  // is consolidated in one place. Here in the C, we then just import and use it.\r
  hsync_program_init(pio, hsync_sm, hsync_offset, HSYNC);\r
  vsync_program_init(pio, vsync_sm, vsync_offset, VSYNC);\r
  rgb_program_init(pio, rgb_sm, rgb_offset, 8);   // 8\r
  rgb_program_init(pio, rgb_sm3, rgb2_offset, 8); // 8\r
  // Start the two pio machine IN SYNC\r
  // Note that the RGB state machine is running at full speed,\r
  // so synchronization doesn't matter for that one. But, we'll\r
  // start them all simultaneously anyway.\r
  pio_enable_sm_mask_in_sync(pio, ((1u << hsync_sm) | (1u << vsync_sm) | (1u << rgb_sm) | (1u << rgb_sm3)));\r
\r
  // turn up i/o pin drive\r
  // void gpio_set_drive_strength (uint gpio, enum gpio_drive_strength drive)\r
  for (int i = 8; i <= 15; i++)\r
  {\r
    gpio_set_drive_strength(i, GPIO_DRIVE_STRENGTH_12MA);\r
  }\r
\r
  /////////////////////////////////////////////////////////////////////////////////////////////////////\r
  // ============================== PIO DMA Channels =================================================\r
  /////////////////////////////////////////////////////////////////////////////////////////////////////\r
  // DMA channels - 0 and 2 sends color data, 1 and 3 reconfigures and restarts 0 and 2\r
  // the logic here is that the vsynch state machine enforces line doubling between the two data machines\r
  int rgb_chan_0 = dma_claim_unused_channel(true); // sends data for one aframe then chains to 1\r
  int rgb_chan_1 = dma_claim_unused_channel(true); // set beginning address for chan 0 then chains to  chan 0\r
  int rgb_chan_2 = dma_claim_unused_channel(true); // sends data for one aframe then chains to 3\r
  int rgb_chan_3 = dma_claim_unused_channel(true); // resets channel 2\r
  // ===============================================\r
  // Channel Zero (sends color data to PIO VGA machine)\r
  dma_channel_config c0 = dma_channel_get_default_config(rgb_chan_0); // default configs\r
  channel_config_set_transfer_data_size(&c0, DMA_SIZE_8);             // 8-bit txfers\r
  channel_config_set_read_increment(&c0, true);                       // yes read incrementing\r
  channel_config_set_write_increment(&c0, false);                     // no write incrementing\r
  channel_config_set_dreq(&c0, DREQ_PIO0_TX2);                        // DREQ_PIO0_TX2 pacing (FIFO)\r
  channel_config_set_chain_to(&c0, rgb_chan_1);                       // chain to other channel\r
\r
  dma_channel_configure(\r
      rgb_chan_0,        // Channel to be configured\r
      &c0,               // The configuration we just created\r
      &pio->txf[rgb_sm], // write address (RGB PIO TX FIFO)\r
      &vga_data_array,   // place holder for first load from channel one\r
      TXCOUNT,           // Number of transfers; in this case each is 1 byte.\r
      true               // Don't start immediately.\r
  );\r
\r
  // ===============================================\r
  // Channel One (reconfigures the channel 0 for next line)\r
  dma_channel_config c1 = dma_channel_get_default_config(rgb_chan_1); // default configs\r
  channel_config_set_transfer_data_size(&c1, DMA_SIZE_32);            // 32-bit txfers\r
  channel_config_set_read_increment(&c1, false);                      // no read incrementing\r
  channel_config_set_write_increment(&c1, false);                     // no write incrementing\r
  channel_config_set_chain_to(&c1, rgb_chan_0);                       // chain to other channel\r
\r
  dma_channel_configure(\r
      rgb_chan_1,                        // Channel to be configured\r
      &c1,                               // The configuration we just created\r
      &dma_hw->ch[rgb_chan_0].read_addr, // Write address (channel 0 read address)\r
      &address_pointer,                  // Read address (POINTER TO AN ADDRESS)\r
      1,                                 // Number of transfers, in this case each is 4 byte\r
      false                              // Don't start immediately.\r
  );\r
\r
  // ===============================================\r
  // Channel 2 (sends color data to PIO VGA machine)\r
  dma_channel_config c2 = dma_channel_get_default_config(rgb_chan_2); // default configs\r
  channel_config_set_transfer_data_size(&c2, DMA_SIZE_8);             // 8-bit txfers\r
  channel_config_set_read_increment(&c2, true);                       // yes read incrementing\r
  channel_config_set_write_increment(&c2, false);                     // no write incrementing\r
  channel_config_set_dreq(&c2, DREQ_PIO0_TX3);                        // DREQ_PIO0_TX2 pacing (FIFO)\r
  channel_config_set_chain_to(&c2, rgb_chan_3);                       // chain to other channel\r
\r
  dma_channel_configure(\r
      rgb_chan_2,         // Channel to be configured\r
      &c2,                // The configuration we just created\r
      &pio->txf[rgb_sm3], // write address (RGB PIO TX FIFO)\r
      &vga_data_array,    // place holder for first load from channel one\r
      TXCOUNT,            // Number of transfers; in this case each is 1 byte.\r
      true                // Don't start immediately.\r
  );\r
\r
  // ===============================================\r
  // Channel 3 (reconfigures the channel 0 for next frame)\r
  dma_channel_config c3 = dma_channel_get_default_config(rgb_chan_3); // default configs\r
  channel_config_set_transfer_data_size(&c3, DMA_SIZE_32);            // 32-bit txfers\r
  channel_config_set_read_increment(&c3, false);                      // no read incrementing\r
  channel_config_set_write_increment(&c3, false);                     // no write incrementing\r
  channel_config_set_chain_to(&c3, rgb_chan_2);                       // chain to other channel\r
\r
  dma_channel_configure(\r
      rgb_chan_3,                        // Channel to be configured\r
      &c3,                               // The configuration we just created\r
      &dma_hw->ch[rgb_chan_2].read_addr, // Write address (channel 0 read address)\r
      &address_pointer,                  // Read address (POINTER TO AN ADDRESS)\r
      1,                                 // Number of transfers, in this case each is 4 byte\r
      true                               // Don't start immediately.\r
  );\r
}\r
\r
// A function for drawing a pixel with a specified color.\r
// Note that because information is passed to the PIO state machines through\r
// a DMA channel, we only need to modify the contents of the array and the\r
// pixels will be automatically updated on the screen.\r
void drawPixel(short x, short y, char color)\r
{\r
  // Range checks (640x480 display)\r
  if (x > 318)\r
    return;\r
  if (x < 0)\r
    return;\r
  if (y < 0)\r
    return;\r
  if (y > 239)\r
    return;\r
\r
  // Which pixel is it?\r
  int pixel = ((320 * y) + x);\r
\r
  // Draw to the back buffer\r
  draw_buffer[pixel] = color;\r
}\r
\r
// Swap the back buffer to the front buffer\r
// Call this after you've finished drawing a complete frame\r
void swapBuffers(void)\r
{\r
  for (int i = 0; i < TXCOUNT; i++)\r
  {\r
    vga_data_array[i] = vga_back_buffer[i];\r
  }\r
}\r
\r
void drawVLine(short x, short y, short h, char color)\r
{\r
  for (short i = y; i < (y + h); i++)\r
  {\r
    drawPixel(x, i, color);\r
  }\r
}\r
\r
void drawHLine(short x, short y, short w, char color)\r
{\r
  for (short i = x; i < (x + w); i++)\r
  {\r
    drawPixel(i, y, color);\r
  }\r
}\r
\r
// Bresenham's algorithm - thx wikipedia and thx Bruce!\r
void drawLine(short x0, short y0, short x1, short y1, char color)\r
{\r
  /* Draw a straight line from (x0,y0) to (x1,y1) with given color\r
   * Parameters:\r
   *      x0: x-coordinate of starting point of line. The x-coordinate of\r
   *          the top-left of the screen is 0. It increases to the right.\r
   *      y0: y-coordinate of starting point of line. The y-coordinate of\r
   *          the top-left of the screen is 0. It increases to the bottom.\r
   *      x1: x-coordinate of ending point of line. The x-coordinate of\r
   *          the top-left of the screen is 0. It increases to the right.\r
   *      y1: y-coordinate of ending point of line. The y-coordinate of\r
   *          the top-left of the screen is 0. It increases to the bottom.\r
   *      color: 3-bit color value for line\r
   */\r
  short steep = abs(y1 - y0) > abs(x1 - x0);\r
  if (steep)\r
  {\r
    swap(x0, y0);\r
    swap(x1, y1);\r
  }\r
\r
  if (x0 > x1)\r
  {\r
    swap(x0, x1);\r
    swap(y0, y1);\r
  }\r
\r
  short dx, dy;\r
  dx = x1 - x0;\r
  dy = abs(y1 - y0);\r
\r
  short err = dx / 2;\r
  short ystep;\r
\r
  if (y0 < y1)\r
  {\r
    ystep = 1;\r
  }\r
  else\r
  {\r
    ystep = -1;\r
  }\r
\r
  for (; x0 <= x1; x0++)\r
  {\r
    if (steep)\r
    {\r
      drawPixel(y0, x0, color);\r
    }\r
    else\r
    {\r
      drawPixel(x0, y0, color);\r
    }\r
    err -= dy;\r
    if (err < 0)\r
    {\r
      y0 += ystep;\r
      err += dx;\r
    }\r
  }\r
}\r
\r
// Draw a rectangle\r
void drawRect(short x, short y, short w, short h, char color)\r
{\r
  /* Draw a rectangle outline with top left vertex (x,y), width w\r
   * and height h at given color\r
   * Parameters:\r
   *      x:  x-coordinate of top-left vertex. The x-coordinate of\r
   *          the top-left of the screen is 0. It increases to the right.\r
   *      y:  y-coordinate of top-left vertex. The y-coordinate of\r
   *          the top-left of the screen is 0. It increases to the bottom.\r
   *      w:  width of the rectangle\r
   *      h:  height of the rectangle\r
   *      color:  16-bit color of the rectangle outline\r
   * Returns: Nothing\r
   */\r
  drawHLine(x, y, w, color);\r
  drawHLine(x, y + h - 1, w, color);\r
  drawVLine(x, y, h, color);\r
  drawVLine(x + w - 1, y, h, color);\r
}\r
\r
void drawCircle(short x0, short y0, short r, char color)\r
{\r
  /* Draw a circle outline with center (x0,y0) and radius r, with given color\r
   * Parameters:\r
   *      x0: x-coordinate of center of circle. The top-left of the screen\r
   *          has x-coordinate 0 and increases to the right\r
   *      y0: y-coordinate of center of circle. The top-left of the screen\r
   *          has y-coordinate 0 and increases to the bottom\r
   *      r:  radius of circle\r
   *      color: 16-bit color value for the circle. Note that the circle\r
   *          isn't filled. So, this is the color of the outline of the circle\r
   * Returns: Nothing\r
   */\r
  short f = 1 - r;\r
  short ddF_x = 1;\r
  short ddF_y = -2 * r;\r
  short x = 0;\r
  short y = r;\r
\r
  drawPixel(x0, y0 + r, color);\r
  drawPixel(x0, y0 - r, color);\r
  drawPixel(x0 + r, y0, color);\r
  drawPixel(x0 - r, y0, color);\r
\r
  while (x < y)\r
  {\r
    if (f >= 0)\r
    {\r
      y--;\r
      ddF_y += 2;\r
      f += ddF_y;\r
    }\r
    x++;\r
    ddF_x += 2;\r
    f += ddF_x;\r
\r
    drawPixel(x0 + x, y0 + y, color);\r
    drawPixel(x0 - x, y0 + y, color);\r
    drawPixel(x0 + x, y0 - y, color);\r
    drawPixel(x0 - x, y0 - y, color);\r
    drawPixel(x0 + y, y0 + x, color);\r
    drawPixel(x0 - y, y0 + x, color);\r
    drawPixel(x0 + y, y0 - x, color);\r
    drawPixel(x0 - y, y0 - x, color);\r
  }\r
}\r
\r
void drawCircleHelper(short x0, short y0, short r, unsigned char cornername, char color)\r
{\r
  // Helper function for drawing circles and circular objects\r
  short f = 1 - r;\r
  short ddF_x = 1;\r
  short ddF_y = -2 * r;\r
  short x = 0;\r
  short y = r;\r
\r
  while (x < y)\r
  {\r
    if (f >= 0)\r
    {\r
      y--;\r
      ddF_y += 2;\r
      f += ddF_y;\r
    }\r
    x++;\r
    ddF_x += 2;\r
    f += ddF_x;\r
    if (cornername & 0x4)\r
    {\r
      drawPixel(x0 + x, y0 + y, color);\r
      drawPixel(x0 + y, y0 + x, color);\r
    }\r
    if (cornername & 0x2)\r
    {\r
      drawPixel(x0 + x, y0 - y, color);\r
      drawPixel(x0 + y, y0 - x, color);\r
    }\r
    if (cornername & 0x8)\r
    {\r
      drawPixel(x0 - y, y0 + x, color);\r
      drawPixel(x0 - x, y0 + y, color);\r
    }\r
    if (cornername & 0x1)\r
    {\r
      drawPixel(x0 - y, y0 - x, color);\r
      drawPixel(x0 - x, y0 - y, color);\r
    }\r
  }\r
}\r
\r
void fillCircle(short x0, short y0, short r, char color)\r
{\r
  /* Draw a filled circle with center (x0,y0) and radius r, with given color\r
   * Parameters:\r
   *      x0: x-coordinate of center of circle. The top-left of the screen\r
   *          has x-coordinate 0 and increases to the right\r
   *      y0: y-coordinate of center of circle. The top-left of the screen\r
   *          has y-coordinate 0 and increases to the bottom\r
   *      r:  radius of circle\r
   *      color: 16-bit color value for the circle\r
   * Returns: Nothing\r
   */\r
  drawVLine(x0, y0 - r, 2 * r + 1, color);\r
  fillCircleHelper(x0, y0, r, 3, 0, color);\r
}\r
\r
void fillCircleHelper(short x0, short y0, short r, unsigned char cornername, short delta, char color)\r
{\r
  // Helper function for drawing filled circles\r
  short f = 1 - r;\r
  short ddF_x = 1;\r
  short ddF_y = -2 * r;\r
  short x = 0;\r
  short y = r;\r
\r
  while (x < y)\r
  {\r
    if (f >= 0)\r
    {\r
      y--;\r
      ddF_y += 2;\r
      f += ddF_y;\r
    }\r
    x++;\r
    ddF_x += 2;\r
    f += ddF_x;\r
\r
    if (cornername & 0x1)\r
    {\r
      drawVLine(x0 + x, y0 - y, 2 * y + 1 + delta, color);\r
      drawVLine(x0 + y, y0 - x, 2 * x + 1 + delta, color);\r
    }\r
    if (cornername & 0x2)\r
    {\r
      drawVLine(x0 - x, y0 - y, 2 * y + 1 + delta, color);\r
      drawVLine(x0 - y, y0 - x, 2 * x + 1 + delta, color);\r
    }\r
  }\r
}\r
\r
// Draw a rounded rectangle\r
void drawRoundRect(short x, short y, short w, short h, short r, char color)\r
{\r
  /* Draw a rounded rectangle outline with top left vertex (x,y), width w,\r
   * height h and radius of curvature r at given color\r
   * Parameters:\r
   *      x:  x-coordinate of top-left vertex. The x-coordinate of\r
   *          the top-left of the screen is 0. It increases to the right.\r
   *      y:  y-coordinate of top-left vertex. The y-coordinate of\r
   *          the top-left of the screen is 0. It increases to the bottom.\r
   *      w:  width of the rectangle\r
   *      h:  height of the rectangle\r
   *      color:  16-bit color of the rectangle outline\r
   * Returns: Nothing\r
   */\r
  // smarter version\r
  drawHLine(x + r, y, w - 2 * r, color);         // Top\r
  drawHLine(x + r, y + h - 1, w - 2 * r, color); // Bottom\r
  drawVLine(x, y + r, h - 2 * r, color);         // Left\r
  drawVLine(x + w - 1, y + r, h - 2 * r, color); // Right\r
  // draw four corners\r
  drawCircleHelper(x + r, y + r, r, 1, color);\r
  drawCircleHelper(x + w - r - 1, y + r, r, 2, color);\r
  drawCircleHelper(x + w - r - 1, y + h - r - 1, r, 4, color);\r
  drawCircleHelper(x + r, y + h - r - 1, r, 8, color);\r
}\r
\r
// Fill a rounded rectangle\r
void fillRoundRect(short x, short y, short w, short h, short r, char color)\r
{\r
  // smarter version\r
  fillRect(x + r, y, w - 2 * r, h, color);\r
\r
  // draw four corners\r
  fillCircleHelper(x + w - r - 1, y + r, r, 1, h - 2 * r - 1, color);\r
  fillCircleHelper(x + r, y + r, r, 2, h - 2 * r - 1, color);\r
}\r
\r
// fill a rectangle\r
void fillRect(short x, short y, short w, short h, char color)\r
{\r
  /* Draw a filled rectangle with starting top-left vertex (x,y),\r
   *  width w and height h with given color\r
   * Parameters:\r
   *      x:  x-coordinate of top-left vertex; top left of screen is x=0\r
   *              and x increases to the right\r
   *      y:  y-coordinate of top-left vertex; top left of screen is y=0\r
   *              and y increases to the bottom\r
   *      w:  width of rectangle\r
   *      h:  height of rectangle\r
   *      color:  3-bit color value\r
   * Returns:     Nothing\r
   */\r
\r
  // rudimentary clipping (drawChar w/big text requires this)\r
  // if((x >= _width) || (y >= _height)) return;\r
  // if((x + w - 1) >= _width)  w = _width  - x;\r
  // if((y + h - 1) >= _height) h = _height - y;\r
\r
  // tft_setAddrWindow(x, y, x+w-1, y+h-1);\r
\r
  for (int i = x; i < (x + w); i++)\r
  {\r
    for (int j = y; j < (y + h); j++)\r
    {\r
      drawPixel(i, j, color);\r
    }\r
  }\r
  // printf("%d\\n\\r", bit_bucket) ;\r
}\r
\r
// fill a diheredrectangle\r
void fillRectDither(short x, short y, short w, short h, char color1, char color2)\r
{\r
  //\r
  for (int i = x; i < (x + w); i++)\r
  {\r
    for (int j = y; j < (y + h); j++)\r
    {\r
      drawPixelDither(i, j, color1, color2);\r
    }\r
  }\r
}\r
\r
// Draw a character\r
void drawChar(short x, short y, unsigned char c, char color, char bg, unsigned char size)\r
{\r
  char i, j;\r
  if ((x >= _width) ||            // Clip right\r
      (y >= _height) ||           // Clip bottom\r
      ((x + 6 * size - 1) < 0) || // Clip left\r
      ((y + 8 * size - 1) < 0))   // Clip top\r
    return;\r
\r
  for (i = 0; i < 6; i++)\r
  {\r
    unsigned char line;\r
    if (i == 5)\r
      line = 0x0;\r
    else\r
      line = pgm_read_byte(font + (c * 5) + i);\r
    for (j = 0; j < 8; j++)\r
    {\r
      if (line & 0x1)\r
      {\r
        if (size == 1) // default size\r
          drawPixel(x + i, y + j, color);\r
        else\r
        { // big size\r
          fillRect(x + (i * size), y + (j * size), size, size, color);\r
        }\r
      }\r
      else if (bg != color)\r
      {\r
        if (size == 1) // default size\r
          drawPixel(x + i, y + j, bg);\r
        else\r
        { // big size\r
          fillRect(x + i * size, y + j * size, size, size, bg);\r
        }\r
      }\r
      line >>= 1;\r
    }\r
  }\r
}\r
\r
inline void setCursor(short x, short y)\r
{\r
  /* Set cursor for text to be printed\r
   * Parameters:\r
   *      x = x-coordinate of top-left of text starting\r
   *      y = y-coordinate of top-left of text starting\r
   * Returns: Nothing\r
   */\r
  cursor_x = x;\r
  cursor_y = y;\r
}\r
\r
inline void setTextSize(unsigned char s)\r
{\r
  /*Set size of text to be displayed\r
   * Parameters:\r
   *      s = text size (1 being smallest)\r
   * Returns: nothing\r
   */\r
  textsize = (s > 0) ? s : 1;\r
}\r
\r
inline void setTextColor(char c)\r
{\r
  // For 'transparent' background, we'll set the bg\r
  // to the same as fg instead of using a flag\r
  textcolor = textbgcolor = c;\r
}\r
\r
inline void setTextColor2(char c, char b)\r
{\r
  /* Set color of text to be displayed\r
   * Parameters:\r
   *      c = 16-bit color of text\r
   *      b = 16-bit color of text background\r
   */\r
  textcolor = c;\r
  textbgcolor = b;\r
}\r
\r
inline void setTextWrap(char w)\r
{\r
  wrap = w;\r
}\r
\r
void tft_write(unsigned char c)\r
{\r
  if (c == '\\n')\r
  {\r
    cursor_y += textsize * 8;\r
    cursor_x = 0;\r
  }\r
  else if (c == '\\r')\r
  {\r
    // skip em\r
  }\r
  else if (c == '\\t')\r
  {\r
    int new_x = cursor_x + tabspace;\r
    if (new_x < _width)\r
    {\r
      cursor_x = new_x;\r
    }\r
  }\r
  else\r
  {\r
    drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);\r
    cursor_x += textsize * 6;\r
    if (wrap && (cursor_x > (_width - textsize * 6)))\r
    {\r
      cursor_y += textsize * 8;\r
      cursor_x = 0;\r
    }\r
  }\r
}\r
\r
inline void writeString(char *str)\r
{\r
  /* Print text onto screen\r
   * Call tft_setCursor(), tft_setTextColor(), tft_setTextSize()\r
   *  as necessary before printing\r
   */\r
  while (*str)\r
  {\r
    tft_write(*str++);\r
  }\r
}`,cf={class:"source-code-page"},ff={class:"content-container"},df={class:"file-list"},uf=["onClick"],_f={class:"code-viewer"},hf={key:0,class:"placeholder"},pf={key:1,class:"code-container"},gf={class:"file-header"},mf={__name:"SourceCode",setup(e){const n=[{name:"balloons.c",code:rf},{name:"audio_playback.c",code:of},{name:"path_generation.c",code:sf},{name:"sprites.c",code:af},{name:"vga256_graphics.c",code:lf}],t=tt(null),r=tt("");function i(o){t.value=o,r.value=o.code}return(o,s)=>(te(),ie("div",cf,[s[1]||(s[1]=K("div",{class:"header"},[K("h1",null,"Source Code"),K("a",{href:"/",class:"back-button"}," Back to Main Page")],-1)),K("div",ff,[K("div",df,[s[0]||(s[0]=K("h2",null,"Files",-1)),K("ul",null,[(te(),ie(ge,null,Cn(n,a=>K("li",{key:a.name,class:at({active:t.value?.name===a.name}),onClick:l=>i(a)},Oe(a.name),11,uf)),64))])]),K("div",_f,[t.value?(te(),ie("div",pf,[K("div",gf,[K("h3",null,Oe(t.value.name),1)]),K("pre",null,[K("code",null,Oe(r.value),1)])])):(te(),ie("div",hf," Select a file to view its contents "))])])]))}},wf=Ht(mf,[["__scopeId","data-v-a72d56c2"]]),yf=[{path:"/",component:tf},{path:"/source-code",component:wf}],bf=Oc({history:ac(),routes:yf,scrollBehavior(e,n,t){return e.hash&&e.hash!==e.path?{el:e.hash,behavior:"smooth",top:80}:{top:0}}}),$o=bl(Dc);$o.use(bf);$o.mount("#app");</script>
    <style rel="stylesheet" crossorigin>*{margin:0;padding:0;box-sizing:border-box}:root{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;line-height:1.5;font-weight:400;color-scheme:light;color:#213547;background-color:#fff;font-synthesis:none;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}html{scroll-behavior:smooth}body{margin:0;min-width:320px;min-height:100vh}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1.2}a{font-weight:500;color:#646cff;text-decoration:inherit}a:hover{color:#535bf2}.navbar[data-v-79040f32]{position:fixed;top:0;left:0;right:0;background:linear-gradient(135deg,#667eea,#764ba2);box-shadow:0 2px 10px #0000001a;z-index:1000;padding:0 1rem}.navbar-content[data-v-79040f32]{max-width:100%;margin:0 auto;display:flex;justify-content:center;align-items:center;padding:.75rem 0;gap:1.5rem}.navbar-title[data-v-79040f32]{color:#fff;margin:0;font-size:1.3rem;font-weight:600;white-space:nowrap;flex-shrink:0}.nav-links[data-v-79040f32]{display:flex;list-style:none;margin:0;padding:0;gap:.5rem;flex-wrap:nowrap;overflow-x:auto;overflow-y:hidden;align-items:center;scrollbar-width:none;-ms-overflow-style:none}.nav-links[data-v-79040f32]::-webkit-scrollbar{display:none}.nav-links a[data-v-79040f32]{color:#ffffffe6;text-decoration:none;font-weight:500;transition:all .3s ease;padding:.4rem .6rem;border-radius:4px;position:relative;white-space:nowrap;font-size:.85rem;flex-shrink:0}.nav-links a[data-v-79040f32]:hover{color:#fff;background:#ffffff1a}.nav-links a.active[data-v-79040f32]{color:#fff;background:#fff3}.nav-links a.active[data-v-79040f32]:after{content:"";position:absolute;bottom:0;left:50%;transform:translate(-50%);width:30px;height:2px;background:#fff}@media(max-width:768px){.navbar[data-v-79040f32]{padding:0 .5rem}.navbar-content[data-v-79040f32]{gap:.75rem}.navbar-title[data-v-79040f32]{font-size:1.1rem}.nav-links a[data-v-79040f32]{padding:.3rem .5rem;font-size:.75rem}}.app[data-v-a6f11c8d]{min-height:100vh}.content[data-v-a6f11c8d]{margin-top:70px;padding:2rem;max-width:95%;width:100%;margin-left:auto;margin-right:auto}.project-header[data-v-a6f11c8d]{text-align:center;padding:3rem 0 2rem;border-bottom:2px solid #e0e0e0;margin-bottom:3rem}.project-header h1[data-v-a6f11c8d]{color:#667eea;font-size:2.8rem;margin-bottom:1rem;font-weight:700}.team-members[data-v-a6f11c8d]{color:#666;font-size:1.2rem;font-style:italic}.section[data-v-a6f11c8d]{min-height:40vh;padding:3rem 0;scroll-margin-top:80px}.section h2[data-v-a6f11c8d]{color:#667eea;font-size:2.2rem;margin-bottom:2rem;border-bottom:3px solid #667eea;padding-bottom:.5rem}.subsection[data-v-a6f11c8d]{margin-bottom:2.5rem}.subsection h3[data-v-a6f11c8d]{color:#764ba2;font-size:1.5rem;margin-bottom:1rem;font-weight:600}.subsection p[data-v-a6f11c8d]{line-height:1.8;color:#333;margin-bottom:1rem;font-size:1.05rem;white-space:pre-wrap}.note[data-v-a6f11c8d]{background:#fff3cd;border-left:4px solid #ffc107;padding:.8rem 1rem;margin-top:.5rem;border-radius:4px;color:#856404}.footer[data-v-a6f11c8d]{text-align:center;padding:2rem;color:#666;border-top:1px solid #e0e0e0;margin-top:4rem}.source-code-link[data-v-a6f11c8d]{color:#667eea;text-decoration:none;transition:color .2s ease}.source-code-link[data-v-a6f11c8d]:hover{color:#764ba2;text-decoration:underline}.images-container[data-v-a6f11c8d]{margin:2rem 0}.image-figure[data-v-a6f11c8d]{margin:2rem auto;max-width:100%;text-align:center;scroll-margin-top:100px}.content-image[data-v-a6f11c8d]{max-width:100%;height:auto;border-radius:8px;box-shadow:0 4px 12px #00000026;border:1px solid #e0e0e0;display:block;margin:0 auto}figcaption[data-v-a6f11c8d]{margin-top:.75rem;font-size:.95rem;color:#555;font-style:italic;line-height:1.5;padding:0 1rem}.subsection p[data-v-a6f11c8d] a[href^="#img-"]{color:#667eea;text-decoration:none;font-weight:600;border-bottom:1px dashed #667eea;transition:all .2s ease}.subsection p[data-v-a6f11c8d] a[href^="#img-"]:hover{color:#764ba2;border-bottom-color:#764ba2;border-bottom-style:solid}#appendix-permissions[data-v-a6f11c8d]{background:linear-gradient(135deg,#f0fdf4,#dcfce7);padding:2rem;border-radius:8px;border:2px solid #22c55e}#appendix-permissions h2[data-v-a6f11c8d]{color:#15803d;border-bottom-color:#15803d}#appendix-permissions .subsection p[data-v-a6f11c8d]{font-weight:600;color:#15803d}#references .subsection p[data-v-a6f11c8d]{font-family:Courier New,monospace;font-size:.95rem;background:#f8f9fa;padding:1rem;border-radius:4px;border-left:3px solid #667eea}@media(max-width:768px){.content[data-v-a6f11c8d]{padding:1rem;max-width:95%}.project-header h1[data-v-a6f11c8d]{font-size:2rem}.team-members[data-v-a6f11c8d]{font-size:1rem}.section[data-v-a6f11c8d]{padding:2rem 0}.section h2[data-v-a6f11c8d]{font-size:1.8rem}.subsection h3[data-v-a6f11c8d]{font-size:1.3rem}.subsection p[data-v-a6f11c8d]{font-size:1rem}.image-figure[data-v-a6f11c8d]{margin:1.5rem auto}figcaption[data-v-a6f11c8d]{font-size:.85rem;padding:0 .5rem}}@media print{.navbar[data-v-a6f11c8d]{display:none}.content[data-v-a6f11c8d]{margin-top:0;max-width:100%}.section[data-v-a6f11c8d]{page-break-inside:avoid;min-height:auto}.subsection[data-v-a6f11c8d]{page-break-inside:avoid}}.source-code-page[data-v-a72d56c2]{min-height:100vh;background:#f5f5f5}.header[data-v-a72d56c2]{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;padding:2rem;display:flex;justify-content:space-between;align-items:center;box-shadow:0 2px 8px #0000001a}.header h1[data-v-a72d56c2]{margin:0;font-size:2rem}.back-button[data-v-a72d56c2]{color:#fff;text-decoration:none;padding:.5rem 1rem;border:2px solid white;border-radius:4px;transition:all .2s ease}.back-button[data-v-a72d56c2]:hover{background:#fff;color:#667eea}.content-container[data-v-a72d56c2]{display:flex;height:calc(100vh - 120px);margin:1rem;gap:1rem}.file-list[data-v-a72d56c2]{width:250px;background:#fff;border-radius:8px;padding:1.5rem;box-shadow:0 2px 8px #0000001a;overflow-y:auto}.file-list h2[data-v-a72d56c2]{margin-top:0;color:#667eea;font-size:1.3rem;border-bottom:2px solid #667eea;padding-bottom:.5rem}.file-list ul[data-v-a72d56c2]{list-style:none;padding:0;margin:0}.file-list li[data-v-a72d56c2]{padding:.75rem 1rem;margin:.5rem 0;cursor:pointer;border-radius:4px;transition:all .2s ease;font-family:Courier New,monospace}.file-list li[data-v-a72d56c2]:hover{background:#f0f0f0}.file-list li.active[data-v-a72d56c2]{background:#667eea;color:#fff}.code-viewer[data-v-a72d56c2]{flex:1;background:#fff;border-radius:8px;box-shadow:0 2px 8px #0000001a;overflow:hidden;display:flex;flex-direction:column}.placeholder[data-v-a72d56c2],.loading[data-v-a72d56c2]{display:flex;align-items:center;justify-content:center;height:100%;font-size:1.2rem;color:#999}.code-container[data-v-a72d56c2]{display:flex;flex-direction:column;height:100%}.file-header[data-v-a72d56c2]{background:#f8f9fa;padding:1rem 1.5rem;border-bottom:1px solid #e0e0e0}.file-header h3[data-v-a72d56c2]{margin:0;color:#333;font-family:Courier New,monospace}.code-container pre[data-v-a72d56c2]{flex:1;margin:0;padding:1.5rem;overflow:auto;background:#f8f9fa}.code-container code[data-v-a72d56c2]{font-family:Courier New,monospace;font-size:.9rem;line-height:1.6;color:#333}@media(max-width:768px){.content-container[data-v-a72d56c2]{flex-direction:column;height:auto}.file-list[data-v-a72d56c2]{width:100%}.code-viewer[data-v-a72d56c2]{height:500px}}</style>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
