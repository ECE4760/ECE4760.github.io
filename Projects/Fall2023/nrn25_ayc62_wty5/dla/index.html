<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><meta content="The documentation of our DLA project." name=description><title>DLA - Documentation</title><link href=../img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=../img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=../img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Signika&display=swap" rel=stylesheet><style>body{--primary-color:#698bcf;--primary-pale-color:#698bcf1c;--text-color:#3c4043;--text-pale-color:#9aa2b9;--bg-color:#fff;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9971d9;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#4985a2;--callout-tip-color:#3ea06f;--main-font:'Signika',ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--code-font:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--homepage-max-width:750px;--main-max-width:750px;--avatar-size:70px;--paragraph-font-size:18px;--paragraph-line-height:1.75;--aside-font-size:16px;--img-border-radius:0;--inline-code-border-radius:2px}body.dark{--primary-color:#698bcf;--primary-pale-color:#698bcf1c;--text-color:#9197a5;--text-pale-color:#5d6470;--bg-color:#202124;--highlight-mark-color:#5f75b045;--callout-note-color:#698bcf;--callout-important-color:#9971d9;--callout-warning-color:#c99054;--callout-alert-color:#d35757;--callout-question-color:#4985a2;--callout-tip-color:#3ea06f}</style><link href=../main.css rel=stylesheet><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI rel=stylesheet><script crossorigin defer integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js></script><script crossorigin defer integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false},{left:'\\[',right:'\\]',display:true}],throwOnError:false})})</script><body class=prose-page><script>if(localStorage.getItem('theme')=='dark'){document.body.classList.add('dark');const a=document.querySelector('link#hl');if(a)a.href='/hl-dark.css'}</script><header class=blur><div id=header-wrapper><nav><a href=../index.html>{nathanielnrn, ayc62, wty5}</a><span class=separator>::</span><a href=../dla/index.html>DLA</a></nav><div id=btns><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button></div></div></header><div id=wrapper><main><div><div data-check-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z" fill="currentColor"></path></svg>' data-copy-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>' id=copy-cfg style=display:none></div><article data-backlink-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20"><path d="M9.41421 8L18.0208 16.6066L16.6066 18.0208L8 9.41421V17H6V6H17V8H9.41421Z" fill="currentColor"></path></svg>' class=prose><h1 id=off-grid-diffusion-limited-aggregation-on-memory-and-a-computation-constrained-microcontroller>Off-grid Diffusion Limited Aggregation on Memory and a Computation Constrained Microcontroller</h1><h2 id=project-introduction>Project Introduction</h2><p>As part of our <a rel="nofollow noreferrer" href=https://ece4760.github.io/>ECE 4760</a> final project, we created a cyclic <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Diffusion-limited_aggregation>Diffusion Limited Aggregation</a> (DLA) simulator that can be controlled via hand motions.<p>DLA is the process that simulates particles undergoing <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Brownian_motion>Brownian</a> motion that form clusters and aggregate upon collisions. Our inspiration for this project comes from both the beautiful shapes that DLA creates and the interesting natural processes that DLA models. DLA also has a multitude of scientific applications, such as modeling snowflakes, crystals, or chemical reactions. Further, we wanted users to be able to interact with characteristics of the DLA algorithm to observe how slight modificactions to parameters can have large downstream effects to emergent behavior.<p>We implemented two versions of DLA on a RP2040 microcontroller: basic off-lattice DLA, where particles stick infinitely upon aggregation, and cyclic DLA, where particles decay upon aggregation. The simulation is then displayed, real-time, on a screen via a VGA interface. The user is able to interact with the simulation using hand motions by wearing a glove with an IMU attached. Shaking and tilting their hands in various directions will cause the particles to aggregate faster or move with a bias in certain directions.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/basic.webm width=500></video><figcaption>Figure 1: Basic DLA (non-cyclic)</figcaption></figure></div><p>The following details the design of our simulator, the testing and performance of our system, and some takeaways from the project.<h2 id=high-level-design>High Level Design</h2><h4 id=rationale-and-background>Rationale and Background</h4><h4 id=brownian-motion>Brownian Motion</h4><p>DLA models aggregate particles whose primary motion is Brownian. Particles undergoing brownian motion can be modeled by moving an amount that is described by a <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Normal_distribution>normal distribution</a> whose variance is proportional to time elapsed.<p>In particular, linear Brownian motion is defined (see <a rel="nofollow noreferrer" href=https://www.stat.berkeley.edu/~aldous/205B/bmbook.pdf>page 21</a>) as motion such that for a timestep $h$ the movement of a particle described by $B(t+h) - B(t)$ is normally distributed with mean 0 and standard deviation $h.$ More explicitly this increment $X$ must be obtained with probability $$P(X=x)=\frac{1}{h \sqrt{2\pi}}e^{-\frac{1}{2}(\frac{x-0}{h})^2}.$$ We note that for our purposes $h$ is arbitrary, and dependent on our method of simulation and random number generation.<h4 id=imus>IMUs</h4><p>Inertial measurement units measure the acceleration and rotational velocity they experience. With the help of some <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/ReactionWheel/Complementary_Filters.html#Accelerometer-vs.-Gyroscope>trigonometry and filtering</a>, it is possible to determine the orientation of an IMU.<p>With this in mind, we set off to build a motion-controlled DLA simulator.<p>At a high level, our design involves 3 components:<ol><li>The RP2040 microcontroller<li>The IMU<li>The VGA display</ol><p>The IMU measures its orientation, the VGA displays the simulation, and our RP2040 both simulates and interfaces with the IMU and VGA. The mean and variance of the normal distribution used to model particles' behavior could be changed depending on the orientation and acceleration of the IMU. Concretely, this meant that we could bias particles to, on average, move in a certain direction, as well as control the simulated speed at which the particles were moving.<h4 id=hardware-software-tradeoffs>Hardware/Software Tradeoffs</h4><p>One place we encountered some tradeoffs involves the polling rate of the IMU. To an extent, we could increase the responsiveness and accuracy of our orientation measurements by polling the IMU more rapidly. However, polling the IMU takes a nontrivial amount of time. In particular, time spent reading from the IMU is time not spent simulation particle motion. After a certain point, a high polling rate led to both undesired behavior and even crashes. This is expanded upon below. We decreased the polling rate of the IMU to avoid these issues.<p>Another tradeoff we dealt with involved the amount of bits used to describe a pixel's color. We were concerned that using 8 bit color (i.e storing the color as a <code>char</code>) would make us run into memory size limitations. For this reason we used 4 bit color in our program. While it turns out that we probably would have been fine using 8-bit color, as the number of particles we used was limited by their density in our "screen-space," we had at this point made some implementation choices that would have made it difficult to transition to using 8-bit color. For this reason, we continued using 4-bit color for our project.<h4 id=existing-patents-copyrights-and-trademarks>Existing Patents, Copyrights, and Trademarks</h4><p>Regarding patents, copyrights, or trademarks, as far as we know none are applicable to this project. We've sourced all online coding resources that inspired us/were used for reference. Much of this work was enabled by some of Bruce Land's <a rel="nofollow noreferrer" href=https://people.ece.cornell.edu/land/courses/ece4760/RP2040/>C PICO SDK work</a>, without his protothread and VGA drivers this project would have been out of scope for the 5 weeks we had to complete it.<h2 id=design>Design</h2><h3 id=hardware>Hardware</h3><p>The heart of our system is a Raspberry Pi Pico, which features the RP2040 microcontroller. We implemented the circuitry for this lab using a breadboard, shown below Fig 1. Similar to previous labs, our microcontroller communicates through UART to interface with a PuTTY terminal serial interface and utilizes the Pico's PIO state machines (see <a rel="nofollow noreferrer" href=https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf>chapter 3</a>) to implement <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/VGA/VGA.html>VGA drivers</a> that allow us to visualize our simulation.<figure><img src=../dla/breadboard.png width=550><figcaption>Figure 2: An image of our physical breadboard and glove control system. The IMU is attached to the top of the glove.</figcaption></figure><p>Figure 3 below visualizes how we integrated the VGA display, RP2040, IMU (MPU 6050), and Serial interface (USB-A and PuTTY terminal) together.<figure><img src=../dla/lab4-final-dla-schematic.png width=550><figcaption>Figure 3: Schematic of our hardware setup.</figcaption></figure><p>To allow for 4 bit color with a green gradient, the VGA connection utilizes a summing circuit, as seen in Figure 3 above. We use four resistors with the approximate resistances 1R, 2R, 4R, and 8R where R $\approx$ 100, based on the resistors we had available in the course lab. Looking at Figure 3, we see that if we set all four GPIOs to high, we get the brightest green, whereas if we only set the rightmost GPIO to high, we get the dimmest green.<h3 id=software>Software</h3><p>The software we built for our simulator can be broken into a number of components. We will describe each component as it stands alone, and then describe how these components integrate together.<h4 id=random-number-generator>Random number generator</h4><p>Simulating brownian motion requires drawing from a <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Normal_distribution>normal distribution</a>. Most modern languages have implementations of functions that do this built in to their <a rel="nofollow noreferrer" href=https://cplusplus.com/reference/random/normal_distribution/>standard libraries</a>.<p>C, however, lacks such functionality.<p>What C does offer is a <a rel="nofollow noreferrer" href=https://en.cppreference.com/w/c/numeric/random/rand><code>rand()</code> function</a> that returns a value sampled from a uniform distribution between 0 and some constant <code>RAND_MAX</code>. We use this uniform distribution to approximate a normal distribution by drawing from <code>rand()</code> multiple times and updating a particle based on that value. Over many time steps, the motion of a given particle will approximate a normal distribution as a result of the <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Central_limit_theorem>Central Limit Theorem</a>. As our particles are updated 30 times a second, and the sampling distribution tends to normal over time, we can get a good approximation of brownian motion with this uniform distribution. Figure 4 shows the empirical probability distribution of displacement of a particle over 15 timesteps (equivalent to half a second), using this "sum of uniform samples" method. Figure 5 shows the empirical probability distribution of displacement of a particle over 15 timesteps sampling from a normal distribution at each time step. The distributions between each method are very similar, with our uniform distribution method being slightly biased towards the right. We believe this is an artifact of the visualization of our as our uniform distribution has integer values, and our simulation did not show any obvious tendency to positive values at runtime. The takeaway from this graph is that, over time, our particles behave as if they were moving randomly with movement at each timestep being samples from a normal distribution.<figure><img alt="A histogram. " src=../dla/nearly-uniform-distribution.png width=550><figcaption>Figure 4: A histogram visualizing the distribution of the displacement of a particle over 15 timesteps with uniformly sampled movement. Taken from 8,000 samples. The orange line is an actual normal distribution with appropriate mean and variance.</figcaption></figure><figure><img alt="A histogram. " src=../dla/normal-sums.png width=550><figcaption>Figure 5: A histogram visualizing the distribution of the displacement of a particle over 15 timesteps with normally sampled movement. Taken from 8,000 samples. The orange line is the same orange from Figure 1.</figcaption></figure><h4 id=particle-state-and-collision-detection>Particle State and Collision Detection</h4><p>Our particles consisted of <code>x</code> and <code>y</code> coordinates stored as <code>short</code>s, <code>color</code> stored as a <code>char</code>, and a <code>cyclic_counter</code> that tracked how long a particle was aggregated for. In order to minimize memory usage, our <code>color</code> member variable also acted as a way to determine if a particle was aggregated or not. Particles that were not aggregated had a color of either <code>1</code> (dimmest possible green) or <code>0</code> (black), while particles that were aggregated had colors ranging from <code>2-15</code>, (increasingly bright shades of green). All particles were stored in an array.<p>Collision detection was implemented by with the help of fixed point precision types, with 16 decimal places, a <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Alpha_max_plus_beta_min_algorithm>alpha max beta min</a> square root approximation algorithm, and our pixel backing array.<p>Our collision detector calculates the distance between a particle's current location and its new desired location using the alpha max beta min algorithm. It then uses this distance to determine an increment, which can be thought of as a vector of unit length in the direction of the particles updated location. With the help of this "increment vector", each pixel in between the particle's current location and new location is checked to see if it is touching existing aggregate or not. If a pixel is determined to be touching our aggregate, the particle is moved to that pixel (falling short of the intended update location) and it is mutated to be part of the collective aggregate (by changing its color to bright green). If the path between a particle's current location and new location is free of aggregate, the particle is moved to the intended update location and remains "active" (as opposed to aggregated).<h4 id=touching-aggregate-detection>Touching Aggregate Detection</h4><p>Recall that our aggregate consists of various shades of green (represented as <code>color</code> values from <code>2-15</code>). A pixel is deemed to be touching aggregate if the sum of the colors of the 8 pixels surrounding it surpasses some threshold. This threshold can be tuned to change the emergent behavior of aggregation, but was often left at <code>15</code> as this often produced interesting results. As an example, with a threshold of <code>15</code> a pixel would be deemed to be touching aggregate if it neighbored at least a single "bright green" pixel, or at least 2 pixels with color values of <code>8</code> (theoretically, half as bright as a "bright green"), and so on.<h4 id=angle-detection>Angle detection</h4><p>The following is adapted from our <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/Helicopter/Helicopter.html>lab 3</a> report. And is included here for completeness:<p>Our raw MPU6050 IMU measurements were received via I2C, where specific registers were read, corresponding with specific measurements of the IMU. While we initially planned to utilize the IMU's raw gyroscope measurements around the x-axis and y-axis to compute rotational deltas, we found that just using accelerometer data proved accurate enough for responsive use. Getting rid of the gyroscopic factor would reduce the computational complexity of our simulation without affecting its quality, so we opted to just use the accelerometer to determine our angle<p>Our raw accelerometer data was used to compute the angle of our lever based on an inverse tan function (see Figure 6). The raw data from our accelerometer was low passed, as noise in the raw data is amplified through the inverse tan function. See the next section for more information.<p>Figure 6 shows how accelerometer data can be used to calculate an angle of an IMU. In our case, we were interested in measuring rotation around the x and y axes. Taking the inverse tangent of acceleration in the z direction and the direction that we are <em>not</em> calculating (i.e to determine x-axis rotation we need y-axis acceleration) gives us the rotation around that axis.<figure><img alt="A lever and acceleration vectors, along with an angle theta." src=../dla/angles.png width=550><figcaption>Figure 6: An image showing how acceleration data can be used to calculate an angle. Taken from the <a href=https://vanhunteradams.com/Pico/ReactionWheel/Complementary_Filters.html>course website</a>.</figcaption></figure><h4 id=low-pass>Low pass</h4><p>The following is adapted from our <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/Helicopter/Helicopter.html>lab 3</a> report and is included for completeness:<p>A software <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/ReactionWheel/Digital_Lowpass_Filters.html>low-pass</a> filter was used on our raw accelerometer data.<p>This software filter essentially averages our readings in relation to our current data over multiple periods of time, smoothing out any high frequencies. We applied low pass filters to our accelerometer data because the effects of noise would be greatly amplified through an inverse tan function, leading to very noisy angle values.<h4 id=acceleration-variance-detection>Acceleration Variance Detection</h4><p>The variance of the acceleration in the z axis our IMU underwent over a period of 0.66 seconds was tracked. This was accomplished by maintaining a rolling average and storing the previous 20 z-acceleration values obtained from our IMU and calculating the variance of our Z acceleration: $$\text{Var}(Z) = \mathbb{E}[(Z - \mathbb{E}[Z])^2]$$<p>The variance calculation was performed naively (iterating over all values in our array), but proved fast enough to be computed in the span of a single frame.<h4 id=particle-movement>Particle Movement</h4><p>Our particle movement was implemented by moving a particle in the x and y directions an amount obtained by sampling from a uniform distribution. The <code>max_speed</code> variable is dependent on the variance of our z-acceleration. It describes the magnitude of the most a particle could move in a direction. So if <code>max_speed</code> was 6, a particle could never move more than <code>6</code> or <code>-6</code> in either direction.<p>The mean of this distribution depended on the angle of our IMU. Rotation along the y-axis of the IMU (pointing towards the screen) corresponded with the horizontal movement of our particles, and likewise for the x-axis and vertical movement. The mean of our distributions moved stepwise linearly based on the ratio of the angle of our IMU with 90. Meaning rotation around an axis of 90 degrees had a (absolute) mean of <code>(max_speed - 1) / 2</code>, while a rotation of 0 degrees (i.e the IMU was flat) had a mean of 0.<p>You may be asking why we set <code>(max_speed - 1) / 2</code> and not <code>max_speed / 2</code> when our IMU was fully rotated? This is because if we had set the mean to be exactly <code>max_speed / 2</code> our particles would have only ever moved in a single direction. This makes the movement seem un-random nature and is not satisfying to interact with. For this reason we enforced the ranges of our uniform distribution to never be higher than <code>-1</code> and never be lower than <code>1</code> (depending on the direction of tilt). This slightly changes the mean of our distribution.<h4 id=particle-decay>Particle decay</h4><p>We were interested in simulating <a rel="nofollow noreferrer" href=https://ciphrd.com/2020/07/21/cyclic-diffusion-limited-aggregation/>cyclic DLA</a>. To this end, our particle structs store a <code>cyclic_counter</code> member variable that counted the number of frames a particle had been aggregated for. The more time a particle had been aggregated for, the dimmer the aggregated particle would appear, before disappearing and returning to be a "free" particle, undergoing Brownian motion independent of the aggregate. This feature is displayed when explaining cyclic factor results.<h4 id=simulation-animation>Simulation/Animation</h4><p>30 times a second our simulation/animation <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Protothread>protothread</a> was awoken. This thread was responsible for polling our IMU, performing collision detection, updating particle locations and colors, and finally writing to our pixel backing-array. While responsible for many tasks, in practice this protothread largely consists of a bunch of function calls in a while loop. Some of these functions are guarded by flags that let us turn features (such as variable speed, tilt bias) on and off.<h4 id=serial>Serial</h4><p>Part of our simulation interfaces via <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Protocols/UART/UART.html>UART</a> to a PuTTY terminal to allow us to turn feature flags on and off, and reset our simulation. Serial runs on it's own protothread and utilizes non-blocking serial read and write functions, obtained from Bruce Land's protothreads <a rel="nofollow noreferrer" href=https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_protothreads/index_Protothreads.html>modifications</a>. These non-blocking functions rely on the RP 2040s ability to signal when UART can be written to. The thread responsible for reading/writing yields until a character can be read/written via UART, and in this way only runs when needed. This allows for computational threads (such as simulator/animator) to run almost constantly.<h4 id=bringing-it-all-together>Bringing it all together</h4><p>After initializing all of our UART and IMU GPIOs, along with our PIO state machines, our serial and simulation/animation threads are initialized. Our serial thread is non-blocking, and simply uses protothreads to output to terminal and read in to an input buffer as needed. Some logic regarding flags is contained in this thread as well. This thread is initialized on our second core.<p>Our simulation thread is initialized on our first core. In a given frame this thread polls our IMU and updates the parameters that describe our uniform distribution based on our IMUs acceleration variance and tilt. Then, two samples are drawn from our distribution and fed to our collision detector. Our collision detector updates the location and color of our particle, based on the aggregate currently present (i.e. a particle moves an amount determined by our random sampling, or collides with aggregate in the way). The particle's old location is drawn over ("erasing" it) and the particle's new location is drawn to.<p>The thread then yields such that it will awaken 1/30th of a second after the current frame begins. In this way we enforce a simulation and animation speed of 30 fps.<h2 id=testing>Testing</h2><h3 id=hardware-1>Hardware</h3><p>We had used the VGA display and the IMU, previously as part of <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/Helicopter/Helicopter.html>lab 3</a> of the course. At setup, we had to make sure the connector was wired correctly and that the receiving monitor was functional (which was not always the case). If the receiving monitor did not properly display our program, we knew that either the wiring was incorrect or the monitor had to be swapped out. Luckily, being familiar with the IMU made it easy for us to leverage its acceleration and angle capabilities.<p>When testing for user input, we wired up the UART connection to input keyboard presses using PuTTY. With this wired up, we set flags enabling/disabling specific features and tested specific elements of our hardware. As we succesfulkly interfaced with our PuTTY terminal, we were confident in the UART implementation we were <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Protocols/UART/UART.html>using</a>.<p>We did have some difficulty implementing the 4 bit green gradient as it required some additional circuits knowledge. Fortunately, the required summing circuit utilized resistors available in lab and the circuitry was not complicated. That being said, we were able to verify this 4 bit green gradient by using the VGA display and determining whether particles were properly decaying from the brightest green to the dimmest green.<h3 id=software-1>Software</h3><p>Like previous labs, we utilized serial's print capabilities to allow us to examine the values of variables in real time. Beyond that, a large amount of testing was done by looking at our IMU acceleration and complementary angle graphs to determine whether the particle motion was correct. For the features that did not utilize the IMU, their effectiveness could be verified by looking at the program and comparing it to the expected result.<h4 id=angle-graphs>Angle Graphs</h4><p>We used software (modified from <a rel="nofollow noreferrer" href=https://vanhunteradams.com/Pico/Helicopter/Display.html>here</a>) to graph the measured angle of our rotation around both the <code>x</code> and <code>y</code> axis. This allowed us to both examine the behavior of our angle measurements with respect to noise and responsiveness, and qualitatively view the effects of changes we made to our measurement algorithm. In particular, graphing proved invaluable to help us notice that changing our polling rates had down stream effects on measured angles, and required modification to our low pass algorithm to account for these changes.<p>Furthermore, our graph helped us verify that our parameter changes were behaving as expected. In particular, our graph allowed us to tell at what angle the mean of our uniform distribution shifted (which was a stepwise function). We verified that our mean shifted at the intended angles through user testing.<h4 id=simulation>Simulation</h4><p>Having an obvious visual component to our simulation made testing for its correctness easy. After making changes to our algorithms, we verified visually if our simulation behaved as expected. We compared our simulation both to other, examples of <a rel="nofollow noreferrer" href=https://isaacshaker.github.io/DLA-Simulation/>DLA</a> and to previous iterations of our own work. Examining incremental changes to our simulation algorithms helped us uncover a number of issues, described in detail below. Among the issues we discovered was a shift in the mean of the movement of our particles from conversion from fixed point to integer values, incorrect aggregation occurring at the borders of our simulation, and some issues with a naive collision detection algorithm.<h2 id=results>Results</h2><p>We visually tested our simulation with various features and parameter values. Our initial, basic DLA simulation had no motion controls and simply modeled Brownian motion aggregation of particles. Once that was complete, we tested our tilt, speed, cyclic, visibility, seed location, and reset. We found that for the space allocated in our simulation (an invisible bounding box in the snippets below), 8000 particles proved enough particles to be interesting while not creating too high of a particle density such that aggregation would occur extremely rapidly.<h4 id=basic-dla>Basic DLA</h4><p>The basic DLA motion consists of a min speed = -2 and a max speed = 2. As shown below, the clustering motion branches out evenly from the center, and matches the patterns generated by many other DLA simulators (see the References section).</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/basic.webm width=500></video><figcaption>Basic DLA</figcaption></figure></div><h4 id=tilt-factor>Tilt Factor</h4><p>Activating our tilt feature shifted the mean of the normal distribution modeling the motion of our particles, and is responsible for creating a slight bias in particles' movements. As shown below, the particles are first provided a bias to the right and then a bias to the left. A common characteristic of the tilt factor is the tendency for particles to clump into high density areas, which aggregate very rapidly once a single part of that "group" reaches some aggregate. This feature can be turned on/off via serial.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/tilt.webm width=500></video><figcaption>Hand-activated Tilt</figcaption></figure></div><h4 id=speed-factor>Speed Factor</h4><p>The speed factor, modified by the variance in acceleration in the z-direction, is responsible for increasing the min speed and max speed bounds based on the variance of the z-acceleration. In order words, the movement of the particles will increase depending on how fast the IMU-glove is shaken. This feature was responsible for the conception of the collision detection. Before the collision detection, particles with increased speeds would cluster incorrectly, skipping over aggregate particles rather colliding with them. Now, the particles are capable of reaching max speeds of around 7 As shown below, the particles are first moving very quickly as a response to the real-time IMU-glove movement. Then, the IMU-glove movement is stopped and the particles begin slowing down, showing how the particles' movement responds to dynamic hand motions. This feature is activated via serial.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/speed.webm width=500></video><figcaption>Hand-activated Speed</figcaption></figure></div><h4 id=cyclic-factor>Cyclic Factor</h4><p>The cyclic factor is responsible for decaying aggregate particles and randomly respawning them, allowing for continuous simulation. Like the other features, it is activated through serial, but an additional integer is provided to alter the decay rate. In the past, once the particles would all aggregate, the program would have to restart. As shown below, the particles decay at a rapid rate, creating a creeping motion of our aggregate throughout the screen.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/cyclic.webm width=500></video><figcaption>Cyclic DLA Motion</figcaption></figure></div><h4 id=visibility-feature>Visibility Feature</h4><p>The visibility feature is responsible for hiding all moving particles, only highlighting the aggregate particles. The result is a cleaner clustering motion as the thousands of moving particles are not shown. As shown below, the basic DLA motion is highlighted without any background movement.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/visibility.webm width=500></video><figcaption>No Background Visibility</figcaption></figure></div><h4 id=seed-location>Seed Location</h4><p>The seed location feature is responsible for adding an aggregate particle seed in a custom location. This custom location is determined in serial based on an input x and y coordinate. The custom seed is a permanent aggregate particle, allowing for more unique patterns.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/short2seeds.webm width=500></video><figcaption>Custom Seed Location</figcaption></figure></div><h4 id=reset>Reset</h4><p>The reset serial command is responsible for either committing a hard or soft reset. Turns off all activated features, while a soft reset respawns all particles, separating them from any created aggregate. Shown below is a hard reset.</p><style>.center{text-align:center}</style><div class=center><figure><video autoplay loop muted src=../dla/reset.webm width=500></video><figcaption>Resetting Particles</figcaption></figure></div><h4 id=maximum-of-particles>Maximum of Particles</h4><p>While we were capable of smoothly running 7000-8000 particles, the program is capable of running 16000 particles based on memory limitations. However, as the particle count increases, there were noticeable reductions in frame rate. This reduction is especially noticeable depending on which factors are activated. Because tilt, speed, and cyclic are computationally intensive, these factors are the computational bottleneck. Additionally, as mentioned above, running the maximum number of particles would also significantly increase the particle density, making all particles aggregate very rapidly.<h4 id=safety>Safety</h4><p>There are no significant safety concerns. A minor concern could be that waving one's hand rapidly up and down to alter the variance of z-acceleration could lead to someone getting smacked. Users should be aware their surroundings before controlling the simulation.<h4 id=usability>Usability</h4><p>Our program requires users to be able to freely move their hands to use the motion controls. However there are serial based workarounds for this. Unfortunately, the visual component of our simulation would not be very accessible for the visually impaired.<h2 id=bugs-of-note>Bugs of Note</h2><p>We detail below some of the bugs we encountered while building our simulator, how we overcame them, and any takeaways we have.<h3 id=rotten-randomness>Rotten Randomness</h3><p>Before settling on the approach of approximating a normal distribution over time by sampling from a uniform distribution, we attempted a few ways to sample from a normal distribution for every particle, once a frame. One approach involved summing over multiple calls to <code>rand()</code> in order to approximate a normal distribution within a single frame. Because this involved 10s of function calls per particle, it severely limited the speed of our due to the increased computation complexity. Another approach involved <a rel="nofollow noreferrer" href=https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_random/index_random.html>sampling a random bit</a> using the RP 2040's ring oscillator clock (ROSC). With these random bits it is possible to generate a wide variety of distributions, including a normal one. Furthermore, it is possible to perform many of the tasks required to generate a normal distribution by utilizing the RP 2040's DMA channels, at little to no cost to the CPU.<p>While the second approach in particular is attractive due to the minimal cpu overhead, testing found that the simple approach that we went with, generating a normal distribution "over time" simulated well and was both nice to interact with via motion controls, and behaved inline with other DLA simulations. For this reason we were happy to keep using <code>rand()</code> and move on to other parts of our system.<h3 id=polling-problems>Polling Problems</h3><p>Initially, polling our IMU at a rate of 1,000 Hz via a repeating alarm timer led to our simulation crashing shortly after startup. It was unclear what the root cause of these issues were, as they persisted even when moving our repeating alarm timer to a different core. Which goes against our initial suspicion that our interrupts were interfering with in-flight writes/reads to our backing pixel array, which may have eventually led to the reading of garbage data which softlocked our program.<p>To resolve this, we moved our IMU polling trigger to occur within our simulation protothread. This meant that no calculations/pixel updates could be interrupted, and guaranteed the sequentiality of our polling <code>-></code> simulate step.<p>Moving our IMU polling trigger to our simulation protothread meant that our IMU was only polled 30 times a second, as opposed to 1,000. However, we found that this frequency still provided accurate enough readings for our motion controls to feel responsive.<h3 id=bonkers-borders>Bonkers Borders</h3><p>In addition to crashes, enabling IMU polling changed the behavior of pixel aggregation, leading pixels to aggregate seemingly at random at the borders of our simulation. This was eventually resolved by adding better bounds logic to our touching-aggregate function. However it remains unclear why polling the IMU changed our collision detection logic.<h3 id=aggravating-angle-assessment>Aggravating Angle Assessment</h3><p>During testing, we noticed that if we rotated our IMU to close to 90 degrees along the x-axis, the rotational measurements of our y-axis would become inaccurate. The same occurred if we swapped the axes of rotation. We learned that using acceleration along axes is limited in that at extreme angles we lose a degree of information. Consider rotating around an axis pointed in front of you (y axis pointing forward, x-axis to the left, z-axis pointing towards the sky). Our IMU calculates rotation around the y-axis by comparing z and x-axis accelerations. Consider that if we rotate along the x axis so that our y-axis is now pointing up (z axis pointing towards us, x axis pointing to the left), rotation around the y-axis no longer changes the acceleration experienced in both the x-axis and z-axis, rather, both remain close to 0. This makes measurement of rotation around y very difficult and sensitive to noise.<p>Luckily for our project, users did not often reach rotations of 90 degrees, as doing so was quite uncomfortable with our glove. So this did not prove an issue in practice.<p><strong>Takeaway:</strong> It was discussed how in measuring rotation around 2 axes, we were essentially trying to model the IMU in 3 degrees of freedom. However, we were doing this with only 2 pieces of data in each axes: z acceleration and x/y acceleration. To this end our measurements were underdetermined, and caused the issues described above. We should aim to have fully determined systems, and if that is infeasibly be aware of the limitations of our models<h3 id=restrictive-rounding>Restrictive Rounding</h3><p>When shifting the mean of our uniform distribution based on the tilt of our IMU we performed fixed point arithmetic for the sake of computational speed, and then converted values to integers. Our initial system took into account the sign of our tilt, and shifted the mean of our distribution accordingly, based on the between our current angle and 90 degrees.<p>Because of the way our fixed to integer conversion works, numbers were rounded differently dependent on their sign. Namely, fixed point representations are converted to integers by right shifting <code>>></code>. This means that integer values are truncated, not rounded. This meant that we were taking the floor of our fixed point number. This has an effect on the magnitude of a number after truncation based on its sign. Consider that <code>4.3</code> is truncated to <code>4</code> while <code>-4.3</code> is truncated to <code>-5</code>. This, along with the details of our initial implementation, meant that our mean was incorrectly being biased towards negative numbers. This was apparent in our simulation as particles tending towards the top left, even when our IMU was held flat.<p>To fix this, we negated some fixed point numbers before truncating them and negating them again. In this way, our truncation was "symmetric" on both positive and negative fixed point numbers.<p><strong>Takeaway:</strong> Implementation matters! Especially when developing in C on things like microcontrollers, we need to be very aware of the implications of various implementations, as they can have compounding downstream effects. We were fortunate enough to figure out what was going on fairly quickly, but this may had not been obvious if we had been less aware of different number representations and how we convert between them.<h2 id=conclusion>Conclusion</h2><h4 id=improvements-and-extensions>Improvements and Extensions</h4><p>If we were to attempt this lab again, it would be interesting to continue tuning our decay and aggregation parameters that give rise to interesting emergent patterns. We were able to generate crystal-like structures as well as subtle rippling motion, but we were unable to recreate some of the patterns seen <a rel="nofollow noreferrer" href=https://ciphrd.com/2020/07/21/cyclic-diffusion-limited-aggregation/>here</a> (which helped inspire this project).<p>We could also extend some of the features we have.<p>For example, we could implement a "drawing" feature that would allow a custom aggregation seeds to be drawn on the screen based on motion controls and a cursor. The current custom seed feature is only capable of adding a single seed at a time. However, this "drawn seed" could perhaps lead to more complex cluster formations.<p>For future extensions beyond adding more DLA features, we could expand our program to highlight other particle models as well that go beyond Brownian motion. Though the DLA patterns are interesting, there are many patterns that cannot be replicated using DLA. Things like <a rel="nofollow noreferrer" href=https://core.ac.uk/download/pdf/30841042.pdf>Laplacian Growth models</a> could be used to simulate crystal growth and electrodeposition. Other mathematical models could be used to simulate fungal growth or bacteria colonies. It would be worth comparing how all the models respond to adding the existing speed, tilt, and cyclic features as well.<p>It could also be interesting to explore possible optimizations in our drivers that could help us expand our simulation. In particular we used a 320x240 size screen instead of a 640x480 screen due to memory constraints. It would be interesting to try and overcome this limitation to allow for higher resolution simulation.<h4 id=final-thoughts>Final Thoughts</h4><p>While this project integrated concepts we've learned throughout the semester in a new way, and the DLA modeling itself was the result of our own implementation. We're excited in the future to possibly build more of these components, such as the VGA driver, from scratch.<p>On a personal note, it was especially exciting to see our program in action. Seeing our project begin as an abstract and then turn into life was particularly rewarding, especially because there were many challenges along the way. The program often created patterns that were unexpected, leaving us mesmerized as we fiddled with parameters of our program.<p>As mentioned in the previous section it would be interesting (although possibly difficult) to use a more complex model of motion that could potentially lead to more life-like formations.<h4 id=intellectual-property>Intellectual Property</h4><p>There are no intellectual property concerns we are aware of. We are grateful for Bruce and Hunter's available software libraries.<h2 id=appendix>Appendix</h2><h3 id=permissions>Permissions</h3><h4 id=project-website>Project Website</h4><p>The group approves this report for inclusion on the course website.<h4 id=project-video>Project Video</h4><p>The group approves the video for inclusion on the course youtube channel.<h3 id=tasks>Tasks</h3><p>The work was largely evenly split among team members, with slight focuses on certain. The following is a non-exhaustive list of topics focused on.<p><strong>Nathaniel:</strong> Setup and dev environment, collision detection, voltage divider, website, and report.<p><strong>Angela:</strong> Collision detection, voltage divider, aggregation algorithm, website, and report.<p><strong>William:</strong> Random number generation, motion-random-distribution effects, serial, website, and report.<h3 id=references>References</h3><p><a rel="nofollow noreferrer" href=http://formandcode.com/code-examples/simulate-dla>DLA Implementation 1</a><p><a rel="nofollow noreferrer" href=https://isaacshaker.github.io/DLA-Simulation/>DLA Implementation 2</a><p><a rel="nofollow noreferrer" href=https://ciphrd.com/2020/07/21/cyclic-diffusion-limited-aggregation/>Cyclic DLA</a><p><a rel="nofollow noreferrer" href=https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_random/index_random.html>Random Bits</a><h3 id=code>Code</h3><p>Code can be found <a href=../code/index.html>here</a>.</article></div><footer><div class=copyright><p>© 2023 <your-name> <div class=credits>powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>serene</a></div> <script src=../js/lightense.min.js></script> <script src=../js/main.js></script> 
