<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw);.lst-kix_jmvkyv7bpyg1-2>li:before{content:"-  "}.lst-kix_bzonpwkky1sx-4>li:before{content:"\0025cb   "}.lst-kix_bzonpwkky1sx-6>li:before{content:"\0025cf   "}.lst-kix_jmvkyv7bpyg1-1>li:before{content:"-  "}.lst-kix_jmvkyv7bpyg1-5>li:before{content:"-  "}.lst-kix_bzonpwkky1sx-3>li:before{content:"\0025cf   "}.lst-kix_bzonpwkky1sx-7>li:before{content:"\0025cb   "}.lst-kix_bzonpwkky1sx-2>li:before{content:"\0025cb   "}.lst-kix_bzonpwkky1sx-8>li:before{content:"\0025a0   "}.lst-kix_jmvkyv7bpyg1-4>li:before{content:"-  "}.lst-kix_jmvkyv7bpyg1-3>li:before{content:"-  "}.lst-kix_bzonpwkky1sx-1>li:before{content:"\0025a0   "}ul.lst-kix_gf97ags3qw3q-6{list-style-type:none}ul.lst-kix_bzonpwkky1sx-6{list-style-type:none}ul.lst-kix_gf97ags3qw3q-7{list-style-type:none}ul.lst-kix_bzonpwkky1sx-7{list-style-type:none}ul.lst-kix_gf97ags3qw3q-8{list-style-type:none}ul.lst-kix_bzonpwkky1sx-8{list-style-type:none}ul.lst-kix_gf97ags3qw3q-2{list-style-type:none}ul.lst-kix_gf97ags3qw3q-3{list-style-type:none}.lst-kix_usixo6qiymtn-0>li:before{content:"\0025cf   "}ul.lst-kix_gf97ags3qw3q-4{list-style-type:none}ul.lst-kix_gf97ags3qw3q-5{list-style-type:none}.lst-kix_rev1ojihxyjd-8>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-8}.lst-kix_jmvkyv7bpyg1-6>li:before{content:"-  "}ul.lst-kix_gf97ags3qw3q-0{list-style-type:none}ul.lst-kix_gf97ags3qw3q-1{list-style-type:none}ul.lst-kix_8sc4iqgn9d6o-0{list-style-type:none}.lst-kix_jmvkyv7bpyg1-8>li:before{content:"-  "}ul.lst-kix_8sc4iqgn9d6o-1{list-style-type:none}.lst-kix_jmvkyv7bpyg1-7>li:before{content:"-  "}.lst-kix_bzonpwkky1sx-5>li:before{content:"\0025a0   "}ul.lst-kix_8sc4iqgn9d6o-4{list-style-type:none}ul.lst-kix_8sc4iqgn9d6o-5{list-style-type:none}.lst-kix_usixo6qiymtn-5>li:before{content:"\0025a0   "}.lst-kix_usixo6qiymtn-6>li:before{content:"\0025cf   "}ul.lst-kix_8sc4iqgn9d6o-2{list-style-type:none}ul.lst-kix_8sc4iqgn9d6o-3{list-style-type:none}ul.lst-kix_8sc4iqgn9d6o-8{list-style-type:none}.lst-kix_usixo6qiymtn-3>li:before{content:"\0025cf   "}.lst-kix_usixo6qiymtn-4>li:before{content:"\0025cb   "}.lst-kix_usixo6qiymtn-7>li:before{content:"\0025cb   "}.lst-kix_usixo6qiymtn-8>li:before{content:"\0025a0   "}ul.lst-kix_8sc4iqgn9d6o-6{list-style-type:none}ul.lst-kix_8sc4iqgn9d6o-7{list-style-type:none}ul.lst-kix_usixo6qiymtn-4{list-style-type:none}.lst-kix_usixo6qiymtn-1>li:before{content:"\0025cb   "}.lst-kix_usixo6qiymtn-2>li:before{content:"\0025a0   "}ul.lst-kix_usixo6qiymtn-3{list-style-type:none}ul.lst-kix_usixo6qiymtn-6{list-style-type:none}ul.lst-kix_usixo6qiymtn-5{list-style-type:none}ul.lst-kix_usixo6qiymtn-0{list-style-type:none}ul.lst-kix_usixo6qiymtn-2{list-style-type:none}ul.lst-kix_usixo6qiymtn-1{list-style-type:none}ol.lst-kix_rev1ojihxyjd-5.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-5 0}ul.lst-kix_35grqhytndu-0{list-style-type:none}ul.lst-kix_35grqhytndu-5{list-style-type:none}ul.lst-kix_35grqhytndu-6{list-style-type:none}ul.lst-kix_35grqhytndu-7{list-style-type:none}ul.lst-kix_35grqhytndu-8{list-style-type:none}ul.lst-kix_35grqhytndu-1{list-style-type:none}ul.lst-kix_35grqhytndu-2{list-style-type:none}ul.lst-kix_39nrc97deu5c-8{list-style-type:none}ul.lst-kix_35grqhytndu-3{list-style-type:none}ul.lst-kix_39nrc97deu5c-7{list-style-type:none}ul.lst-kix_35grqhytndu-4{list-style-type:none}ul.lst-kix_39nrc97deu5c-6{list-style-type:none}ul.lst-kix_39nrc97deu5c-5{list-style-type:none}ul.lst-kix_5z41kas6mzts-7{list-style-type:none}.lst-kix_lptbtjdtmwy2-0>li:before{content:"\0025cf   "}.lst-kix_lptbtjdtmwy2-1>li:before{content:"\0025a0   "}ul.lst-kix_39nrc97deu5c-4{list-style-type:none}ul.lst-kix_5z41kas6mzts-6{list-style-type:none}ul.lst-kix_39nrc97deu5c-3{list-style-type:none}ul.lst-kix_39nrc97deu5c-2{list-style-type:none}ul.lst-kix_5z41kas6mzts-8{list-style-type:none}ul.lst-kix_39nrc97deu5c-1{list-style-type:none}ul.lst-kix_5z41kas6mzts-3{list-style-type:none}ol.lst-kix_rev1ojihxyjd-4.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-4 0}ul.lst-kix_usixo6qiymtn-8{list-style-type:none}ul.lst-kix_39nrc97deu5c-0{list-style-type:none}ul.lst-kix_5z41kas6mzts-2{list-style-type:none}ul.lst-kix_usixo6qiymtn-7{list-style-type:none}ul.lst-kix_5z41kas6mzts-5{list-style-type:none}ul.lst-kix_5z41kas6mzts-4{list-style-type:none}ul.lst-kix_5z41kas6mzts-1{list-style-type:none}ul.lst-kix_5z41kas6mzts-0{list-style-type:none}.lst-kix_7pa0vpa04jl0-5>li:before{content:"\0025a0   "}.lst-kix_7pa0vpa04jl0-6>li:before{content:"\0025cf   "}.lst-kix_7pa0vpa04jl0-4>li:before{content:"\0025cb   "}.lst-kix_7pa0vpa04jl0-3>li:before{content:"\0025cf   "}ul.lst-kix_bzonpwkky1sx-0{list-style-type:none}ul.lst-kix_bzonpwkky1sx-1{list-style-type:none}.lst-kix_7pa0vpa04jl0-1>li:before{content:"\0025cb   "}ul.lst-kix_bzonpwkky1sx-2{list-style-type:none}ul.lst-kix_bzonpwkky1sx-3{list-style-type:none}.lst-kix_7pa0vpa04jl0-2>li:before{content:"\0025a0   "}ul.lst-kix_bzonpwkky1sx-4{list-style-type:none}ul.lst-kix_bzonpwkky1sx-5{list-style-type:none}.lst-kix_bzonpwkky1sx-0>li:before{content:"\0025cf   "}.lst-kix_7pa0vpa04jl0-0>li:before{content:"\0025cf   "}.lst-kix_rev1ojihxyjd-6>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-6}.lst-kix_jmvkyv7bpyg1-0>li:before{content:"-  "}.lst-kix_rev1ojihxyjd-3>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-3}.lst-kix_dkevq65j6l02-8>li:before{content:"\0025a0   "}.lst-kix_dkevq65j6l02-4>li:before{content:"\0025cb   "}.lst-kix_dkevq65j6l02-0>li:before{content:"\0025cf   "}.lst-kix_dkevq65j6l02-2>li:before{content:"\0025a0   "}.lst-kix_i7haiip8moea-4>li:before{content:"\0025cb   "}ol.lst-kix_rev1ojihxyjd-6.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-6 0}.lst-kix_i7haiip8moea-6>li:before{content:"\0025cf   "}.lst-kix_7pa0vpa04jl0-7>li:before{content:"\0025cb   "}.lst-kix_lptbtjdtmwy2-8>li:before{content:"\0025a0   "}.lst-kix_i7haiip8moea-8>li:before{content:"\0025a0   "}ul.lst-kix_7pa0vpa04jl0-8{list-style-type:none}ul.lst-kix_7pa0vpa04jl0-6{list-style-type:none}ul.lst-kix_7pa0vpa04jl0-7{list-style-type:none}.lst-kix_lptbtjdtmwy2-4>li:before{content:"\0025cb   "}.lst-kix_rev1ojihxyjd-1>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-1,lower-latin) ". "}.lst-kix_lptbtjdtmwy2-2>li:before{content:"\0025a0   "}.lst-kix_rev1ojihxyjd-2>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-2}ul.lst-kix_7pa0vpa04jl0-4{list-style-type:none}ul.lst-kix_7pa0vpa04jl0-5{list-style-type:none}ul.lst-kix_7pa0vpa04jl0-2{list-style-type:none}ul.lst-kix_7pa0vpa04jl0-3{list-style-type:none}.lst-kix_dkevq65j6l02-6>li:before{content:"\0025cf   "}ul.lst-kix_7pa0vpa04jl0-0{list-style-type:none}.lst-kix_lptbtjdtmwy2-6>li:before{content:"\0025cf   "}ul.lst-kix_7pa0vpa04jl0-1{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-0{list-style-type:none}ol.lst-kix_rev1ojihxyjd-8.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-8 0}ul.lst-kix_9pdsyil7n9rh-2{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-1{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-4{list-style-type:none}.lst-kix_35grqhytndu-1>li:before{content:"\0025cb   "}ul.lst-kix_9pdsyil7n9rh-3{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-6{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-5{list-style-type:none}ul.lst-kix_9pdsyil7n9rh-8{list-style-type:none}.lst-kix_fmuyws78gavy-2>li:before{content:"\0025a0   "}ul.lst-kix_9pdsyil7n9rh-7{list-style-type:none}.lst-kix_fmuyws78gavy-0>li:before{content:"\0025cf   "}.lst-kix_rev1ojihxyjd-1>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-1}.lst-kix_9pdsyil7n9rh-7>li:before{content:"\0025cb   "}.lst-kix_35grqhytndu-5>li:before{content:"\0025a0   "}.lst-kix_39nrc97deu5c-6>li:before{content:"\0025cf   "}.lst-kix_9pdsyil7n9rh-5>li:before{content:"\0025a0   "}.lst-kix_35grqhytndu-3>li:before{content:"\0025cf   "}.lst-kix_39nrc97deu5c-8>li:before{content:"\0025a0   "}.lst-kix_5z41kas6mzts-8>li:before{content:"\0025a0   "}ol.lst-kix_rev1ojihxyjd-7.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-7 0}ul.lst-kix_1xyz2ggnfdsd-8{list-style-type:none}.lst-kix_9pdsyil7n9rh-1>li:before{content:"\0025cb   "}ul.lst-kix_1xyz2ggnfdsd-7{list-style-type:none}ul.lst-kix_1xyz2ggnfdsd-6{list-style-type:none}.lst-kix_5z41kas6mzts-6>li:before{content:"\0025cf   "}ul.lst-kix_1xyz2ggnfdsd-5{list-style-type:none}ul.lst-kix_1xyz2ggnfdsd-4{list-style-type:none}.lst-kix_9pdsyil7n9rh-3>li:before{content:"\0025cf   "}ul.lst-kix_1xyz2ggnfdsd-3{list-style-type:none}ul.lst-kix_1xyz2ggnfdsd-2{list-style-type:none}ul.lst-kix_1xyz2ggnfdsd-1{list-style-type:none}.lst-kix_i7haiip8moea-2>li:before{content:"\0025a0   "}ul.lst-kix_1xyz2ggnfdsd-0{list-style-type:none}.lst-kix_5z41kas6mzts-4>li:before{content:"\0025cb   "}ul.lst-kix_ns74pjckqueo-1{list-style-type:none}.lst-kix_35grqhytndu-7>li:before{content:"\0025cb   "}.lst-kix_39nrc97deu5c-4>li:before{content:"\0025cb   "}.lst-kix_i7haiip8moea-0>li:before{content:"\0025cf   "}ul.lst-kix_ns74pjckqueo-2{list-style-type:none}ul.lst-kix_ns74pjckqueo-0{list-style-type:none}ul.lst-kix_ns74pjckqueo-5{list-style-type:none}.lst-kix_39nrc97deu5c-2>li:before{content:"\0025a0   "}ul.lst-kix_ns74pjckqueo-6{list-style-type:none}ul.lst-kix_ns74pjckqueo-3{list-style-type:none}.lst-kix_5z41kas6mzts-2>li:before{content:"\0025a0   "}ul.lst-kix_ns74pjckqueo-4{list-style-type:none}.lst-kix_39nrc97deu5c-0>li:before{content:"\0025cf   "}ul.lst-kix_ns74pjckqueo-7{list-style-type:none}ul.lst-kix_ns74pjckqueo-8{list-style-type:none}.lst-kix_5z41kas6mzts-0>li:before{content:"\0025cf   "}.lst-kix_95dd5x28ezqz-0>li:before{content:"\0025cf   "}.lst-kix_1xyz2ggnfdsd-7>li:before{content:"\0025cb   "}.lst-kix_95dd5x28ezqz-2>li:before{content:"\0025a0   "}.lst-kix_95dd5x28ezqz-3>li:before{content:"\0025cf   "}.lst-kix_95dd5x28ezqz-1>li:before{content:"\0025cb   "}.lst-kix_1xyz2ggnfdsd-8>li:before{content:"\0025a0   "}ul.lst-kix_xfs9bc5wk0kc-6{list-style-type:none}ol.lst-kix_rev1ojihxyjd-2{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-5{list-style-type:none}ol.lst-kix_rev1ojihxyjd-3{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-8{list-style-type:none}ol.lst-kix_rev1ojihxyjd-0{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-7{list-style-type:none}ol.lst-kix_rev1ojihxyjd-1{list-style-type:none}.lst-kix_ns74pjckqueo-0>li:before{content:"\0025cf   "}ul.lst-kix_xfs9bc5wk0kc-0{list-style-type:none}.lst-kix_ns74pjckqueo-1>li:before{content:"\0025cb   "}.lst-kix_ns74pjckqueo-3>li:before{content:"\0025cf   "}ul.lst-kix_xfs9bc5wk0kc-2{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-1{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-4{list-style-type:none}ul.lst-kix_xfs9bc5wk0kc-3{list-style-type:none}.lst-kix_ns74pjckqueo-2>li:before{content:"\0025a0   "}ol.lst-kix_rev1ojihxyjd-2.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-2 0}.lst-kix_ns74pjckqueo-5>li:before{content:"\0025a0   "}.lst-kix_ns74pjckqueo-7>li:before{content:"\0025cb   "}.lst-kix_ns74pjckqueo-4>li:before{content:"\0025cb   "}.lst-kix_ns74pjckqueo-8>li:before{content:"\0025a0   "}.lst-kix_fmuyws78gavy-8>li:before{content:"\0025a0   "}.lst-kix_1xyz2ggnfdsd-0>li:before{content:"\0025cf   "}.lst-kix_rev1ojihxyjd-7>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-7}.lst-kix_ns74pjckqueo-6>li:before{content:"\0025cf   "}.lst-kix_1xyz2ggnfdsd-3>li:before{content:"\0025cf   "}.lst-kix_fmuyws78gavy-6>li:before{content:"\0025cf   "}.lst-kix_fmuyws78gavy-7>li:before{content:"\0025cb   "}.lst-kix_95dd5x28ezqz-6>li:before{content:"\0025cf   "}.lst-kix_95dd5x28ezqz-7>li:before{content:"\0025cb   "}.lst-kix_1xyz2ggnfdsd-1>li:before{content:"\0025cb   "}.lst-kix_1xyz2ggnfdsd-5>li:before{content:"\0025a0   "}.lst-kix_95dd5x28ezqz-4>li:before{content:"\0025cb   "}.lst-kix_95dd5x28ezqz-8>li:before{content:"\0025a0   "}.lst-kix_1xyz2ggnfdsd-2>li:before{content:"\0025a0   "}.lst-kix_1xyz2ggnfdsd-6>li:before{content:"\0025cf   "}.lst-kix_fmuyws78gavy-3>li:before{content:"\0025cf   "}.lst-kix_fmuyws78gavy-4>li:before{content:"\0025cb   "}.lst-kix_fmuyws78gavy-5>li:before{content:"\0025a0   "}.lst-kix_95dd5x28ezqz-5>li:before{content:"\0025a0   "}.lst-kix_1xyz2ggnfdsd-4>li:before{content:"\0025cb   "}ul.lst-kix_fmuyws78gavy-2{list-style-type:none}ul.lst-kix_fmuyws78gavy-3{list-style-type:none}ul.lst-kix_fmuyws78gavy-0{list-style-type:none}ul.lst-kix_fmuyws78gavy-1{list-style-type:none}ul.lst-kix_fmuyws78gavy-6{list-style-type:none}ul.lst-kix_fmuyws78gavy-7{list-style-type:none}.lst-kix_rev1ojihxyjd-8>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-8,lower-roman) ". "}ul.lst-kix_fmuyws78gavy-4{list-style-type:none}.lst-kix_xfs9bc5wk0kc-7>li:before{content:"\0025cb   "}ul.lst-kix_fmuyws78gavy-5{list-style-type:none}ul.lst-kix_fmuyws78gavy-8{list-style-type:none}.lst-kix_xfs9bc5wk0kc-8>li:before{content:"\0025a0   "}.lst-kix_8sc4iqgn9d6o-4>li:before{content:"\0025cb   "}.lst-kix_8sc4iqgn9d6o-5>li:before{content:"\0025a0   "}.lst-kix_rev1ojihxyjd-4>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-4,lower-latin) ". "}.lst-kix_rev1ojihxyjd-5>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-5,lower-roman) ". "}.lst-kix_rev1ojihxyjd-2>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-2,lower-roman) ". "}.lst-kix_rev1ojihxyjd-3>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-3,decimal) ". "}.lst-kix_rev1ojihxyjd-6>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-6,decimal) ". "}.lst-kix_rev1ojihxyjd-7>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-7,lower-latin) ". "}.lst-kix_8sc4iqgn9d6o-8>li:before{content:"\0025a0   "}.lst-kix_gf97ags3qw3q-8>li:before{content:"-  "}.lst-kix_8sc4iqgn9d6o-7>li:before{content:"\0025cb   "}.lst-kix_gf97ags3qw3q-7>li:before{content:"-  "}.lst-kix_8sc4iqgn9d6o-6>li:before{content:"\0025cf   "}ul.lst-kix_i7haiip8moea-2{list-style-type:none}ul.lst-kix_i7haiip8moea-3{list-style-type:none}ul.lst-kix_i7haiip8moea-0{list-style-type:none}.lst-kix_gf97ags3qw3q-4>li:before{content:"-  "}.lst-kix_gf97ags3qw3q-6>li:before{content:"-  "}ul.lst-kix_i7haiip8moea-1{list-style-type:none}.lst-kix_gf97ags3qw3q-5>li:before{content:"-  "}.lst-kix_8sc4iqgn9d6o-1>li:before{content:"\0025cb   "}ol.lst-kix_rev1ojihxyjd-8{list-style-type:none}.lst-kix_gf97ags3qw3q-2>li:before{content:"-  "}.lst-kix_xfs9bc5wk0kc-1>li:before{content:"\0025cb   "}ol.lst-kix_rev1ojihxyjd-6{list-style-type:none}.lst-kix_8sc4iqgn9d6o-2>li:before{content:"\0025a0   "}.lst-kix_8sc4iqgn9d6o-3>li:before{content:"\0025cf   "}ol.lst-kix_rev1ojihxyjd-7{list-style-type:none}ol.lst-kix_rev1ojihxyjd-4{list-style-type:none}.lst-kix_gf97ags3qw3q-3>li:before{content:"-  "}.lst-kix_xfs9bc5wk0kc-0>li:before{content:"\0025cf   "}ol.lst-kix_rev1ojihxyjd-5{list-style-type:none}.lst-kix_xfs9bc5wk0kc-3>li:before{content:"\0025cf   "}.lst-kix_xfs9bc5wk0kc-5>li:before{content:"\0025a0   "}.lst-kix_gf97ags3qw3q-1>li:before{content:"-  "}.lst-kix_xfs9bc5wk0kc-2>li:before{content:"\0025a0   "}.lst-kix_xfs9bc5wk0kc-6>li:before{content:"\0025cf   "}.lst-kix_8sc4iqgn9d6o-0>li:before{content:"\0025cf   "}.lst-kix_rev1ojihxyjd-0>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-0}ul.lst-kix_i7haiip8moea-8{list-style-type:none}.lst-kix_gf97ags3qw3q-0>li:before{content:"-  "}ul.lst-kix_i7haiip8moea-6{list-style-type:none}ul.lst-kix_i7haiip8moea-7{list-style-type:none}ul.lst-kix_i7haiip8moea-4{list-style-type:none}.lst-kix_xfs9bc5wk0kc-4>li:before{content:"\0025cb   "}ul.lst-kix_i7haiip8moea-5{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-0{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-1{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-4{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-5{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-2{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-3{list-style-type:none}.lst-kix_dkevq65j6l02-5>li:before{content:"\0025a0   "}ol.lst-kix_rev1ojihxyjd-3.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-3 0}.lst-kix_dkevq65j6l02-3>li:before{content:"\0025cf   "}.lst-kix_rev1ojihxyjd-4>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-4}.lst-kix_i7haiip8moea-3>li:before{content:"\0025cf   "}.lst-kix_dkevq65j6l02-1>li:before{content:"\0025a0   "}.lst-kix_i7haiip8moea-5>li:before{content:"\0025a0   "}.lst-kix_i7haiip8moea-7>li:before{content:"\0025cb   "}.lst-kix_7pa0vpa04jl0-8>li:before{content:"\0025a0   "}.lst-kix_rev1ojihxyjd-5>li{counter-increment:lst-ctn-kix_rev1ojihxyjd-5}ul.lst-kix_dkevq65j6l02-1{list-style-type:none}.lst-kix_rev1ojihxyjd-0>li:before{content:"" counter(lst-ctn-kix_rev1ojihxyjd-0,decimal) ". "}ul.lst-kix_dkevq65j6l02-2{list-style-type:none}ul.lst-kix_dkevq65j6l02-0{list-style-type:none}ul.lst-kix_dkevq65j6l02-5{list-style-type:none}.lst-kix_lptbtjdtmwy2-3>li:before{content:"\0025cf   "}ul.lst-kix_dkevq65j6l02-6{list-style-type:none}ul.lst-kix_dkevq65j6l02-3{list-style-type:none}ul.lst-kix_dkevq65j6l02-4{list-style-type:none}ul.lst-kix_dkevq65j6l02-7{list-style-type:none}ul.lst-kix_dkevq65j6l02-8{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-8{list-style-type:none}.lst-kix_lptbtjdtmwy2-5>li:before{content:"\0025a0   "}ul.lst-kix_lptbtjdtmwy2-6{list-style-type:none}ul.lst-kix_lptbtjdtmwy2-7{list-style-type:none}.lst-kix_lptbtjdtmwy2-7>li:before{content:"\0025cb   "}.lst-kix_dkevq65j6l02-7>li:before{content:"\0025cb   "}.lst-kix_35grqhytndu-0>li:before{content:"\0025cf   "}.lst-kix_35grqhytndu-6>li:before{content:"\0025cf   "}.lst-kix_fmuyws78gavy-1>li:before{content:"\0025cb   "}.lst-kix_39nrc97deu5c-5>li:before{content:"\0025a0   "}.lst-kix_9pdsyil7n9rh-8>li:before{content:"\0025a0   "}.lst-kix_39nrc97deu5c-7>li:before{content:"\0025cb   "}.lst-kix_35grqhytndu-4>li:before{content:"\0025cb   "}ol.lst-kix_rev1ojihxyjd-1.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-1 0}.lst-kix_35grqhytndu-2>li:before{content:"\0025a0   "}.lst-kix_9pdsyil7n9rh-6>li:before{content:"\0025cf   "}ul.lst-kix_95dd5x28ezqz-1{list-style-type:none}ul.lst-kix_jmvkyv7bpyg1-2{list-style-type:none}ul.lst-kix_95dd5x28ezqz-0{list-style-type:none}.lst-kix_9pdsyil7n9rh-0>li:before{content:"\0025cf   "}ul.lst-kix_jmvkyv7bpyg1-3{list-style-type:none}ul.lst-kix_jmvkyv7bpyg1-4{list-style-type:none}.lst-kix_5z41kas6mzts-7>li:before{content:"\0025cb   "}ul.lst-kix_jmvkyv7bpyg1-5{list-style-type:none}ul.lst-kix_95dd5x28ezqz-5{list-style-type:none}ul.lst-kix_95dd5x28ezqz-4{list-style-type:none}ul.lst-kix_95dd5x28ezqz-3{list-style-type:none}ul.lst-kix_jmvkyv7bpyg1-0{list-style-type:none}ul.lst-kix_95dd5x28ezqz-2{list-style-type:none}ul.lst-kix_jmvkyv7bpyg1-1{list-style-type:none}ul.lst-kix_95dd5x28ezqz-8{list-style-type:none}.lst-kix_9pdsyil7n9rh-4>li:before{content:"\0025cb   "}ul.lst-kix_95dd5x28ezqz-7{list-style-type:none}ul.lst-kix_95dd5x28ezqz-6{list-style-type:none}.lst-kix_5z41kas6mzts-3>li:before{content:"\0025cf   "}.lst-kix_5z41kas6mzts-5>li:before{content:"\0025a0   "}ul.lst-kix_jmvkyv7bpyg1-6{list-style-type:none}.lst-kix_9pdsyil7n9rh-2>li:before{content:"\0025a0   "}ul.lst-kix_jmvkyv7bpyg1-7{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_jmvkyv7bpyg1-8{list-style-type:none}.lst-kix_35grqhytndu-8>li:before{content:"\0025a0   "}.lst-kix_i7haiip8moea-1>li:before{content:"\0025cb   "}.lst-kix_5z41kas6mzts-1>li:before{content:"\0025cb   "}.lst-kix_39nrc97deu5c-3>li:before{content:"\0025cf   "}ol.lst-kix_rev1ojihxyjd-0.start{counter-reset:lst-ctn-kix_rev1ojihxyjd-0 0}.lst-kix_39nrc97deu5c-1>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c17{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-style:normal}.c11{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.5pt;font-family:"Consolas";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times New Roman";font-style:normal}.c25{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.3571428571428572;orphans:2;widows:2;text-align:left}.c24{color:#000000;text-decoration:none;vertical-align:baseline;font-size:13pt;font-style:normal}.c20{color:#434343;text-decoration:none;vertical-align:baseline;font-size:14pt;font-style:normal}.c21{color:#000000;text-decoration:none;vertical-align:baseline;font-size:26pt}.c15{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt}.c28{color:#000000;vertical-align:baseline;font-size:12pt;font-style:normal}.c27{color:#000000;text-decoration:none;vertical-align:baseline;font-size:14pt}.c30{color:#434343;text-decoration:none;vertical-align:baseline;font-size:12pt}.c9{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c19{font-weight:700;font-family:"Times New Roman";font-style:normal}.c31{font-weight:400;font-family:"Arial";font-style:normal}.c13{font-family:"Times New Roman";color:#000000;font-weight:700}.c22{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c23{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c18{color:inherit;text-decoration:inherit}.c14{margin-left:36pt;padding-left:0pt}.c8{font-weight:400;font-family:"Times New Roman"}.c10{padding:0;margin:0}.c29{background-color:#ffffff;color:#202124}.c12{font-style:italic}.c32{font-size:13pt}.c5{background-color:#ffff00}.c3{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c22 doc-content"><p class="c25 title" id="h.h9kr35u096m3"><span class="c19 c21">Pond Water Simulation</span></p><p class="c7"><span class="c8 c32">Matthew Hui and Tomas Choi</span></p><h3 class="c11" id="h.b4pvtel1rv1t"><span class="c13">Project </span><span class="c13">Introduction</span></h3><p class="c6"><span class="c4">For our final project, we made a 2-d simulation of pond ripple behavior and simulated the natural response to skipping a rock across the water. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://www.youtube.com/watch?v%3DuaxF074Uj-o&amp;sa=D&amp;source=editors&amp;ust=1702609753223970&amp;usg=AOvVaw0aiThu3OzJB9I_0VfREZuz">https://www.youtube.com/watch?v=uaxF074Uj-o</a></span></p><p class="c7"><span class="c15 c8 c12">Video 1: Final Demo Video</span></p><p class="c0"><span class="c15 c8 c12 c5"></span></p><p class="c6"><span class="c4">For our final project, we decided to create a simulation of a small pond and the resultant behavior observed when skipping rocks. When designing the overall scope of our lab, one of the natural phenomeyna we found interesting and wanted to replicate was the ripple wave effect that is seen when dropping an object in a still lake. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 546.18px; height: 307.22px;"><img alt="" src="images/image13.png" style="width: 546.18px; height: 307.22px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8">Source: </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://savvy.directorprep.com/blog/the-ripple-effect&amp;sa=D&amp;source=editors&amp;ust=1702609753224825&amp;usg=AOvVaw3IPEixZ-xbaLQlCE0-E3KO">https://savvy.directorprep.com/blog/the-ripple-effect</a></span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Thus, for the end-goal of our project, we wanted to create some sort of simulation where we had an organic behaving pond that would respond as naturally as possible to disturbances induced by dropping in rocks in different areas of our pond. We went through several design challenges and implementation methods and ultimately settled on trying to emulate the behavior with a 2 dimensional view of a pond. With a 2 dimensional view of the pond, we simulated the perceived heights of ripples and dropped rocks using different gradients of blue and also plotted the adaptive heights along a slice of our pond to provide further context on how the heights were changing. Below depicts the end product setup we had for our simulation. </span></p><p class="c0"><span class="c4"></span></p><p class="c0"><span class="c4"></span></p><h3 class="c11" id="h.7m682ckfuf6h"><span class="c13">High Level </span><span class="c13">Design</span></h3><p class="c6"><span class="c28 c23 c8">Inspiration</span></p><p class="c6"><span class="c4">After the boids lab, we were really impressed with the computer graphics capabilities that the Pico had and how visually accurate the motions looked. When looking for a project idea, we knew we wanted to do something related to computer graphics. From the boids lab, we also saw natural patterns emerge from randomly changing certain parameters of the boids, which really shocked us and inspired us to come up with some natural behavior that could be modeled in the VGA screen. Among the many possibilities we discussed, one of them was water simulation. We thought that the best way to demonstrate a simulation is natural is by the way it interacts with stimulus, which prompted us to incorporate stone skipping into our project.</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c28 c23 c8">Background Math</span></p><p class="c6"><span class="c4">For the accurate simulation of the pond, we looked into many different equations, but we ultimately used the wave equation. More specifically, we used the discretized 2D wave equation derived by Hunter for the ECE 5760 Drum Synthesis lab. The 2D wave equation is described by </span></p><p class="c7"><img src="images/image1.png"><span class="c8 c24">,</span></p><p class="c6"><span class="c4">where &#x1d450; is the speed of sound, &#x1d702; is the viscosity coefficient, and &#x1d462; is the height of the node directed out of the plane. The equation above is the continuous wave equation, but in the application of computer graphics, we are basically drawing each node every frame to make it look like a smooth transition of motion. Therefore, we used the discretized 2D wave equation derived by Hunter. &nbsp;</span></p><p class="c7"><img src="images/image2.png"></p><p class="c6"><span class="c4">The way the discretized equation works is by calculating the next amplitude or &ldquo;height&rdquo; of the node based on its current amplitude, its past amplitude, and the amplitudes of the nodes around it. There are many constants in this equation, so for the purpose of our water simulation, we had to change these numbers to make our simulation the most visually realistic. We will discuss the implications of changing the different constants on our simulation in later sections, but the following is the final equation we used </span></p><p class="c7"><img src="images/image3.png"><span class="c4">.</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c23 c8 c28">Logical Structure</span></p><p class="c6"><span class="c4">The structure of our project involves one single directory with 3 main files: the main program that is actually ran, a mpu6050 related file that includes all the helper functions needed to control the IMU, and a VGA graphics file that includes all the helper functions needed to set up all the colors, all of which interact as shown in Figure 1. The main program uses 3 threads: one to perform all the calculations related to the unstimulated water simulation, another to interact with the VGA screen and react to stone skipping, and another to interact with the serial interface. The details of the files and the threads will be discussed in the later sections of the page. </span></p><p class="c0"><span class="c4"></span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 292.00px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 292.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 1: High Level Flowchart of Project</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c28 c23 c8">Hardware/Software Trade-Offs</span></p><p class="c6"><span class="c8">There was one significant hardware/software trade off due mainly to the memory limits of the RP2040. Our original vision of the simulation was to fill the entire VGA screen and have fish-like boids move around the water. However, after experimenting with our water simulation and the 8-bit VGA implementation, we realized that there was a limit to the amount of memory available. We kept encountering RAM issues, which we quickly narrowed down to the cause being the combination of the water simulation along with the 8-bit colors. Although we knew we could implement the fish simulation in the software, we also thought that the RAM problem was an obstacle we could not work around. Another problem we encountered was a decrease in resolution that led to one good area of the VGA screen to be unusable. If we tried to print or draw anything in the &#8533; of the right side of the VGA, we would encounter a weird issue, as shown in Figure </span><span class="c8">2</span><span class="c4">. Therefore, we settled with the water simulation and only displayed it in the portion of the VGA screen that did not cause issues. We were not extremely disappointed because our main goal of the project was to do a water simulation, which was still possible. Looking back, one way we could have dealt with the extensive memory usage of the 8-bit VGA is by reducing it to something like a 5-bit VGA and simply using 1 bit for red, 1 bit for green, and 3 bits for blue. Since we only used blue to display the water particles, the color scheme that we get from these 5 bits might have been enough to create a believable water simulation.</span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.20px; height: 317.15px;"><img alt="" src="images/image11.png" style="width: 398.20px; height: 317.15px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 2: Out of Bound Pixel Error</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c28 c23 c8">Patents/Copyrights/Trademarks</span></p><p class="c6"><span class="c8">We did not directly copy any of the code we used, but we did modify existing code written by Hunter and Bruce related to the discretized 2D wave equation and the 8-bit VGA, both of which have Cornell copyrights. Other than those, we believe our project does not have any patents, copyrights, and trademarks issues.</span></p><h3 class="c11" id="h.pniz55iypfpa"><span class="c13">Hardware </span><span class="c13">Implementation</span></h3><p class="c0"><span class="c15 c31"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 559.93px; height: 236.10px;"><img alt="" src="images/image20.png" style="width: 559.93px; height: 236.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 3: Hardware mapping of RP2040 used in the final project</span></p><p class="c0"><span class="c17 c8"></span></p><p class="c6"><span class="c23 c8">Component Description</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">The hardware in our project included several modules and components that we had used in previous lab assignments in our class including: Pi Pico, 8-Bit VGA Driver, MPU6050 Accelerometer, and a simple GPIO button. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Pi Pico: The Pi Pico microcontroller utilized the RP2040 microcontroller chip which was the main engine driving our entire simulation on our chip. The chip has dual core functionality running at speeds of up to 133MHz, 30 GPIO ports that have a variety of functions related to each, support for i2c, UART, SPI communication protocols and 264 kB of SRAM available for use. To communicate with the Pi Pico, the RP2040 C SDK was utilized. The Pi Pico and its associated pins &amp; ports are displayed above as the central figure. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">8-Bit VGA Driver: The 8-bit VGA driver is functionally similar to the previous 3 bit VGA driver utilized in previous labs with the main difference being the amount of colors we can obtain on the VGA screen. Previously with 3 bits, we were only able to obtain 8 unique colors, however for our project since we were representing depth of water with a color gradient, we needed an array of a single color gradient. With the 8-bit VGA, we instead had 256 colors at our disposal, with gradients 8 different colors for a color. Since we are allocating more bits to our coloration, we had to compensate for it with the size of our overall screen, which decreased from 640x480 resolution to 320x240 resolution. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">MPU6050 Accelerometer: The accelerometer used was the same from lab 3 since we decided to use the accelerometer component of the MPU6050 in order to determine and track hand swipes that simulated skipping stones. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">GPIO Button: The button used was very simple as it represented a basic switch, setting a line to high or low depending on if the button had been pressed or not. The actual code logic for this feature was implemented by defining the associated GPIO pin in the code as described later on. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8 c23">Setup</span></p><p class="c6"><span class="c8">As depicted in the figure above, all of the components described were connected with their respective GPIO pins. The 8-bit VGA setup required additional resistor wiring compared to the 3-bit VGA since we had to add further definition to our voltage levels. In the lab, we were unable to acquire the exact resistance values that were described in the source example created by Bruce Land, </span><span class="c8">and instead had to combine resistors in series to obtain values as close as possible. (For instance, in the case of GP11, it required 680</span><span class="c8 c29">&Omega; and in our setup we used 2 330&Omega; resistors in series, yielding us an effective resistance of 660&Omega;.) </span><span class="c8">The MPU6050 accelerometer was attached to its required pins with extended male -&gt; female pin connectors since we needed to add extra slack in our design in order to make the &ldquo;skipping rock&rdquo; component feasible. &nbsp;</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">To piece the hardware together, we took a modularized approach, adding in the new component whenever we were ready to add in the next feature. We started off with a very basic board, only containing the logic for the 3-bit VGA screen since our main concern was to determine whether or not our proposed equations and algorithm described below would work. Once we verified that we were able to obtain a working set of data, we then moved onto integrating the 8-bit VGA driver set up. This step took a while to create due to the complex nature of the appropriate resistor network set up and we spent extensive debugging time to ensure that our resistors were mapped and connected appropriately. With the visual features set up, we then integrated the MPU6050 into the project, using a similar approach to lab 3. (First ensuring that the connections were proper by testing it with a demo, then integrating it into our final project build.) The last thing that was added was our GPIO button which had a singular wiring on it. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c23 c8">Difficulties &amp; Bugs Encountered:</span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 296.00px; height: 295.00px;"><img alt="" src="images/image14.jpg" style="width: 366.00px; height: 489.00px; margin-left: -64.00px; margin-top: -98.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c15 c8 c12">Figure 3: VGA Color Bug</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Figure 3 illustrates a common bug we encountered in our design where the displayed color was the wrong gradient from what we expected. It first prompted us to look into the rgb values we were encoding, however upon further analysis of our circuit and set up, we realized that we had swapped the connections between the red and blue pins on the VGA driver resulting in the orange color scheme seen above, which also looks very cool. . </span></p><h3 class="c11" id="h.f1506j3e4tf"><span class="c13">Software Implementation</span></h3><p class="c6"><span class="c17 c8">Water Simulation </span></p><p class="c6"><span class="c4">We based our implementation of the water simulation on the ECE5760 Drum Synthesis Lab, which also used the 2D discretized wave equation. Before trying to see how the water simulation looked, we focused on getting the wave equation implemented correctly. Therefore, we implemented it in Python and we were able to visualize and debug the simulation much more easily compared to when using the VGA. The way we did this was by storing all the data into arrays and then displaying the amplitudes with different colors picture by picture. With Python, we were not able to actually simulate the water, but we were able to determine two things: what were the maximum and minimum values that worked well with the simulation and what the wave equation actually looked like visually. Although we used the Putty interface to reference data throughout the lab, these initial measurements and visualizations gave us confidence that the wave equation looked promising. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 200.50px; height: 199.56px;"><img alt="" src="images/image16.png" style="width: 200.50px; height: 199.56px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 199.50px; height: 199.50px;"><img alt="" src="images/image18.png" style="width: 199.50px; height: 199.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 197.50px; height: 200.00px;"><img alt="" src="images/image21.png" style="width: 197.50px; height: 200.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure </span><span class="c8 c12">4:</span><span class="c15 c8 c12">&nbsp;Python Simulation of 2D Discretized Wave Equation</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Therefore, we moved the water simulation implementation to a C program and initially used the 3-bit color VGA to display the water simulation. Although we were not able to accurately determine the depth of water due to the available color scheme, we did learn a couple of things. The first thing we learned was that while the water strikes looked good, the ripple effect was not as &ldquo;satisfying&rdquo;. It somehow felt that the strike was like at the top of the waterfall, but the ripple effect did not match the strength of that waterfall. Clearly, the way we debugged the water simulation portion of this project was not very &ldquo;scientific&rdquo;. Instead, we used very subjective measures that very often came from the answer to the following question: &ldquo;Does it look convincing?&rdquo;. We realized that the reason the striked looked that way was due to the way in which the ECE5760 Drum Synthesis Lab implements the strikes. It used an exponential function to map the heights of the nodes in a specific area to cause the ripple effect that came from the wave equation. In the context of drums, the exponential function made sense, but we realized that for the water simulation it was just not as convincing. Therefore, we took a more linear approach to induce the strikes. The strikes would be targeted to one specific node, and it would modify the height of every node in a radius of 5 from that node. Figure 5 contains the snippet of code to do this. The way it would modify each node was by taking the proportion of distance from the striking node, multiplying that to a specified strength, and then adding it to the height of the node. </span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 445.50px; height: 55.04px;"><img alt="" src="images/image19.png" style="width: 445.50px; height: 55.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure </span><span class="c8 c12">5:</span><span class="c15 c8 c12">&nbsp;Strike Implementation</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Thus, the strike would take the form of a pyramid. Visually, it could be imagined as a hand pulling the one water particle up and thus also stretching and pulling the water particles around it, and then letting them go to cause ripples in the water. We observed that this implementation of the strike was more visually appealing and realistic.</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Another thing we learned from translating our code to the VGA screen was that the ripples themselves would not stop for a long time and they would be too strong in areas where the striked should not have affected as much. Therefore, we recognized two problems: the unaffected nodes were interacting too closely with the nodes around them and the ripples would go on for a long time. The result of this was that the water simulation was more chaotic than natural.</span></p><p class="c7"><span class="c9 c8"><iframe class = "c18" src="https://drive.google.com/file/d/162LJTyTQsFue7x3DIzeVZVqmJWwnuW8U/preview" width="640" height="480" allow="autoplay"></iframe></span></p><p class="c7"><span class="c15 c8 c12">Video 2: Chaotic Simulation</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">We dealt with this issue by tweaking the values of some of the constants in the discretized 2D wave equation. Our final equation looked like this:</span></p><p class="c7"><img src="images/image3.png"><span class="c4">.</span></p><p class="c6"><span class="c8">The two constants that we modified in this equation were the &#8539; and the last 0.9999. In the Drum Synthesis lab code, the </span><img src="images/image4.png"><span class="c8">&nbsp;was originally a </span><img src="images/image5.png"><span class="c4">. The reason we reduced this number was because we noticed that the heights of the nodes were being impacted too much by the heights of the nodes around them, and this was causing the nodes to continuously pass on the energy they had and be a factor in the chaos described previously. The last 0.9999 was originally a 0.9998. One might think that this does not greatly affect the simulation, but it does. The last term in the equation could be considered as the energy dissipation term that allows the water simulation to look realistic in terms of its amplitude change when the pond is unaffected over a substantial period of time. By reducing the constant of dissipation even a little bit, we were able to observe the simulation take the form of what we would actually expect to see from a pond. One of the reasons we were so strict on getting this initial water simulation right was because everything we had done up to this point was to create the unstimulated pond. When we say unsimulated, we refer to no stone skipping. Although it is in motion, one could call this the static state and were of the belief that our static state had to be as perfect as possible for our whole project to be successful. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span class="c9 c8"><iframe class = "c18" src="https://drive.google.com/file/d/1bgLwkMj6y3RxRCs0Rg5eke8Xs3NhSct2/preview" width="640" height="480" allow="autoplay"></iframe></span></p><p class="c7"><span class="c15 c8 c12">Video 3: Final Water Simulation Over Time</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c17 c8">8-bit Color </span></p><p class="c6"><span class="c4">In terms of the VGA screen, we used the VGA 8-bit color version that was implemented and documented by Hunter and Bruce. We decided to use the 8 bit VGA color version because the 3 bit version that we used for our other labs only gave us one shade of blue. Since water is blue and we needed to animate different depths, the 3 bit would not do. The 8 bits VGA uses 3 bits for red, 3 bits for green, and 2 bits for blue. The new palette that we had to work with allowed us to separate the different possible heights into sections that would be matched to a certain shade of blue. This way we could simulate depth by making it darker or lighter depending on the depth of water. From the math we did and the data we were observing from the serial interface, we recognized that the maximum and minimum heights of the nodes were 0.2 and -0.2, respectively. We also had 8 shades of blue we could use, so we took full advantage of these and divided the range between 0.2 and -0.2 into different height sections, where if the node found itself in one of those sections, its color would be a specific shade of blue. For example, if the height was between 0.1 and 0.15, the node&rsquo;s color would be rgb(0, 6, 2). If the height was between -0.05 and 0, the node&rsquo;s color would be rgb(0, 3, 2). We would use lighter shades of blue for higher heights and darker shades of blue for smaller heights, so rgb(0, 6, 2) maps to a lighter blue than rgb(0, 3, 2). This way we could accurately simulate depth for our water simulation. Again, the accuracy of the simulation using color was very subjective, but we debugged using different colors and shades for different sections until we found, what we considered, the perfect divisions with the perfect shade mappings that led to the water simulation. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.00px; height: 265.93px;"><img alt="" src="images/image22.png" style="width: 239.00px; height: 265.93px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c15 c8 c12">Figure 6: Different Shades of Blue</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c23 c8">Side view of pond</span></p><p class="c6"><span class="c4">The use of the 8-bit color VGA was because we were modeling heights with color. However, in order to really visualize the water and the motions and ripples that were happening in the water simulation, we added a side view of the pond. The way it worked was by taking all the nodes at one vertical point and taking all the heights that we calculated from the wave equation at that y-point and displaying them. We would calculate the height at which to draw the vertical lines to display the pond by normalizing the value of the height to a range that could be drawn in an area in the VGA screen, as shown in Figure 7. </span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 410.50px; height: 47.37px;"><img alt="" src="images/image10.png" style="width: 410.50px; height: 47.37px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure </span><span class="c8 c12">7:</span><span class="c8 c12">&nbsp;Side View Calculation</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Because we were only displaying the nodes at one y-point, we also added a cursor that would let you determine which image of the water the user would like to display, so which y-position. The way it worked in the code was by using the button to set the cursor_height, and then drawing the nodes only in the cursor_height position, as shown below. The button presses would be registered using the gpio_set_irq_enabled_with_callback() function, so when the button was pressed, the GPIO pin corresponding to the button would register this and cause the program to go into the function down_button_pressed(), which simply </span><span class="c8">incremented</span><span class="c4">&nbsp;the cursor_height variable and redrew the cursor rectangle, as shown in Figure 8. </span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 483.50px; height: 58.86px;"><img alt="" src="images/image9.png" style="width: 483.50px; height: 58.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure </span><span class="c8 c12">8:</span><span class="c15 c8 c12">&nbsp;Side View Drawing</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">We tried different ways of displaying this side view of the pond. The two versions that we were thinking of using fillCircle or fillRect to draw the water at its height. The value of side_height would be the same for both, but we were debating which one adds the most to our water simulation. We ultimately decided to use fillRect because it displayed the water as if we were now half submerged in the pond and half not, so we could see the waves in the water and see how sometimes parts of the water were under or above the central line at 0. A very interesting phenomenon that we would observe was when there were overlapping waves, which was something we could only see with the side view. Figure 11 clearly depicts the value that this side view adds to our simulation, both for us and the person viewing the simulation.</span></p><p class="c7 c3"><span class="c16"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 509.50px; height: 85.73px;"><img alt="" src="images/image8.png" style="width: 509.50px; height: 85.73px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 9: Side View using fillCircle()</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 507.50px; height: 72.08px;"><img alt="" src="images/image12.png" style="width: 507.50px; height: 72.08px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 10: Side View using fillRect()</span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 263.13px; height: 301.50px;"><img alt="" src="images/image7.png" style="width: 263.13px; height: 301.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 11: Beautiful Side View of Pond with Many Strike Interactions</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c17 c8">Skipping Stone</span></p><p class="c6"><span class="c4">All of the computation that has been described up to this point was done in the main thread of Core 0. We also used Core 1 to deal with the skipping stone portion of the project. To skip stones, we added the IMU to our project. The first thing we did was configure the PWM to periodically prompt an interrupt. This interrupt is what would record the acceleration and gyroscope data that comes out of the IMU. This meant that every period, the program would receive the data from the IMU. The period was small enough that the program was working smoothly to human input. The RP2040 and the IMU communicated with each other through the I2C communication protocol. Therefore, data would move from the IMU to the RP2040, where we would determine whether the z-direction acceleration that we recorded was greater than 1.9G. The acceleration threshold of the IMU was 2.0G, so we tried configuring the IMU to have its threshold at 4.0G. However, we realized that it was very difficult to snap the IMU to accelerate with such a large force. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Therefore, if the program registered a z-direction acceleration greater than 1.9, the stone skipping thread in Core 1 would reuse the strike_pond() function that we used to get the static water simulation. However, the strike_pond() that we used in this thread would get a random position to throw the stone in and it would have a weaker strength parameter. Figure </span><span class="c8">5</span><span class="c8">&nbsp;shows that the strike pond function uses the strength parameter to see by how much to change the strength. We set the strength of the stone skipping strikes to be weaker than the initial &ldquo;natural&rdquo; strikes. To model stone skipping, we also animated it so that we could observe three strikes with three stone drawings with some delay so that it looks like it is one stone moving across the pond. To make it even more realistic, for each throw, we reduce each subsequent stone strength. In our case, we say that the one stone skips three times, so the first strike is strength 0.1, the second strike is strength 0.075, and the third strike is strength 0.05. Figure </span><span class="c8">12</span><span class="c8">&nbsp;shows the implementation of the randomized skipping, along with the stone animation and striking. </span></p><p class="c7 c3"><span class="c4"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 321.50px; height: 274.61px;"><img alt="" src="images/image15.png" style="width: 321.50px; height: 274.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure </span><span class="c8 c12">12:</span><span class="c8 c12 c15">&nbsp;Stone Skipping Animation</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">To summarize, the user would grab the IMU, snap it, and then the screen would display the stone moving through the water, along with the changing depths of the water at the points where the strikes happened. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span class="c9 c8"><iframe class = "c18" src="https://drive.google.com/file/d/1cflguh8zv3emZdrTiiiqBR0wmrSKc6GX/preview" width="640" height="480" allow="autoplay"></iframe></span></p><p class="c7"><span class="c8 c12">Video 4: Clear Stone Skipping</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c17 c8">Serial Communication with Putty</span></p><p class="c6"><span class="c4">We also had a separate thread that ran in Core 1 that used the UART communication protocol to communicate with the serial terminal Putty. We used it a lot throughout our debugging process, but we ultimately decided to use it to add another form of choosing which y-position to look at for the side view. One disadvantage that we observed when using the button to choose the cursor_height, we realized that it was a bit difficult to keep pressing the button to get to the other end of the pond. Therefore, the serial communication would allow us to jump between cursor heights instead of incrementing, thus making a smoother demonstration process. Putty would print out &ldquo;Input 0 for changing y-pos to look at:&rdquo; and based on the input, the variable cursor_height would change accordingly. It is worth to note that there could be extensions to our serial communication using Putty to enhance the demonstration portion of our project. For example, we could let the user set all the nodes&rsquo; height to zero or let the user strike the pond wherever they want. There are many extensions that we did not have the time to implement, but that would facilitate the process of seeing the ripples clearly. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: -0.00px 0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 385.19px; height: 217.55px;"><img alt="" src="images/image6.png" style="width: 451.64px; height: 217.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: -0.00px -0.00px; border: 1.33px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 218.45px; height: 218.45px;"><img alt="" src="images/image17.png" style="width: 218.45px; height: 218.45px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c8 c12">Figure 13: Putty Demonstration</span></p><h3 class="c11" id="h.wcg3twm93sue"><span class="c19 c27">Results</span></h3><p class="c6"><span class="c4">Overall, the end result of our project exceeded the initial expectations and vision we had for the simulation. Since we were trying to imitate a natural phenomenon, it was relatively difficult to determine and measure the accuracy and precision of our simulation. Instead, we had a holistic and subjective interpretation of the accuracy of the simulation. The main goal with our simulation was to create something that felt as organic as possible where it was difficult to tell that the simulation was dictated by equations. As a result, this required us to induce as much &ldquo;controlled chaos&rdquo; as possible which we did by including two initial &ldquo;pond drops&rdquo; in the upper left quadrant of the pond. By taking this approach, it meant that the first few seconds (~3-5) of our simulation did feel rather inorganic since the entire plane remained static at a depth of 0 as the two ripple responses propagated throughout the pond. However, once these ripples did eventually reach the border of our pond and started propagating the opposite direction, it began to look more organic. </span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span class="c9 c8"><iframe class = "c18" src="https://drive.google.com/file/d/1EDJUG7KbG5Wn3-5hNCPtMCoyb_UAkuJq/preview" width="640" height="480" allow="autoplay"></iframe></span></p><p class="c7"><span class="c15 c8 c12">Video 5: Initial Strikes (first few seconds of animation)</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Even though we were able to emulate a pretty realistic pond, since we are still using equations to govern the behavior of the depth of things, there were still some cases where it was obvious that the observed behavior was not intended. This was especially noticeable when our algorithm would propagate the pond upwards and simultaneously we would strike the pond, which immediately decreases the depth of the pond. This immediate reduction sometimes caused parts of the pond to instantly reverse colors, appearing as if someone had pressed a rewind button in the middle of our simulation. (This behavior was very uncommon so we did not decide to take it into consideration when tuning our system.)</span></p><p class="c0"><span class="c4"></span></p><p class="c7"><span class="c9 c8"><iframe class = "c18" src="https://drive.google.com/file/d/1CeF7371rzYUt7imc1eASxDEzJYslUAjz/preview" width="640" height="480" allow="autoplay"></iframe></span></p><p class="c7"><span class="c15 c8 c12">Video 6: Reversal Behavior</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Despite these minor drawbacks to our simulation, the overall response and behavior of our system worked well. </span><span class="c8">According </span><span class="c4">to the feedback we received from people who tested out our simulation, they noted that the rock skipping response looked very nice as sometimes they were able to notice the ripple waves really propagate throughout the pond. Additionally, they noted that the bottom graph we had to display a horizontal slice of the varying heights was very helpful to better understand what the changing colors in our pond simulation above represented. However, when showing it to people, we did receive feedback that even though they were snapping the IMU, the water simulation was not displaying the three ripples. We took into consideration and analyzed why this behavior was occurring. Even though the ripples were not appearing, the rock simulation was, which meant that the stone skipping functions were all called. We realized that when the heights of the water were already low enough, the strikes did not alter the height of the pond since it was just keeping those nodes at their original heights. Although it did not look as we intended, it made sense in the &ldquo;natural&rdquo; sense, so we did not modify it. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">In terms of enforcing safety in design, there were two aspects we had to take into consideration; the physical hardware safety, and also the design of our code. Since we were mostly working with things that did not require insane amounts of power or current, putting everything together on one board and close to each other was a valid design approach. (We did not need to isolate any system from another.) As per our code, we did have to take into consideration some elements of concurrency in our design, making sure that we did not have two threads or two methods operating on the same code space. (We made sure that only one method would update a variable, and all other threads would only read that variable to reduce the probability of running into race conditions.) </span></p><h3 class="c11" id="h.vcqfpymryu7w"><span class="c13">Conclusion</span></h3><p class="c6"><span class="c8 c17">General Reflections and Learnings</span></p><p class="c6"><span class="c4">This final project proved to be filled with numerous challenges and also a great deal of research of new topics that we had not previously seen. We felt that our final simulation massively exceeded our expectations as we felt that we created a pond simulation that accurately represented what someone would see if they were to skip rocks on a pond. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c8">Throughout this project, we learned a lot about the hardware and software we used in the first couple of labs. We had to experiment with the hsync.pio, vsync.pio, and vga256_graphics.c files to accurately understand how the color mappings worked and how the Lab 2 VGA files differed from the 8-bit color VGA files. We also got a better understanding of how the PWM worked and why we used it in Lab 3. We realized its usefulness when trying to induce periodic interrupt signals that substantially reduce the computation needed to be done by the cores, but still accurately registers data induced by human input. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c17 c8">Further Improvements</span></p><p class="c6"><span class="c4">We felt that we wouldn&rsquo;t do things differently in the future as the end product exceeded expectations, but there are plenty of things we would further incorporate to improve our simulation. Currently, our rock strikes were very uniform as it would always strike down in a pyramid shape with linearly changing depths. To increase variability, it would be interesting to observe what would happen if we had some other nonlinear strike to see how the responses would change. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Another feature we could add which would improve the &ldquo;accuracy&rdquo; of our pond would be to add in obstacles in the pond (like a large boulder in different areas) where it would add additional boundaries where the ripple response would bounce off of, increasing the variability once again. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c4">Additionally, we could make the entire project into a small game where there would be an actual character on the screen. Outside the water, there could be grass, and the character would be able to move around the grass and pick up stones. Then, with the stones that it picked up, the character could skip stone. If the character runs out of stones, it will need to go pick up more. At that point, the game could expand anywhere and many cool new capabilities could be added. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c23 c8">Intellectual Property Considerations</span></p><p class="c6"><span class="c4">Most of our code was created by ourselves, with the exceptions of some formulas to model the wave equation that were taken from the ECE 5760 drum lab source code. We also did follow some hardware layout from Bruce Land&rsquo;s 8-Bit VGA driver demo which was provided on our course website. Aside from these, everything else was original. </span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c23 c8">Conformation to Standards</span></p><p class="c6"><span class="c8">To our knowledge, our project did not violate any applicable standards or other codes of conducts relating to project development using </span><span class="c8">microcontrollers. </span></p><h3 class="c11" id="h.blh0vcbq23wg"><span class="c13">Appendix A - Approvals</span></h3><p class="c6"><span class="c28 c23 c8">Inclusion on course page</span></p><p class="c6"><span class="c4">The group approves this report for inclusion on the course website.</span></p><p class="c0"><span class="c4"></span></p><p class="c6"><span class="c17 c8">Inclusion on YouTube channel</span></p><p class="c6"><span class="c8">The group does not approve the video for inclusion on the course youtube channel.</span></p><h3 class="c11" id="h.nfwtuadi4hh8"><span class="c13">Appendix B - Task Division</span></h3><p class="c6"><span class="c4">For the final project, we did a lot of pair programming together and also worked on the lab separately at times. The following represents the general breakdown of the delegation of tasks:</span></p><p class="c0"><span class="c4"></span></p><ul class="c10 lst-kix_jmvkyv7bpyg1-0 start"><li class="c6 c14 li-bullet-0"><span class="c4">Tomas: IMU Integration, Rock Animation &amp; Behavior, Graphics Refinement, Side View graph</span></li></ul><ul class="c10 lst-kix_gf97ags3qw3q-0 start"><li class="c6 c14 li-bullet-0"><span class="c8">Matthew: Strike &amp; Wave Equation Setup, 8-bit VGA Setup, GPIO Button </span></li></ul><h3 class="c11" id="h.1cjqhfhr9ilx"><span class="c27 c19">Appendix C - References</span></h3><ul class="c10 lst-kix_8sc4iqgn9d6o-0 start"><li class="c6 c14 li-bullet-0"><span class="c8">2D Discretized Wave Equation - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://vanhunteradams.com/DE1/Drum/Discretization.html&amp;sa=D&amp;source=editors&amp;ust=1702609753296883&amp;usg=AOvVaw00Mq_y-YBFZPxedLgjJBSX">https://vanhunteradams.com/DE1/Drum/Discretization.html</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">8-bit VGA - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_vga256/index_vga_256.html&amp;sa=D&amp;source=editors&amp;ust=1702609753297323&amp;usg=AOvVaw12p1QpaMxoS1D_N-4vL6FZ">https://people.ece.cornell.edu/land/courses/ece4760/RP2040/C_SDK_vga256/index_vga_256.html</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">5760 Drum Synthesis Lab - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://vanhunteradams.com/DE1/Drum/Drum_synthesis.html&amp;sa=D&amp;source=editors&amp;ust=1702609753297749&amp;usg=AOvVaw2DH8UtwtVgrDnNei2cMCtU">https://vanhunteradams.com/DE1/Drum/Drum_synthesis.html</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">UART Communication - </span><span class="c8 c9"><a class="c18" href="https://www.google.com/url?q=https://vanhunteradams.com/Protocols/UART/UART.html&amp;sa=D&amp;source=editors&amp;ust=1702609753298216&amp;usg=AOvVaw01J4oKtzBcIXnxGjtpLD3w">https://vanhunteradams.com/Protocols/UART/UART.html</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">I2C Communication - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://vanhunteradams.com/Protocols/I2C/I2C.html&amp;sa=D&amp;source=editors&amp;ust=1702609753298548&amp;usg=AOvVaw22xm0Vst7_MtbPBHUx-tLm">https://vanhunteradams.com/Protocols/I2C/I2C.html</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">RP2040 Datasheet - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf&amp;sa=D&amp;source=editors&amp;ust=1702609753298886&amp;usg=AOvVaw38dcRLZs-MeT003o5KBk3y">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">MPU6050 - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://learn.adafruit.com/mpu6050-6-dof-accelerometer-and-gyro&amp;sa=D&amp;source=editors&amp;ust=1702609753299208&amp;usg=AOvVaw1MNcxYQnTegfwr2stK8w4N">https://learn.adafruit.com/mpu6050-6-dof-accelerometer-and-gyro</a></span></li><li class="c6 c14 li-bullet-0"><span class="c8">VGA Driver - </span><span class="c9 c8"><a class="c18" href="https://www.google.com/url?q=https://vanhunteradams.com/Pico/VGA/VGA.html&amp;sa=D&amp;source=editors&amp;ust=1702609753299506&amp;usg=AOvVaw2cM2sdukLgEbj8IxMWoFGq">https://vanhunteradams.com/Pico/VGA/VGA.html</a></span></li></ul><h3 class="c11" id="h.t2orr3cvmyam"><span class="c27 c19">Appendix D - Code </span></h3><p class="c0"><span class="c15 c31"></span></p><p class="c2"><span class="c1">/* &nbsp;ECE 4760 Final Project - Pond Water Animation</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;Tomas Choi (tic3) and Matthew Hui (mmh257)</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;HARDWARE CONNECTIONS</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;8-bit VGA Driver connections</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;Source: Bruce Land</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 16 ---&gt; VGA Hsync</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 17 ---&gt; VGA Vsync</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 08 ---&gt; 330 ohm resistor ---&gt; VGA Blue lo-bit |__ both wired to 150 ohm to ground</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 09 ---&gt; 220 ohm resistor ---&gt; VGA Blue hi_bit | and to VGA blue</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 10 ---&gt; 1000 ohm resistor ---&gt; VGA Green lo-bit |__ three resistors wired to 100 ohm to ground</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 11 ---&gt; 680 ohm resistor ---&gt; VGA Green mid_bit | and to VGA Green</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 12 ---&gt; 330 ohm resistor ----&gt; VGA Green hi_bit |</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 13 ---&gt; 1000 ohm resistor ---&gt; VGA Red lo-bit |__ three resistors wired to 100 ohm to ground</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 14 ---&gt; 680 ohm resistor ---&gt; VGA Red mid_bit | and to VGA red</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 15 ---&gt; 330 ohm resistor ----&gt; VGA Red hi_bit |</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- RP2040 GND ---&gt; VGA GND</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;MPU6050 Accelerometer Connections:</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 26 ---&gt; MPU6050 SDA</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- GPIO 27---&gt; MPU6050 SCL</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- 3.3v ---&gt; MPU6050 VCC</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- RP2040 GND ---&gt; MPU6050 GND</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;Serial Terminal Connections:</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;GPIO 0 ---&gt; White</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;GPIO 1 ---&gt; Green</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;RP2040 GND ---&gt; GND</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;GPIO Button Connections:</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;GPIO 21 ---&gt; button</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;RP2040 GND ---&gt; button</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;--------------</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;* RESOURCES USED</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- PIO state machines 0, 1, and 2 on PIO instance 0</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- DMA channels 0, 1</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- 153.6 kBytes of RAM (for pixel color data)</span></p><p class="c2"><span class="c1">&nbsp;* &nbsp;- Numerous GPIO Channels listed above</span></p><p class="c2"><span class="c1">&nbsp;*</span></p><p class="c2"><span class="c1">&nbsp;*/</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Include the VGA grahics library</span></p><p class="c2"><span class="c1">#include &quot;vga256_graphics.h&quot;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Include standard libraries</span></p><p class="c2"><span class="c1">#include &lt;stdio.h&gt;</span></p><p class="c2"><span class="c1">#include &lt;stdlib.h&gt;</span></p><p class="c2"><span class="c1">#include &lt;math.h&gt;</span></p><p class="c2"><span class="c1">#include &lt;string.h&gt;</span></p><p class="c2"><span class="c1">// Include Pico libraries</span></p><p class="c2"><span class="c1">#include &quot;pico/stdlib.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;pico/divider.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;pico/multicore.h&quot;</span></p><p class="c2"><span class="c1">// Include hardware libraries</span></p><p class="c2"><span class="c1">#include &quot;hardware/pio.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/dma.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/clocks.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/irq.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/adc.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/i2c.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/pwm.h&quot;</span></p><p class="c2"><span class="c1">#include &quot;hardware/spi.h&quot;</span></p><p class="c2"><span class="c1">// Include protothreads</span></p><p class="c2"><span class="c1">#include &quot;pt_cornell_rp2040_v1_1_1.h&quot;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Include MPU6050 library</span></p><p class="c2"><span class="c1">#include &quot;mpu6050.h&quot;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// === the fixed point macros ========================================</span></p><p class="c2"><span class="c1">typedef signed int fix15;</span></p><p class="c2"><span class="c1">#define multfix15(a, b) ((fix15)((((signed long long)(a)) * ((signed long long)(b))) &gt;&gt; 15))</span></p><p class="c2"><span class="c1">#define float2fix15(a) ((fix15)((a)*32768.0)) // 2^15</span></p><p class="c2"><span class="c1">#define fix2float15(a) ((float)(a) / 32768.0)</span></p><p class="c2"><span class="c1">#define absfix15(a) abs(a)</span></p><p class="c2"><span class="c1">#define int2fix15(a) ((fix15)(a &lt;&lt; 15))</span></p><p class="c2"><span class="c1">#define fix2int15(a) ((int)(a &gt;&gt; 15))</span></p><p class="c2"><span class="c1">#define char2fix15(a) (fix15)(((fix15)(a)) &lt;&lt; 15)</span></p><p class="c2"><span class="c1">#define divfix(a, b) (fix15)(div_s64s64((((signed long long)(a)) &lt;&lt; 15), ((signed long long)(b))))</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// drum-specific multiply macros simulated by shifts</span></p><p class="c2"><span class="c1">#define times0pt5(a) ((a) &gt;&gt; 1)</span></p><p class="c2"><span class="c1">#define times0pt25(a) ((a) &gt;&gt; 2)</span></p><p class="c2"><span class="c1">#define times2pt0(a) ((a) &lt;&lt; 1)</span></p><p class="c2"><span class="c1">#define times4pt0(a) ((a) &lt;&lt; 2)</span></p><p class="c2"><span class="c1">#define times0pt9998(a) ((a) - ((a) &gt;&gt; 12)) //&gt;&gt;10</span></p><p class="c2"><span class="c1">#define times0pt9999(a) ((a) - ((a) &gt;&gt; 13)) //&gt;&gt;10</span></p><p class="c2"><span class="c1">#define times0pt999(a) ((a) - ((a) &gt;&gt; 10)) &nbsp;//&gt;&gt;10</span></p><p class="c2"><span class="c1">#define times_rho(a) (((a) &gt;&gt; 3)) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //&gt;&gt;2</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Frame Rate to assist with tracking time spent in threads</span></p><p class="c2"><span class="c1">#define FRAME_RATE 33000</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Created pixel struct to store information on each pixel</span></p><p class="c2"><span class="c1">typedef struct</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; fix15 x_pos;</span></p><p class="c2"><span class="c1">&nbsp; fix15 y_pos;</span></p><p class="c2"><span class="c1">&nbsp; fix15 height_n; &nbsp; //current height</span></p><p class="c2"><span class="c1">&nbsp; fix15 height_n_1; //previous height</span></p><p class="c2"><span class="c1">&nbsp; fix15 new_height; //newly calculated height</span></p><p class="c2"><span class="c1">&nbsp; char color;</span></p><p class="c2"><span class="c1">} pixel;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Drum sizing parameters from ECE5760 Lab 3</span></p><p class="c2"><span class="c1">// drum will FAIL if size is too big</span></p><p class="c2"><span class="c1">// Determined drum_size experimentally, looking for the maximum value before we exceeded the ram limits</span></p><p class="c2"><span class="c1">#define drum_size 85</span></p><p class="c2"><span class="c1">#define drum_middle 15</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Number of total pixels in the simulation: 85x85</span></p><p class="c2"><span class="c1">#define num_pixels 7225</span></p><p class="c2"><span class="c1">pixel pond[drum_size][drum_size]; //30x30 board for now</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// state variables for pond calculations</span></p><p class="c2"><span class="c1">fix15 new_pond_temp;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//Counter variable for the timer stuff</span></p><p class="c2"><span class="c1">int time_count = 0;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Variable used to keep track of text to write onto the VGA Screen</span></p><p class="c2"><span class="c1">char text[50];</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Arrays in which raw measurements will be stored</span></p><p class="c2"><span class="c1">fix15 acceleration[3], gyro[3];</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// semaphore</span></p><p class="c2"><span class="c1">static struct pt_sem vga_semaphore ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Some paramters for PWM</span></p><p class="c2"><span class="c1">#define WRAPVAL 5000</span></p><p class="c2"><span class="c1">#define CLKDIV &nbsp;25.0</span></p><p class="c2"><span class="c1">uint slice_num ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// State variables used in the side view rendering</span></p><p class="c2"><span class="c1">// Keeps track of the current y-axis level view of the pond</span></p><p class="c2"><span class="c1">int cursor_height = 40;</span></p><p class="c2"><span class="c1">// Temporary variable keeping track of heights from the side view</span></p><p class="c2"><span class="c1">fix15 side_height[drum_size];</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// GPIO Button routine: Moves the cursor height down by 1, once we reach the end</span></p><p class="c2"><span class="c1">// of the pond, it wraps back towards the top resetting it to a height of 0.</span></p><p class="c2"><span class="c1">void down_button_pressed () {</span></p><p class="c2"><span class="c1">&nbsp;</span></p><p class="c2"><span class="c1">&nbsp; cursor_height++;</span></p><p class="c2"><span class="c1">&nbsp; if (cursor_height &gt; 2*85){</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; cursor_height = 0;</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; fillRect (100, 170, 170, 50, BLACK);</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Interrupt service routine for MPU6050</span></p><p class="c2"><span class="c1">void on_pwm_wrap() {</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Clear the interrupt flag that brought us here</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; pwm_clear_irq(pwm_gpio_to_slice_num(19));</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Read the IMU</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; mpu6050_read_raw(acceleration, gyro);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Signal VGA to draw</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; PT_SEM_SIGNAL(pt, &amp;vga_semaphore);</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//Initializing the pond board to a base shade of blue - rgb(0, 3, 2)</span></p><p class="c2"><span class="c1">void init_board()</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; for (int i = 0; i &lt; drum_size; i++)</span></p><p class="c2"><span class="c1">&nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; for (int j = 0; j &lt; drum_size; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //Start off with spacing them 1 pixel apart</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].x_pos = int2fix15(100 + 2 * i);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].y_pos = int2fix15(2 * j);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].height_n = int2fix15(0);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].height_n_1 = int2fix15(0);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].new_height = int2fix15(0);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 3, 2); //start off blue</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; fillRect(fix2int15(pond[i][j].x_pos), fix2int15(pond[i][j].y_pos), 2, 2, rgb(0, 3, 2));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Water strike method - visualized as setting an area in the pond to some arbitrary pyramid like height shape</span></p><p class="c2"><span class="c1">// Takes in 3 parameters:</span></p><p class="c2"><span class="c1">// int x, y: Coordinates of the strike location</span></p><p class="c2"><span class="c1">// float strength: The maximum height the middle of the strike will be, should range between [0,1]</span></p><p class="c2"><span class="c1">// Note: The method is additive, adding the strike height onto the existing pixels, with</span></p><p class="c2"><span class="c1">// the strike strength descending linearly from the central strike onto the neighboring 5 pixels</span></p><p class="c2"><span class="c1">void strike_pond(int x, int y, float strength)</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; //Initial setup variables</span></p><p class="c2"><span class="c1">&nbsp; static int i = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int j = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int squared_distance = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int x_dist = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int y_dist = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int dist_level = 0;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; static float new_height = 0;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //NOTE: i -&gt; y coordinates, j -&gt; x coordinates</span></p><p class="c2"><span class="c1">&nbsp; //Looping through the current pixels in the pond, setting the peaks of the values</span></p><p class="c2"><span class="c1">&nbsp; //The value of the peaks will range from [-1,1]</span></p><p class="c2"><span class="c1">&nbsp; for (i = 0; i &lt; drum_size; i++)</span></p><p class="c2"><span class="c1">&nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; for (j = 0; j &lt; drum_size; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; x_dist = abs(i - x);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; y_dist = abs(j - y);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; dist_level = fmax(x_dist, y_dist);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //Checks for the pixels that are within a 5 pixel radius (Manhattan Distance)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; if (dist_level &lt;= 5)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; new_height = (float)(5 - dist_level) / 5.0 * strength;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].height_n = float2fix15(fix2float15(pond[i][j].height_n) + new_height);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].height_n_1 = float2fix15(fix2float15(pond[i][j].height_n_1) + new_height);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Helper method: Deep copy information from height_n_1 onto height_n.</span></p><p class="c2"><span class="c1">// Utilized since deep copying needs to occur once we fully modify every pixel in the pond</span></p><p class="c2"><span class="c1">// in its current state</span></p><p class="c2"><span class="c1">void copy_data()</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; static int i = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int j = 0;</span></p><p class="c2"><span class="c1">&nbsp; for (i = 0; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; for (j = 0; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].height_n_1 = pond[i][j].height_n;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].height_n = pond[i][j].new_height;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Updating Pond Method: Performs the wave equation algorithm onto the entire</span></p><p class="c2"><span class="c1">// pond, updating the values based on neighboring ones and any strikes on the pond.</span></p><p class="c2"><span class="c1">// The magnitude of heights will range between [-1,1]</span></p><p class="c2"><span class="c1">void update_pond()</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; static int i = 0;</span></p><p class="c2"><span class="c1">&nbsp; static int j = 0;</span></p><p class="c2"><span class="c1">&nbsp; //Iterate through all the pixels EXCEPT the right and bottom wall</span></p><p class="c2"><span class="c1">&nbsp; for (i = 1; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; for (j = 1; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //Wave equation logic</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; new_pond_temp = times_rho(pond[i - 1][j].height_n + pond[i + 1][j].height_n + pond[i][j - 1].height_n + pond[i][j + 1].height_n - times4pt0(pond[i][j].height_n));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; pond[i][j].new_height = times0pt9999(new_pond_temp + times2pt0(pond[i][j].height_n) - times0pt9998(pond[i][j].height_n_1));</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //Coloration setting logic: Setting the color of a pixel based on its height</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; if (pond[i][j].height_n &gt; float2fix15(0.15) &amp;&amp; pond[i][j].height_n &lt; float2fix15(0.2))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 7, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(0.1) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(0.15))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 6, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(0.05) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(0.10))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 5, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(0.0) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(0.05))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 4, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(-0.05) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(0))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 3, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(-0.1) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(-0.05))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 2, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(-0.15) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(-0.10))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 1, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else if (pond[i][j].height_n &gt; float2fix15(-0.2) &amp;&amp; pond[i][j].height_n &lt;= float2fix15(-0.15))</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 0, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; else</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; pond[i][j].color = rgb(0, 5, 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //Copy over the values from height_n_1 to height_n</span></p><p class="c2"><span class="c1">&nbsp; copy_data();</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Helper Method: Drawing the top down view of our pond in the top half</span></p><p class="c2"><span class="c1">// of the screen. Loops through every single pixel and draws a rectangle</span></p><p class="c2"><span class="c1">// with the corresponding rectangle and color.</span></p><p class="c2"><span class="c1">void draw_pond_top() {</span></p><p class="c2"><span class="c1">&nbsp; for (int i = 0; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fillRect(fix2int15(pond[i][j].x_pos), fix2int15(pond[i][j].y_pos), 2, 2, pond[i][j].color);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Helper Method: Drawing the side view of our pond.</span></p><p class="c2"><span class="c1">// Parameter:</span></p><p class="c2"><span class="c1">// int y_coord: Takes in the y-coordinate representing the slice of the pond to visualize</span></p><p class="c2"><span class="c1">void draw_pond_front(int y_coord) {</span></p><p class="c2"><span class="c1">&nbsp; //Normalize and scale the height data onto our margins for the graph and convert it to the</span></p><p class="c2"><span class="c1">&nbsp; //appropriate y-position on the VGA Screen representing this.</span></p><p class="c2"><span class="c1">&nbsp; for (int i = 0; i &lt; drum_size; i++) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Using y = 200 as a midpoint for our graph, 40 pixels of room above and 40 below.</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; side_height[i] = int2fix15(200) - multfix15(divfix(pond[i][y_coord].height_n, float2fix15(0.2)), int2fix15(225));</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //Drawing the side view of the pond</span></p><p class="c2"><span class="c1">&nbsp; for (int i = 1; i &lt; drum_size-1; i++) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Clears the previous rendering</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; fillRect(100 + 2*i, 170, 2, 100, BLACK);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Draws in a line with the new rendering/height</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; fillRect(100 + i*2, &nbsp;fix2int15(side_height[i]), 2, 300 - fix2int15(side_height[i]), rgb(0, 3, 2));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Commented out, but only drew the square at the heights intead of a line downwards to obtain a</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //different view</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // fillRect(2*i, fix2int15(side_height[i]), 2, 2,rgb(0, 3, 2));</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">// Basic pond animation thread</span></p><p class="c2"><span class="c1">static PT_THREAD(protothread_anim(struct pt *pt))</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; PT_BEGIN(pt);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // Variables for maintaining frame rate</span></p><p class="c2"><span class="c1">&nbsp; static int begin_time ;</span></p><p class="c2"><span class="c1">&nbsp; static int spare_time ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //Initial pond</span></p><p class="c2"><span class="c1">&nbsp; init_board();</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //Adding Text</span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 80);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(WHITE);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;Top View: &quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 200);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(WHITE);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;Side View: &quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //More text representing the title of the project</span></p><p class="c2"><span class="c1">&nbsp; drawRoundRect(26, 16, 67, 45, 1, GREEN);</span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 20);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(GREEN);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;ECE4760:&quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 30);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(GREEN);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;Pond&quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 40);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(GREEN);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;Water&quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2"><span class="c1">&nbsp; setCursor(30, 50);</span></p><p class="c2"><span class="c1">&nbsp; setTextSize(1);</span></p><p class="c2"><span class="c1">&nbsp; setTextColor(GREEN);</span></p><p class="c2"><span class="c1">&nbsp; sprintf(text, &quot;Simulation&quot;);</span></p><p class="c2"><span class="c1">&nbsp; writeString(text);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; while (1)</span></p><p class="c2"><span class="c1">&nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Measure time at start of thread</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; begin_time = time_us_32() ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Cursor</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; fillRect(100 + 85*2, 0, 30, 200, BLACK);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; fillRect(100 + 85*2, cursor_height, 10, 2, RED);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Drawing in the cursor height number next to the cursor</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; setCursor(100 + 85*2 + 10 + 5, cursor_height - 2);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; setTextColor(RED);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; sprintf(text, &quot;%d&quot;, cursor_height);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; writeString(text);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Every 10,000 counts of the thread, we strike the pond twice in the upper left</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //quadrant which will provide us with a steady level of chaos induced into our system.</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; if (time_count == 0) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; strike_pond(20, 0, 0.3);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; strike_pond(0, 40, 0.3);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; update_pond();</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; time_count++;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; if (time_count == 10000) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; time_count = 0;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Calls the draw methods to draw the top and side views</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; draw_pond_top();</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; draw_pond_front(cursor_height);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; spare_time = FRAME_RATE - (time_us_32() - begin_time) ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // yield for necessary amount of time</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; PT_YIELD_usec(spare_time) ;</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; PT_END(pt);</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//Serial thread to ask for user to inputs to change</span></p><p class="c2"><span class="c1">//cursor value/location</span></p><p class="c2"><span class="c1">static PT_THREAD(protothread_serial(struct pt *pt))</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; PT_BEGIN(pt);</span></p><p class="c2"><span class="c1">&nbsp; // stores user input</span></p><p class="c2"><span class="c1">&nbsp; static int user_input ;</span></p><p class="c2"><span class="c1">&nbsp; static int parameter_input ;</span></p><p class="c2"><span class="c1">&nbsp; static float float_input ;</span></p><p class="c2"><span class="c1">&nbsp; // wait for 0.1 sec</span></p><p class="c2"><span class="c1">&nbsp; PT_YIELD_usec(1000000) ;</span></p><p class="c2"><span class="c1">&nbsp; // announce the threader version</span></p><p class="c2"><span class="c1">&nbsp; sprintf(pt_serial_out_buffer, &quot;Protothreads RP2040 v1.0\n\r&quot;);</span></p><p class="c2"><span class="c1">&nbsp; // non-blocking write</span></p><p class="c2"><span class="c1">&nbsp; serial_write ;</span></p><p class="c2"><span class="c1">&nbsp; while(1) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // // print prompt</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; sprintf(pt_serial_out_buffer, &quot;Input 0 for changing y-pos to look at: &quot;);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // non-blocking write</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; serial_write ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // spawn a thread to do the non-blocking serial read</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; serial_read ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // convert input string to number</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; sscanf(pt_serial_in_buffer,&quot;%d&quot;, &amp;user_input) ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // update boundary condition</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; if (user_input == 0) {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; sprintf(pt_serial_out_buffer, &quot;Input y-pos to look at: &quot;);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; // non-blocking write</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; serial_write ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; // spawn a thread to do the non-blocking serial read</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; serial_read ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; // convert input string to number</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; sscanf(pt_serial_in_buffer,&quot;%d&quot;, &amp;user_input) ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; cursor_height = user_input;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; // END WHILE(1)</span></p><p class="c2"><span class="c1">&nbsp; PT_END(pt);</span></p><p class="c2"><span class="c1">&nbsp; }</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//VGA Display drawing thread</span></p><p class="c2"><span class="c1">static PT_THREAD (protothread_vga(struct pt *pt))</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Indicate start of thread</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; PT_BEGIN(pt) ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Control rate of drawing</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; static int throttle ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Draw the static aspects of the display</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; setTextSize(1) ;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; setTextColor(WHITE);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; //Random number generated variables</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; static int rand_y = 0;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; while (true) {</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; // Wait on semaphore</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; PT_SEM_WAIT(pt, &amp;vga_semaphore);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //Determining if our measured acceleration is above a threshold before drawing our</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; //rock skips</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; if (fix2float15(acceleration[2]) &gt;= 1.99){</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Random logic to determine the random y location to begin our skips</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; rand_y = rand() % 60 + 10;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Draws the first rock in the skip cycle and strikes</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fillCircle(100 + 2*65, 2*rand_y, 3, rgb(2, 0, 0));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(250);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; strike_pond(65, rand_y, 0.1);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_pond();</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Updates colors around it</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i!=65) fillRect(fix2int15(pond[i][j].x_pos), fix2int15(pond[i][j].y_pos), 2, 2, pond[i][j].color);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; draw_pond_front(cursor_height);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Sleeps for 400ms before skipping to the next rock</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(400);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Draws the second rock in the skip cycle and strikes it with a little less power</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fillCircle(100 + 2*40, 2*rand_y, 3, rgb(2, 0, 0));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(250);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; strike_pond(40, rand_y, 0.075);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_pond();</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i!=40) fillRect(fix2int15(pond[i][j].x_pos), fix2int15(pond[i][j].y_pos), 2, 2, pond[i][j].color);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; draw_pond_front(cursor_height);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(400);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; //Draws the final rock in the cycle with the least amount of strength</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; fillCircle(100 + 2*15, 2*rand_y, 3, rgb(2, 0, 0));</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(250);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; strike_pond(15, rand_y, 0.05);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; update_pond();</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; drum_size - 1; i++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; drum_size - 1; j++)</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i!=15) fillRect(fix2int15(pond[i][j].x_pos), fix2int15(pond[i][j].y_pos), 2, 2, pond[i][j].color);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; draw_pond_front(cursor_height);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; sleep_ms(400);</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; // Indicate end of thread</span></p><p class="c2"><span class="c1">&nbsp; &nbsp; PT_END(pt);</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//Second core used to animate the rock throwing animations, and also the serial threads</span></p><p class="c2"><span class="c1">void core1_main()</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; // Add animation thread</span></p><p class="c2"><span class="c1">&nbsp; pt_add_thread(protothread_vga);</span></p><p class="c2"><span class="c1">&nbsp; pt_add_thread(protothread_serial);</span></p><p class="c2"><span class="c1">&nbsp; // Start the scheduler</span></p><p class="c2"><span class="c1">&nbsp; pt_schedule_start;</span></p><p class="c2"><span class="c1">}</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">//Main method</span></p><p class="c2"><span class="c1">int main()</span></p><p class="c2"><span class="c1">{</span></p><p class="c2"><span class="c1">&nbsp; // initializing stio</span></p><p class="c2"><span class="c1">&nbsp; stdio_init_all();</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // initializing the VGA</span></p><p class="c2"><span class="c1">&nbsp; initVGA();</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; ////////////////////////////////////////////////////////////////////////</span></p><p class="c2"><span class="c1">&nbsp; ///////////////////////// I2C CONFIGURATION ////////////////////////////</span></p><p class="c2"><span class="c1">&nbsp; i2c_init(I2C_CHAN, I2C_BAUD_RATE) ;</span></p><p class="c2"><span class="c1">&nbsp; gpio_set_function(SDA_PIN, GPIO_FUNC_I2C) ;</span></p><p class="c2"><span class="c1">&nbsp; gpio_set_function(SCL_PIN, GPIO_FUNC_I2C) ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // MPU6050 initialization</span></p><p class="c2"><span class="c1">&nbsp; mpu6050_reset();</span></p><p class="c2"><span class="c1">&nbsp; mpu6050_read_raw(acceleration, gyro);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; ////////////////////////////////////////////////////////////////////////</span></p><p class="c2"><span class="c1">&nbsp; ///////////////////////// PWM CONFIGURATION ////////////////////////////</span></p><p class="c2"><span class="c1">&nbsp; ////////////////////////////////////////////////////////////////////////</span></p><p class="c2"><span class="c1">&nbsp; // Tell GPIO&#39;s 19,18 that they allocated to the PWM</span></p><p class="c2"><span class="c1">&nbsp; gpio_set_function(19, GPIO_FUNC_PWM);</span></p><p class="c2"><span class="c1">&nbsp; gpio_set_function(18, GPIO_FUNC_PWM);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // Find out which PWM slice is connected to GPIO 19 (it&#39;s slice 2, same for 18)</span></p><p class="c2"><span class="c1">&nbsp; slice_num = pwm_gpio_to_slice_num(19);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // Mask our slice&#39;s IRQ output into the PWM block&#39;s single interrupt line,</span></p><p class="c2"><span class="c1">&nbsp; // and register our interrupt handler</span></p><p class="c2"><span class="c1">&nbsp; pwm_clear_irq(slice_num);</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_irq_enabled(slice_num, true);</span></p><p class="c2"><span class="c1">&nbsp; irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);</span></p><p class="c2"><span class="c1">&nbsp; irq_set_enabled(PWM_IRQ_WRAP, true);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // This section configures the period of the PWM signals</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_wrap(slice_num, WRAPVAL) ;</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_clkdiv(slice_num, CLKDIV) ;</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // This sets duty cycle</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_chan_level(slice_num, PWM_CHAN_B, 0);</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_chan_level(slice_num, PWM_CHAN_A, 0);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // Start the channel</span></p><p class="c2"><span class="c1">&nbsp; pwm_set_mask_enabled((1u &lt;&lt; slice_num));</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // Button pressing gpio</span></p><p class="c2"><span class="c1">&nbsp; gpio_set_irq_enabled_with_callback(21, GPIO_IRQ_EDGE_RISE, true, &amp;down_button_pressed);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // start core 1</span></p><p class="c2"><span class="c1">&nbsp; multicore_reset_core1();</span></p><p class="c2"><span class="c1">&nbsp; multicore_launch_core1(&amp;core1_main);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; //Add thread to the core 0</span></p><p class="c2"><span class="c1">&nbsp; pt_add_thread(protothread_anim);</span></p><p class="c2 c3"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp; // starting the thread scheduler</span></p><p class="c2"><span class="c1">&nbsp; pt_schedule_start;</span></p><p class="c2"><span class="c1">}</span></p><p class="c0"><span class="c4"></span></p></body></html>