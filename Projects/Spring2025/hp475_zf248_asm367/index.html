<!DOCTYPE html>
<html lang="en">
<head>
<style>
  img {
    display: block;
    margin-left: auto;
    margin-right: auto;
    max-width: 100%;
    height: auto;
  }

  img + p, p:has(img) {
    text-align: center;
  }

  table {
    margin-left: auto;
    margin-right: auto;
  }

  table + p {
    text-align: center;
  }

  p {
    text-align: justify;
  }
</style>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Raspberry Pi Pico Based Table Tennis Game on VGA Display</title>
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
    <header>
        <h1>Raspberry Pi Pico Based Table Tennis Game on VGA Display</h1>
        <h2>ECE5730 - Digital Systems Design Using Microcontrollers</h2>
        <h3>Final Project - Spring 2025</h3>
        <h3>Anushka Mathew asm367, Zhixing Fan zf248, Harsh Panara hp475</h3>
    </header>

    <nav>
	<a href="#Objective">Objective</a>
	<a href="#projectvideo">Project Video</a>
        <a href="#introduction">Introduction</a>
        <a href="#design">High Level Design</a>
        <a href="#programdesign">Program Hardware Design</a>
        <a href="#problems-faced">Problems Faced</a>
        <a href="#results">Results</a>
	<a href="#conclusion">Conclusion</a>
        <a href="#future-work">Future Work</a>
	<a href="#work-distribution">Work Distribution</a>
        <a href="#appendix">Appendix</a>
    </nav>

    <div class="container">
	<section id="Objective">
<h2>Objective</h2>
	<p>To design and develop an immersive, gesture-controlled two-player table tennis game on VGA with real-time sound feedback and intuitive glove-based play using the Raspberry Pi Pico and MPU6050 IMUs to make it challenging as well as fun.</p>
	</section>
	<section id="projectvideo">
  <h2>Project Video</h2>
  <div style="text-align:center;">
    <iframe width="560" height="315" 
      src="https://www.youtube.com/embed/A9CqhP-DgnU" 
      title="YouTube video player" 
      frameborder="0" 
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
      allowfullscreen>
    </iframe>
  </div>
</section>
        <section id="introduction">
            <h2>Introduction</h2>
            <p>
                This project aims to create a classic Pong game similar to Table Tennis on a VGA display using the Raspberry Pi Pico. The game involves two paddles and a ball that bounces around the screen, requiring players to hit the ball back and forth. The system should generate a stable VGA signal directly from the Pico, detect paddle movements using the imu setup attached to the players glove, handle ball physics, and update the score dynamically. The project will leverage Pico's programmable I/O (PIO) for generating VGA signals efficiently while managing game logic in real-time. This project involved developing a two-player interactive table tennis game displayed on a VGA screen, with motion controls using gloves embedded with IMUs (Inertial Measurement Units).</p>
<p>
The system is powered by a single Raspberry Pi Pico (RP2040) microcontroller. Players control their paddles by moving their hands, and gameplay is enhanced with audio feedback triggered via DMA whenever the ball hits the paddle or the screen boundaries. The game includes a start screen, a win condition of first to win three rounds, and real-time responsiveness. The primary objective was to explore creative human-computer interaction methods and optimize real-time game rendering and audio processing on constrained hardware.
            </p>
        </section>

        <section id="design">
            <h2>High- Level Design</h2>
            <p>
                The idea originated from the classic game Ping Pong, enhanced with modern human interaction specifically, wearable motion control. Inspired by virtual reality glove inputs and retro VGA games, we aimed to combine graphics with intuitive modern controls. Our primary source of design influence was lab-based microcontrollers projects involving the Raspberry Pi Pico, VGA signal generation, IMU integration and sound generation.</p>
<p>
IMU data (accelerometer and gyroscope values) were converted into relative paddle positions using vector arithmetic and simple filtering to smooth out jitter. Collision detection between the ball and paddles and boundaries was implemented. Ball trajectory involved calculating basic linear kinematics with reflection logic for paddle and wall interactions.
            </p>
	<h3>Spin Physics and Background Math</h3>
<p>In both real-world table tennis and this digital simulation, the Magnus effect is essential for producing realistic ball dynamics. This physical phenomenon occurs when a spinning object moves through a fluid, such as air, generating a pressure differential that results in a force perpendicular to the object’s direction of motion and its spin axis. As a result, the ball follows a curved trajectory rather than a straight line. In the game, this effect is simulated by applying spin whenever the ball strikes the paddle with an offset from its center or while the paddle is in motion. This spin induces the Magnus force during the ball's flight, causing it to curve and thereby adding depth, challenge, and physical authenticity to the gameplay experience. <sup>[1][2]</sup> </p>
<p>
The spin is initiated by paddle impact with vertical displacement or movement. The Magnus effect modifies the ball’s vertical velocity, simulating lift or dip. Spin decays naturally to emulate real-world aerodynamic damping.</p>
<p>
This implementation effectively simulates curved motion using lightweight math operations suitable for an embedded system without floating-point hardware, relying on efficient fixed-point arithmetic.</p>
<p>
When a ball spins while moving through air, it drags air faster on one side than the other. According to Bernoulli’s principle, faster-moving air exerts less pressure. This creates a pressure imbalance, generating a sideways force perpendicular to the ball’s velocity vector and its spin axis. This force is the Magnus force.</p>
<p>The Magnus force <span style="text-decoration:overline;">F</span><sub>m</sub> acting on a spinning ball is given by:</p>

<p style="text-align: center;">
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub><mover><mi>F</mi><mo>&#x2192;</mo></mover><mi>m</mi></msub>
    <mo>=</mo>
    <mi>S</mi>
    <mo>&#x22C5;</mo>
    <mo>(</mo>
    <mover><mi>&#x03C9;</mi><mo>&#x2192;</mo></mover>
    <mo>&#x00D7;</mo>
    <mover><mi>v</mi><mo>&#x2192;</mo></mover>
    <mo>)</mo>
  </math>
</p>

<p><strong>Where:</strong></p>
<ul>
  <li><strong>S</strong> is a coefficient that depends on the air density, ball surface, radius, and spin rate.</li>
  <li><strong><math><mover><mi>&#x03C9;</mi><mo>&#x2192;</mo></mover></math></strong> is the angular velocity (spin vector).</li>
  <li><strong><math><mover><mi>v</mi><mo>&#x2192;</mo></mover></math></strong> is the translational velocity vector of the ball.</li>
  <li><strong>&times;</strong> is the cross product, implying the force is perpendicular to both spin and velocity.</li>
</ul>

<p>
  In a simplified 2D context, assuming spin occurs around the z-axis (out of the screen), and the ball moves in the x-y plane,
  the Magnus force adds a component to the y-velocity of the ball (i.e., curves the ball up or down).
</p>

<p>
  To realistically simulate this behavior in an embedded system like the RP2040, we use fixed-point math for efficiency.
  The Magnus effect is approximated by adjusting the ball’s vertical velocity each frame based on its spin:
</p>

<p style="text-align: center;">
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub><mi>v</mi><mi>y</mi></msub>
    <mo>=</mo>
    <msub><mi>v</mi><mi>y</mi></msub>
    <mo>+</mo>
    <msub><mi>k</mi><mi>M</mi></msub>
    <mo>&#x22C5;</mo>
    <mi>spin</mi>
  </math>
</p>

<p><strong>Where:</strong></p>
<ul>
  <li><strong>Vy</strong> is the vertical velocity of the ball.</li>
  <li><strong>spin</strong> is the current spin magnitude (signed).</li>
  <li><strong>Km</strong> is the Magnus coefficient.</li>
</ul>
<br>
<h3>Magnus Effect Spin Simulation Code</h3>

<p>This is implemented in code as:</p>

<pre><code>vy += multfix15(ballSpin, magnusK)</code></pre>

<p>
This effectively emulates the Magnus effect in a discrete stepwise simulation, without solving
fluid dynamics equations in real-time. The spin is not constant; it is introduced when the ball
collides with a paddle. The amount of spin is a function of the ball's contact position relative to
the paddle center and the horizontal velocity of the paddle at the moment of impact.
</p>

<p><strong>Mathematically:</strong></p>
<p style="text-align: center;">
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <mi>spin</mi>
    <mo>=</mo>
    <mi>&#945;</mi>
    <mo>&#x22C5;</mo>
    <mi>&#x2206;y</mi>
    <mo>+</mo>
    <mi>&#946;</mi>
    <mo>&#x22C5;</mo>
    <msub><mi>v</mi><mi>paddle</mi></msub>
  </math>
</p>

<p><strong>Where:</strong></p>
<ul>
  <li><strong>Δy</strong> is the vertical offset from the paddle center to the point of contact.</li>
  <li><strong>Vpaddle</strong> is the horizontal paddle speed.</li>
  <li><strong>α, β</strong> are scaling constants.</li>
</ul>

<p>
A fixed-point variable <code>ballSpin</code> (in Q15 format) is used to represent the current spin of the ball.
When the ball hits a paddle, spin is induced using the vertical offset between the ball and paddle
center and the paddle's horizontal velocity.<sup>[5]</sup>
</p>

<p><strong>This is computed using:</strong></p>

<pre><code>ballSpin = int2fix15(offset / 8) + int2fix15(paddleVX / 4)</code></pre>

<p><strong>Where:</strong></p>
<ul>
  <li><strong>offset</strong> is the vertical distance from the paddle center to the point of contact.</li>
  <li><strong>paddleVX</strong> is the horizontal velocity of the paddle.</li>
  <li><strong>int2fix15()</strong> converts integer to fixed-point format.</li>
</ul>

<p>
This ensures that a hit near the edge of the paddle or with a moving paddle imparts greater spin.
</p>

<p>
To simulate aerodynamic damping, a decay factor is applied to the spin each frame:
</p>

<p style="text-align: center;">
  <math xmlns="http://www.w3.org/1998/Math/MathML">
    <msub><mi>spin</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub>
    <mo>=</mo>
    <mi>&#947;</mi>
    <mo>&#x22C5;</mo>
    <msub><mi>spin</mi><mi>t</mi></msub>
  </math>
</p>

<p>Where γ &lt; 1 gradually reduces the spin toward zero, emulating air resistance.</p>

<p>The spin decays over time to simulate air resistance using:</p>

<pre><code>ballSpin = multfix15(ballSpin, spinDecay);</code></pre>

<p>
Here, <code>spinDecay</code> is a constant slightly less than 1, ensuring the spin gradually reduces with each frame.
</p>
<p>
  During each frame update, the vertical velocity (<strong>vy</strong>) of the ball is modified based on its current
  spin value using:
</p>

<pre><code>vy += multfix15(ballSpin, magnusK);</code></pre>

<p><strong>Where:</strong></p>
<ul>
  <li>
    <em>magnusK</em> is a small constant (e.g., <em>0.03 in Q15</em>) that controls the strength of the Magnus effect
  </li>
  <li>
    <code>multfix15()</code> performs fixed-point multiplication.
  </li>
</ul>

<p>
  This calculation results in the ball curving upwards or downwards depending on the direction
  and magnitude of spin, creating a lifelike trajectory. By using simplified vector math and
  fixed-point arithmetic, the system achieves visually convincing curved ball motion that mirrors
  real-world spin dynamics, while maintaining real-time responsiveness on resource-constrained hardware.<sup>[6]</sup>
</p>

	<h3>Logical Structure</h3>
	<h4>1. Initialization</h4><p>Upon power-up, the program initializes the system by configuring VGA output, setting up I2C communication with the two MPU6050 IMUs, and preparing the GPIO pin for the start button.</p>
 
 <img src="images/welcome2.jpg" alt="Welcome Page" style="max-width:100%; height:auto;">
<p>Fig [1]: Start screen with introductory text - Waits for a button press to start.</p>

<p>The display is cleared using fillRect, and a welcoming introduction screen is rendered via the writeString, setCursor, and setTextSize functions from the VGA graphics library. As shown in the first image, the screen prominently displays "Welcome to Table Tennis" in large blue letters centered on the screen. Below it, in small white text, are detailed game rules and features clearly instructing the players on control mechanisms, spin, audio feedback, and scoring.</p>
<img src="images/button.JPG" alt="Button" style="max-width:100%; height:auto;">
<p>Fig [2]: Button to be pressed at the start of the game<br></p>
<p>At the bottom right, in red, the phrase "Press button to start" is displayed, indicating to the user how to initiate the game. The system enters a polling loop using gpio_get to wait for this button press. On detection of a press, the screen is cleared again, the IMUs are re-initialized with init_two_mpus(), and the game logic begins.
</p>
<h4>2. Game Loop</h4>
<img src="images/game.JPG" alt="Working Game" style="max-width:100%; height:auto;">
<p>Fig [3]: Reads IMU data, updates paddle positions, checks ball collisions, 
updates display, triggers sound.</p>
<p>The game loop operates continuously after initialization and is managed within a Protothread running on core 0, which handles animation and gameplay. The main responsibilities of the game loop are to update ball and paddle positions, check for collisions, render graphics, manage scoring, and trigger sound feedback. Paddle positions are updated based on real-time IMU readings from core 1, which runs protothread_imus in parallel. This core separation ensures that heavy sensor polling does not interfere with time-sensitive VGA rendering. In each iteration of the loop, the ball is first erased using fillCircle in black, and its motion is calculated using wallsAndEdges(), which includes not only boundary collision detection but also Magnus force calculations from spin. After updating the ball’s position, it is redrawn, and the drawArena() function refreshes the game field, including the center line, circular field marking, and real-time scores. Paddle graphics are rendered using draw_paddles_core0(), which uses vector math to depict slanted paddles and draw_thick_line() for visual clarity.
            </p>
<h4>3. Win Detection</h4>
<img src="images/gamewin.JPG" alt="Winning Game" style="max-width:100%; height:auto;">
<p>Fig [4]: Tracks score per round, checks if a player has won three rounds.</p>
<p>Scoring and win detection are managed in the calculateScore() function, which tracks each player’s point score (Score_A and Score_B) and round wins (WinningScore_A and WinningScore_B). A player must reach 11 points and lead by at least 2 points to win a set. This is validated through conditional checks on the score difference (diff1, diff2) and values. Upon winning a set, scores are reset, and the round counter for the winning player is incremented. If a player wins 3 sets, the game declares that player as the final winner by displaying either "Player A Wins" or "Player B Wins" using writeString at the center of the screen. The game is then paused briefly and reset using reset_board() and by spawning a new ball with spawnBoid().</p>
<h4>4. Audio</h4>
<p>Sound in the game is generated using DMA to offload audio playback from the main CPU. When the ball hits a paddle or a wall, the game logic in reflectBallFromPaddle() and wallsAndEdges() aborts and restarts DMA channels (dma_channel_abort, dma_start_channel_mask) to initiate sound playback from a pre-calculated sine wave table stored in DAC_data. The use of DMA ensures that sound is produced with minimal CPU intervention, allowing smooth and uninterrupted graphics and game logic processing. The audio adds immersive feedback, enhancing the physicality of the game.<sup>[4]</sup>
</p>
<p><h4>5. Game Reset</h4></p>
<img src="images/gamereset.JPG" alt="Reset of Game" style="max-width:100%; height:auto;">
<p>Fig [5]: Game resets on pressing the button during an ongoing game</p> 
<p>After the first press of the start button, subsequent presses serve as a global reset trigger. This reset logic is handled with highest priority within the game loop in protothread_anim. If the button is detected as pressed (!gpio_get(15)), the entire game state is cleared: scores and round wins are reset to zero, the paddles are redrawn at initial positions, and a new ball is spawned. If this isn’t the very first start, a message "Game Reset!" is shown using writeString. This feature is critical for recovering from abnormal paddle behavior.
</p><br>
        </section>

        <section id="programdesign">
            <h2>Program Design</h2>
            <p>
                The core of the software is built around four main components that work together to deliver a responsive and interactive gameplay experience. First, VGA graphics routines are used to render the entire display output, including the game field, paddles, ball, and user interface elements such as scores and messages. Second, audio feedback is implemented using DMA-driven playback routines, which allow sound to be triggered asynchronously whenever the ball hits a paddle or boundary, without burdening the CPU. Third, a custom game state manager oversees the overall game flow handling initialization, detecting button input to start or reset the game, managing the scoring system, and determining the win conditions. Lastly, the system incorporates real-time polling and data interpretation to control paddle movement, translating physical glove motions into smooth on-screen paddle responses through filtering and position mapping logic.</p>
<p>
The VGA display is initialized using initVGA() and then used throughout the game to render graphics directly to the screen’s framebuffer. Drawing functions like fillRect, fillCircle, drawLine, and draw_thick_line are used to create static elements (arena lines, center circle) and dynamic elements (ball and paddle positions). Paddle rendering uses a thick line segment to represent a slanted paddle and is updated only when a change in position or tilt is detected to avoid flickering. Text rendering is managed using setCursor, setTextColor, and writeString, and numeric values are updated in place using fillRect to overwrite the old score values.</p>
<p>
A key architectural decision was the division of labor between the two cores of the RP2040. Core 0 handles all graphics rendering and animation (ball physics, collisions, drawing, score updates). While Core 1 is exclusively responsible for reading and filtering IMU data, updating paddle positions, and calculating tilt.</p>
<p>
This split allows for parallel execution and ensures that time-critical VGA drawing is not delayed by I2C communication or filtering computations. Shared state is managed carefully using a double-buffered paddleState[] structure and an activeBuffer variable to avoid concurrency issues. This design significantly improved performance and responsiveness.</p>
<p>
An adaptive difficulty system is introduced where the ball speed, paddle size, or number of balls change based on the player's performance. This could help maintain balanced gameplay for users of varying skill levels.</p>
</p>
	<h3>Software Design</h3>
<img src="images/flowchart1.jpeg" alt="System Flowchart1" style="max-width:100%; height:auto;">
<p>Fig [6]: Flowchart for Software Function and Threads</p>
<p>
    This flowchart provides a comprehensive breakdown of the multithreaded architecture used in the embedded ping-pong game system, running on dual cores. Core0 handles system initialization, peripheral setup, and launches Core1 and the animation thread. Core1 subsequently manages IMU data processing through a dedicated thread. The animation thread running on Core 0 governs the main game loop handling ball spawning, redrawing elements, collision detection, score calculation, and paddle reflection. Additional functions like <em>Ball Physics</em>, <em>Paddle Reflection</em>, <em>Score Calculation</em>, and <em>DMA Sound</em> operate asynchronously to manage game mechanics like Magnus effect, sound triggering, and score updates, ensuring modular, real-time execution.
  </p>
<img src="images/flowchart2.jpeg" alt="System Flowchart2" style="max-width:100%; height:auto;">
<p>Fig [7]: System Flowchart</p>
<p>
    This high-level system flowchart outlines the user interaction and game progression logic on the VGA display. The flow begins with a welcome screen, prompting players to get ready (with gloves), followed by initiating the game table with paddles and ball setup. The game proceeds with successive rounds, updating scores when a player misses. A round concludes when a player scores 11 points with a 2-point lead, and the game ends when a side wins 3 rounds. The system also includes an interrupt mechanism to refresh the game at any point and culminates in a celebratory display upon determining the final winner.
  </p>
	<h3>Hardware Design</h3>
<img src="images/protoboard.JPG" alt="Wiring Connections" style="max-width:100%; height:auto;">
<p>Fig [8]: Protoboard Connectivity</p>
<img src="images/blockdiagram.JPG" alt="Hardware Block Diagram" style="max-width:100%; height:auto;">
<p>Fig [9]: Hardware Block Diagram</p>
		<p>This hardware architecture balances performance, simplicity, and modularity, allowing the game to read both IMUs, render VGA graphics, and produce sound all from a single RP2040 chip. The hardware setup for the project involved careful synchronization of VGA signal timing with real-time game logic, along with stable interpretation of IMU data for smooth paddle control. Achieving jitter-free ball-paddle collisions required fine-tuning of low-pass filtering and precise bounding box calculations. The system is powered by a Raspberry Pi Pico (RP2040) microcontroller, with two 6-DOF IMU sensors mounted on gloves for motion-based input. A piezo speaker driven via DMA provides audio feedback, while a VGA screen at 640x480 resolution displays the game. A single push button serves as the game’s start and reset input.<br>
            </p>
<table border="1" cellspacing="0" cellpadding="8">
  <thead>
    <tr>
      <th>Component</th>
      <th>RP2040 GPIO Pin(s)</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>IMU A</td>
      <td>GPIO 2 (SDA), GPIO 3 (SCL), 3.3V, GND</td>
      <td>I2C address 0x68</td>
    </tr>
    <tr>
      <td>IMU B</td>
      <td>GPIO 2 (SDA), GPIO 3 (SCL), 3.3V, GND, AD0 = HIGH</td>
      <td>I2C address 0x69</td>
    </tr>
    <tr>
      <td>Button</td>
      <td>GPIO 15</td>
      <td>Pulled up internally, active LOW</td>
    </tr>
    <tr>
      <td>DAC (Audio)</td>
      <td>GPIO 5 (CS), GPIO 6 (SCK), GPIO 7 (MOSI), 3.3V, GND</td>
      <td>SPI0-based DAC</td>
    </tr>
    <tr>
      <td>VGA Output</td>
      <td>GPIOs 16–21, GND</td>
      <td>RGB + Sync signals, uses resistors</td>
    </tr>
    <tr>
      <td>Shared 3.3V</td>
      <td>VCC to DAC and both IMUs</td>
      <td>Power supply</td>
    </tr>
    <tr>
      <td>Shared GND</td>
      <td>Common ground for all components</td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>Table [1]: Hardware Connections</p>
<p>The project uses a single Raspberry Pi Pico (RP2040) microcontroller to control the game logic, VGA rendering, IMU data acquisition, and sound generation. Two MPU6050 IMUs are connected to the same I2C bus, leveraging the I2C1 channel of the RP2040. Each MPU6050 has a configurable I2C address via the AD0 pin when this pin is tied LOW, the device address is 0x68, and when HIGH, the address is 0x69.</p>
<p>In our hardware setup, IMU A (Player A): AD0 is tied LOW, giving it the address 0x68, and IMU B (Player B): AD0 is tied HIGH, giving it the address 0x69. Both IMUs share the SDA and SCL lines, GPIO 2 (SDA) and GPIO 3 (SCL) of the Pico are used for I2C1 communication, 3.3V from the Pico powers both IMUs, and GND from the Pico is connected to both IMUs.</p>
<p>This means the first IMU (at 0x68) has 4 wires (VCC, GND, SDA, SCL), and the second (at 0x69) has 5 wires VCC, GND, SDA, SCL, and AD0 connected to 3.3V to set its address high. These connections allow both IMUs to operate on the same I2C channel while being independently addressable. <sup>[7]</sup></p>
<p>A single push-button is used for two purposes: starting the game after the introduction screen and resetting the game at any point after the first start. The button is connected to GPIO 15 and configured as an active-low input. One side of the button connects to GND and the other side connects to GPIO 15. The internal pull-up resistor is enabled in software using gpio_pull_up(), which ensures the input is HIGH when not pressed and LOW when pressed. This simple configuration allows the firmware to continuously poll the button state using gpio_get() and respond to presses reliably.</p>
Audio output is generated using a DAC (Digital-to-Analog Converter) connected via the SPI0 interface. This setup allows audio playback (sine wave tones) to be streamed efficiently using DMA, minimizing CPU load during sound output. The connections to the DAC are as follows:</p>
<div style="text-align: center;">
  <table border="1" cellspacing="0" cellpadding="8" style="margin: 0 auto;">
    <thead>
      <tr>
        <th>RP2040 GPIO / Pin</th>
        <th>Function</th>
        <th>DAC Connection</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>GPIO 5 (Pin 7)</td>
        <td>SPI0 CS (Chip Select)</td>
        <td>CS</td>
      </tr>
      <tr>
        <td>GPIO 6 (Pin 9)</td>
        <td>SPI0 SCK (Clock)</td>
        <td>SCK</td>
      </tr>
      <tr>
        <td>GPIO 7 (Pin 10)</td>
        <td>SPI0 MOSI (Data Out)</td>
        <td>SDI</td>
      </tr>
      <tr>
        <td>3.3V (Pin 36)</td>
        <td>Power Supply</td>
        <td>VCC</td>
      </tr>
      <tr>
        <td>GND (Pin 3)</td>
        <td>Ground</td>
        <td>GND</td>
      </tr>
    </tbody>
  </table>
  <p style="margin-top: 8px;">Table [2]: DAC Connections with RP2040</p>
</div>

<p>This DAC is used to generate the sound effect played when the ball hits a paddle or the wall, using a precomputed sine wave table and streamed through SPI using DMA (dma_channel_configure, dma_start_channel_mask).</p>
<img src="images/vga.JPG" alt="VGA - Wiring" style="max-width:100%; height:auto;">
<p>Fig [10]: VGA Connection to RP2040 <sup>[3]</sup></p>
<p>Video output is driven directly from the Raspberry Pi Pico using bit-banged VGA signals on dedicated GPIO pins, only 6 connections are required to create a working VGA signal:</p>
<p>These connections are used to generate a 640x480 60Hz analog VGA signal, which is rendered with game graphics using custom drawing routines (fillCircle, draw_thick_line, writeString, etc.). The dual green resistors help with brightness modulation for that channel.</p>
<table border="1" cellspacing="0" cellpadding="8">
  <thead>
    <tr>
      <th>RP2040 GPIO</th>
      <th>Function</th>
      <th>VGA Connection</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GPIO 16</td>
      <td>Horizontal Sync</td>
      <td>HSync</td>
    </tr>
    <tr>
      <td>GPIO 17</td>
      <td>Vertical Sync</td>
      <td>VSync</td>
    </tr>
    <tr>
      <td>GPIO 19</td>
      <td>Video Signal (via 330Ω)</td>
      <td>Green</td>
    </tr>
    <tr>
      <td>GPIO 20</td>
      <td>Video Signal (via 330Ω)</td>
      <td>Blue</td>
    </tr>
    <tr>
      <td>GPIO 21</td>
      <td>Video Signal (via 330Ω)</td>
      <td>Red</td>
    </tr>
    <tr>
      <td>GND</td>
      <td>Ground</td>
      <td>VGA Ground</td>
    </tr>
  </tbody>
</table>
<p> Table [3]: VGA COnnection with RP2040</p>
<p>These connections are used to generate a 640x480 60Hz analog VGA signal, which is rendered with game graphics using custom drawing routines (fillCircle, draw_thick_line, writeString, etc.). The dual green resistors help with brightness modulation for that channel.</br></p>
<img src="images/glove.JPG" alt="Gloves with IMU mounted" style="max-width:100%; height:auto;">
<p>Fig [11]: IMU mounted on the glove for the player</p>
<p>To enable intuitive, gesture-based control of the paddles, each MPU6050 IMU was securely mounted onto a glove, one for each player. The IMUs were positioned on the back side of the hand near the wrist, which allowed them to capture tilt and motion data effectively without being obstructed by finger movements. To ensure a firm attachment, each IMU module was wrapped in copper tape to maintain a stable surface against the glove fabric. The modules were then firmly taped onto the gloves using insulating electrical tape, ensuring that the sensors did not shift during gameplay. To route the electrical connections back to the microcontroller, color-coded jumper wires were soldered to the IMU breakout boards. These wires were carefully secured along the wrist and arm area of the glove using heat shrink tubing and additional tape. This reinforcement minimized mechanical stress on the solder joints and prevented wire movement from interfering with sensor readings. The careful mounting and wiring ensured stable data reading, comfortable wearability, and consistent paddle control throughout the game.<br></p>
<p>The VGA signal generation code was based on open-source VGA libraries tailored for RP2040 microcontrollers. The audio output method using DMA was adapted from public RP2040 sound examples. We modified them significantly to support real-time game triggering and frequency customization.<br>
</p>
        </section>

        <section id="problems-faced">
            <h2>Problems Faced and Resolutions</h2>
    <ol>
        <li>
            <strong>Low Pass Filtering</strong> IMU data was initially too jittery, causing erratic paddle motion. We applied low-pass filtering with a small alpha coefficient to smooth the values. This ensured that recent values were weighted less heavily, resulting in fluid motion.
        </li>
        <li>
            <strong>Paddle Clamping:</strong> At first, paddles could move beyond the screen or into the opponent’s territory. We resolved this using clamp() functions to constrain x and y positions within their respective allowable regions (XA_RANGE, XB_MIN, Y_RANGE).
        </li>
        <li>
            <strong>Color Confusion:</strong>Initially, both paddles were rendered in the same color, leading to player confusion. To enhance clarity, Player A’s paddle was rendered in red, and Player B’s paddle in blue.
        </li>
        <li>
            <strong>IMU Interference:</strong> The physical movement of wires between the two IMUs was causing interference, where moving one glove could affect the other paddle. We solved this by using heat-shrink tubing to isolate wiring and reduce unwanted mechanical coupling.
        </li>
        <li>
            <strong>Loose Connections:</strong> Solder joints on IMUs were occasionally loose, leading to frozen paddle inputs while the ball continues moving. To quickly recover from such cases, we emphasized the reset button functionality, which completely initialized the IMUs and game state.

        </li>
        <li>
            <strong>Paddle Graphics:</strong> Initial attempts to use fillRect didn't resolved our issue if we want some tilt motion. Ultimately, we used draw_thick_line() which contains drawline() which rendered clear and dynamic slanted paddles with a given thickness declared in Paddle_Thickness Variable.
        </li>
    </ol>
        </section>

        <section id="results">
            <h2>Results</h2>
            <p>
	The final implementation of the glove-controlled table tennis game produced successful results in terms of functionality, responsiveness, and user experience. The VGA display output was stable, and the graphical elements such as the paddles, ball, score, and arena were rendered without visual flicker or tearing. The system maintained a steady frame rate of approximately 30 frames per second, with minimal latency in paddle movement, ensuring a smooth and interactive gameplay experience. The use of DMA for audio playback significantly improved concurrency, allowing the system to handle audio triggers without blocking or delaying video rendering and IMU updates. This ensured that the game remained responsive even during high-action scenarios with frequent paddle-ball interactions.<br></p>
<div style="text-align: center;">
  <table border="1" cellspacing="0" cellpadding="8" style="margin: 0 auto;">
    <thead>
      <tr>
        <th>Constant</th>
        <th>Purpose</th>
        <th>Value (approx.)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>magnusK</td>
        <td>Magnus force coefficient</td>
        <td>0.03 (Q15)</td>
      </tr>
      <tr>
        <td>spinDecay</td>
        <td>Spin decay factor per frame</td>
        <td>0.995 (Q15)</td>
      </tr>
      <tr>
        <td>alpha</td>
        <td>Paddle motion to spin scaling</td>
        <td>0.125 (1/8)</td>
      </tr>
      <tr>
        <td>beta</td>
        <td>Paddle velocity to spin scaling</td>
        <td>0.25 (1/4)</td>
      </tr>
    </tbody>
  </table>
  <p style="margin-top: 8px;">Table [4]: Final Values used for the Code</p>
</div>
    <p>In terms of accuracy, the paddle collision detection was reliable and precise, with a positional tolerance of about 2 pixels, making gameplay fair and consistent. At times the paddle would freeze and the animation would continue, this would be due to loose contact, when this happens on pressing the reset button, the game resumes from the start. The audio waveform generated via DMA and SPI closely matched the intended sine wave, with test measurements confirming frequency accuracy within ±3 Hz around the 500 Hz target. Video signal timing was carefully managed through the VGA libraries, and oscilloscope verification confirmed the correct synchronization of horizontal and vertical sync pulses, ensuring compatibility with standard VGA monitors.<br></p>
<div style="text-align: center;">
  <img src="images/heatshrink.JPG" alt="heat-Shrink Wiring" style="max-width: 100%; height: auto;">
  <p>Fig [12]: Heat Shrink used as Safety measure</p>
</div>
<p>Safety considerations were also addressed in the hardware design. All components were powered through the RP2040’s regulated 3.3V rail to prevent overvoltage. The IMUs were mounted securely on gloves, and all wiring was insulated and reinforced using heat shrink tubing to prevent accidental disconnections or shorts during gameplay. The pushbutton reset functionality allowed quick recovery in the rare event of a sensor freeze or signal loss, maintaining a safe and recoverable environment.<br></p>
<p>In terms of usability, the system was intuitive and enjoyable to use. Players could control paddles naturally with glove motion, and the visual and audio feedback helped them quickly adapt to the control scheme. The instructions displayed on the start screen made the game accessible to new users without prior explanation. Multiple individuals tested the game and found it responsive, engaging, and easy to operate, validating the system’s robustness and design reliability across a variety of users. Overall, the design met and exceeded performance expectations in all key functional areas.</p>

        </section>
	<section id="conclusion">
	<h2>Conclusion</h2>
	<p>
                The project successfully achieved its intended goals of developing an immersive, real-time table tennis game that integrates gesture-based control, VGA graphics, and DMA-driven audio feedback, all running on a resource-constrained Raspberry Pi Pico microcontroller. By leveraging IMUs mounted on gloves, the design allowed players to control paddles through natural hand motions, bringing a physical and intuitive element to what is traditionally a keyboard-based or joystick-based interface. The game ran at a consistent 30 frames per second, with smooth paddle tracking, low latency, and accurate collision physics including spin dynamics using the Magnus effect.<br></p>
<p>From a standards perspective, the design adhered to established protocols and electrical signaling formats. The VGA output was generated following RS170-compatible video timing, ensuring compatibility with standard displays, while I2C and SPI protocols were used to interface with IMUs and the DAC, respectively. Throughout the project, we made use of publicly available and open-source code, including VGA timing libraries and SPI/DMA audio playback routines. The design was entirely built on documented, open technologies, making it reproducible and extensible for others.<br></p>
<p>While the current implementation is relatively simple, the use of IMU-driven glove controls in a VGA game setting opens the door to future innovations. There may be opportunities to patent more advanced gesture-based gaming interfaces or adapt the system for educational applications. If we were to revisit the project, potential improvements could include wireless IMUs for untethered play, expanded gameplay modes, or machine learning-based motion interpretation. Overall, the project serves as a strong proof of concept and an exciting demonstration of what is possible with microcontrollers and creative human-computer interaction design.<br>

            </p>
	</section>
        <section id="future-work">
            <h2>Future Work</h2>
            <p>
                While the current implementation of the glove-controlled table tennis game provides an engaging and responsive two-player experience, there are several promising directions for future enhancement and development:
            </p>
            <ol>
                <li>
                    <b>Multiple Ball Gameplay:</b> Introducing multiple balls in play could significantly increase the challenge and excitement of the game. This would require adjustments in collision detection logic, rendering multiple ball objects, and managing independent ball velocities and spin. Such a feature could be implemented using additional structures for ball states and integrated into the existing core 0 animation thread.
                </li>
                <li>
                    <b>Single-Player Mode with AI:</b> Implementing a computer-controlled paddle would allow solo gameplay. A basic AI could follow the ball’s trajectory using predictive movement, while a more advanced version could incorporate machine learning models to simulate human-like behavior.
                </li>
                <li>
                    <b>Wireless IMU Gloves:</b> Currently, the gloves are wired to the system, which may restrict player mobility. Future iterations could integrate wireless microcontrollers like ESP32s on each glove, transmitting IMU data via Bluetooth or Wi-Fi to the RP2040.
                </li>
<li>
<b>More Detailed Paddle Control:</b> Incorporating additional gesture recognition, such as twisting the wrist to apply more spin or angle, could give players more nuanced control of the paddle, simulating advanced table tennis techniques.</li>
<li>
<b>Networked Multiplayer:</b> Expanding the system to allow online multiplayer over Wi-Fi could make the game more accessible and competitive. This would involve synchronizing game states between multiple devices over a network connection.</li>
<li><b>Touchscreen or Keyboard Menu Interface:</b> Adding a small touchscreen or keyboard interface could allow players to select game modes, difficulty, or colors before starting, creating a more user-friendly experience.</li>
            </ol>
</section>
        <section id="work-distribution">
        <h2>Team Members and Work Distribution</h2>
	<p> The development of this glove-controlled table tennis game was a collaborative effort by a team of three members, each contributing unique skills while also working collectively on core aspects of the project. All team members were jointly involved in conceptualizing the original game idea, outlining the project proposal, and formulating the logical flow of the game, including how gesture control, VGA graphics, and sound integration would work together cohesively.</p>
<div style="text-align: center;">
  <img src="images/teampicture.JPG" alt="Team Picture" style="max-width: 100%; height: auto;">
  <p>Fig [13]: Picture of the Team with the Working Setup</p>
</div>
<p>The software development was primarily handled by hp475, who took lead on writing the core game logic, implementing the animation threads, integrating the paddle control algorithms, and managing the scoring and win conditions. The audio system, including DMA-based sound triggering and SPI communication with the DAC, was designed and implemented by zf248, who ensured smooth real-time audio playback without interrupting gameplay. asm367 was responsible for the hardware implementation, including breadboarding, soldering all connections between the Pico, DAC, VGA, and IMUs, and adding heat shrink tubing to stabilize the IMU wires and reduce interference between player inputs.
All three team members were actively engaged in documentation, testing, and debugging throughout the development process. They collaborated closely to refine the paddle responsiveness, eliminate cross-interference between IMUs, and tune the system for smooth gameplay. 
</p>
    </section>
    </div>

    <footer id="appendix">
        <div class="container">
            <h3>Appendix</h3>
	    <h4>Appendix A</h4>
		<p>Project on the Course Page: The group approves this report for inclusion on the course website.</p>
		<p>Project on the Course Youtube Channel: The group approves the video for inclusion on the course youtube channel.</p>
	<h4>Appendix B</h4>
	<h5>Budget</h5>
<p>All the materials and tools we used were easily available at the laboratory and are listed below. </p><br>
<div style="text-align: center;">
<table border="1" cellspacing="0" cellpadding="8">
  <thead>
    <tr>
      <th>Part</th>
      <th>Quantity</th>
      <th>Cost (USD)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Raspberry Pi Pico (RP2040)</td>
      <td>1</td>
      <td>$4.00</td>
    </tr>
    <tr>
      <td>MPU6050 IMU Modules</td>
      <td>2</td>
      <td>$10.00</td>
    </tr>
    <tr>
      <td>VGA Connector (DB15)</td>
      <td>1</td>
      <td>$2.00</td>
    </tr>
    <tr>
      <td>DAC Module (e.g., MCP4921)</td>
      <td>1</td>
      <td>$3.00</td>
    </tr>
    <tr>
      <td>
        Miscellaneous (Resistors, Breadboard and Wires, Push Button, Soldering Materials,
        Heat Shrink, Speakers, Gloves, Tools, etc)
      </td>
      <td>N/A</td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>
<p style="margin-top: 8px;">Table [5]: Bill Of Material</p>
</div>
	<h5>References</h5> 
<ol>
  <li>Wikipedia contributors, "Magnus effect," Wikipedia, The Free Encyclopedia. <a href="https://en.wikipedia.org/wiki/Magnus_effect" target="_blank">[Online]</a>.</li>
  <li>ScienceDirect, "Magnus Effect - an overview," ScienceDirect Topics. <a href="https://www.sciencedirect.com/topics/physics-and-astronomy/magnus-effect" target="_blank">[Online]</a>.</li>
  <li>V. H. Adams, "VGA Video Generation with the RP2040," <a href="https://vanhunteradams.com/Pico/VGA/VGA.html" target="_blank">[Online]</a>.</li>
  <li>V. H. Adams, "Direct Digital Synthesis of Birdsong," <a href="https://vanhunteradams.com/Pico/Birds/Birdsong.html" target="_blank">[Online]</a>.</li>
  <li>Wikipedia contributors, "Q (number format)," Wikipedia, The Free Encyclopedia. <a href="https://en.wikipedia.org/wiki/Q_(number_format)" target="_blank">[Online]</a>.</li>
  <li>R. B. Bird and W. E. Stewart, "On the Magnus Effect," ResearchGate, <a href="https://www.researchgate.net/publication/293012282_On_the_Magnus_Effect" target="_blank">[Online]</a>.</li>
  <li>V. H. Adams, "Helicopter Dynamics and Control Using the RP2040," <a href="https://vanhunteradams.com/Pico/Helicopter/Helicopter.html" target="_blank">[Online]</a>.</li>
</ol>           
	<h4>Appendix C</h4>
	    <h5>Code</h5>
            <p>Below is the complete Code for the Project:
            <pre style="background: rgba(0,0,0,0.8); padding: 1em; border-radius: 5px; overflow-x: auto; color:#c5e1a5;">
// Include the VGA grahics library
#include "vga16_graphics.h"

// Include standard libraries
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

// Include Pico libraries
#include "pico/stdlib.h"
#include "pico/divider.h"
#include "pico/multicore.h"

// Include hardware libraries
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/clocks.h"
#include "hardware/pll.h"
#include "hardware/irq.h"
#include "hardware/adc.h"
#include "hardware/pio.h"
#include "hardware/i2c.h"
#include "hardware/spi.h"

// Include protothreads
#include "mpu6050.h"
#include "pt_cornell_rp2040_v1_3.h"

// Thickness of Paddle
#define PADDLE_THICK 8
#define PTH_HALF ((PADDLE_THICK - 1) / 2)
#define MAX_TILT_PX 10
// === the fixed point macros ========================================
typedef signed int fix15;
#define multfix15(a, b) ((fix15)((((signed long long)(a)) * ((signed long long)(b))) >> 15))
#define float2fix15(a) ((fix15)((a) * 32768.0)) // 2^15
#define fix2float15(a) ((float)(a) / 32768.0)
#define absfix15(a) abs(a)
#define int2fix15(a) ((fix15)(a << 15))
#define fix2int15(a) ((int)(a >> 15))
#define char2fix15(a) (fix15)(((fix15)(a)) << 15)
#define divfix(a, b) (fix15)(div_s64s64((((signed long long)(a)) << 15), ((signed long long)(b))))

// Wall detection
#define hitBottom(b) (b > int2fix15(480))
#define hitTop(b) (b < int2fix15(0))
#define hitLeft(a) (a < int2fix15(0))
#define hitRight(a) (a > int2fix15(640))

// uS per frame
#define FRAME_RATE 33000

// the color of the boid
char color = WHITE;

// Boid on core 0
fix15 boid0_x;
fix15 boid0_y;
fix15 boid0_vx;
fix15 boid0_vy;

// Boid on core 1
fix15 boid1_x;
fix15 boid1_y;
fix15 boid1_vx;
fix15 boid1_vy;

// Score and Variable Table
volatile int Score_A = 0;
volatile int Score_B = 0;
volatile int WinningScore_A = 0;
volatile int WinningScore_B = 0;

// ----------  [NEW]  ----------  spin & Magnus
static fix15 ballSpin = 0;
static const fix15 spinDecay = float2fix15(0.995f);
static const fix15 magnusK = float2fix15(0.03f);

// Arrays in which the raw measurements will be stored
fix15 acceleration[3], gyro[3];
fix15 acceleration1[3], gyro1[3];
fix15 accelA[3], gyroA[3], accelB[3], gyroB[3];

// ————————————————————————————————————————————————————————————————————————————
//  CONFIGURATION
// ————————————————————————————————————————————————————————————————————————————
#define SCREEN_W 640
#define SCREEN_H 480
#define PADDLE_W 10
#define PADDLE_H 50

// DMA settings
//  Number of samples per period in sine table
#define sine_table_size 256
int data_chan;
int ctrl_chan;
// Sine table
int raw_sin[sine_table_size];

// Table of values to be sent to DAC
unsigned short DAC_data[sine_table_size];

// Pointer to the address of the DAC data table
unsigned short *address_pointer1 = &DAC_data[0];

// Global flag to track first-time start
bool is_first_start = true;
// A-channel, 1x, active
#define DAC_config_chan_A 0b0011000000000000

// SPI configurations
#define PIN_MISO 4
#define PIN_CS 5
#define PIN_SCK 6
#define PIN_MOSI 7
#define SPI_PORT spi0

// Number of DMA transfers per event
const uint32_t transfer_count = sine_table_size;

// Live Paddle State (Shared with core-0 to draw)
volatile struct
{
  int xA, yA, xB, yB, vXA, vXB;
  int tiltA, tiltB;
} paddleState[2];

volatile int activeBuffer = 0;

// MPU addresses (tie AD0 low for 0x68, high for 0x69)
#define IMU_ADDR_A 0x68               // AD0 pin low
#define IMU_ADDR_B 0x69               // AD0 pin high
#define IMU_UPDATE_US 20000           // 50 Hz paddle refresh
#define XA_RANGE (250 - PADDLE_W)     // horiz. span for A
#define XB_MIN 420                    // B zone start
#define XB_RANGE (220 - PADDLE_W)     // horiz. span for B
#define Y_RANGE (SCREEN_H - PADDLE_H) // vertical span both
// keep track of last‑drawn paddle Y’s
static int lastY_A = (SCREEN_H - PADDLE_H) / 2;
static int lastY_B = (SCREEN_H - PADDLE_H) / 2;

// Create a boid
void spawnBoid(fix15 *x, fix15 *y, fix15 *vx, fix15 *vy, int direction)
{
  // Start in center of screen
  *x = int2fix15(320);
  *y = int2fix15(240);
  // Choose left or right
  if (direction)
    *vx = int2fix15(3);
  else
    *vx = int2fix15(-3);
  // Moving down
  *vy = int2fix15(1);
}

//--------------------------------------------------------------------
//  update_paddles_from_imus()  –  fixed-point, filtered, rate-limited
//--------------------------------------------------------------------
static fix15 filtA = 0; // LPF state (fix15 g-units)
static fix15 filtB = 0;
static const fix15 alpha = 2147; // 0.065 in Q15  (smaller ⇒ smoother)

static inline int clamp(int v, int lo, int hi) { return v < lo ? lo : (v > hi ? hi : v); }
static inline int mapAxisToRange(fix15 val, int range)
{ // val is -1…+1  g  in Q15
  return fix2int15(multfix15(val + float2fix15(1.0f),
                             int2fix15(range))) >>
         1;
}
static int last_xA = 0, last_yA = SCREEN_H / 2, last_xB = SCREEN_W - PADDLE_W, last_yB = SCREEN_H / 2;
// Extra state for the slanted paddles  ────────────────────────────────
static int last_tiltA = 0;
static int last_tiltB = 0;

static int last_xTopA = 0, last_yTopA = 0, last_xBotA = 0, last_yBotA = 0;
static int last_xTopB = 0, last_yTopB = 0, last_xBotB = 0, last_yBotB = 0;
static inline void draw_thick_line(int x1, int y1, int x2, int y2, uint16_t colour)
{
  for (int dx = -PTH_HALF; dx <= PTH_HALF; dx++)
  {
    drawLine(x1 + dx, y1, x2 + dx, y2, colour);
  }
}

static inline void erase_line(int x1, int y1, int x2, int y2)
{
  draw_thick_line(x1, y1, x2, y2, BLACK);
}

static inline void draw_line(int x1, int y1, int x2, int y2)
{
  draw_thick_line(x1, y1, x2, y2, RED);
}
static inline void draw_line2(int x1, int y1, int x2, int y2)
{
  draw_thick_line(x1, y1, x2, y2, BLUE);
}

static inline void draw_paddles_core0(void)
{
  /* --- PLAYER A --- */
  int xBase = paddleState[activeBuffer].xA, yBase = paddleState[activeBuffer].yA, tilt = paddleState[activeBuffer].tiltA;
  int xTop = xBase + tilt, yTop = yBase;
  int xBot = xBase - tilt, yBot = yBase + PADDLE_H;
  if (abs(xBase - last_xA) | abs(yBase - last_yA) | abs(tilt - last_tiltA))
  {
    erase_line(last_xTopA, last_yTopA, last_xBotA, last_yBotA);
    draw_line(xTop, yTop, xBot, yBot);
    last_xA = xBase;
    last_yA = yBase;
    last_tiltA = tilt;
    last_xTopA = xTop;
    last_yTopA = yTop;
    last_xBotA = xBot;
    last_yBotA = yBot;
  }
  /* --- PLAYER B --- */
  xBase = paddleState[activeBuffer].xB;
  yBase = paddleState[activeBuffer].yB;
  tilt = paddleState[activeBuffer].tiltB;
  xTop = xBase + tilt;
  yTop = yBase;
  xBot = xBase - tilt;
  yBot = yBase + PADDLE_H;
  if (abs(xBase - last_xB) | abs(yBase - last_yB) | abs(tilt - last_tiltB))
  {
    erase_line(last_xTopB, last_yTopB, last_xBotB, last_yBotB);
    draw_line2(xTop, yTop, xBot, yBot);
    last_xB = xBase;
    last_yB = yBase;
    last_tiltB = tilt;
    last_xTopB = xTop;
    last_yTopB = yTop;
    last_xBotB = xBot;
    last_yBotB = yBot;
  }
}
// ------------------------------------------------------------------
//                         ball reflection
// ------------------------------------------------------------------
static void reflectBallFromPaddle(fix15 *x, fix15 *y, fix15 *vx, fix15 *vy, int paddleX, int paddleY, int paddleVX)
{
  // Reset DMA channels before starting a new transfer
  dma_channel_abort(ctrl_chan);
  dma_channel_abort(data_chan);
  int bx = fix2int15(*x), by = fix2int15(*y);
  if (bx >= paddleX && bx <= paddleX + PADDLE_W &&
      by >= paddleY && by <= paddleY + PADDLE_H)
  {
    *vx = -*vx;

    int offset = by - (paddleY + PADDLE_H / 2);
    *vy += int2fix15(offset / 8);

    ballSpin = int2fix15(offset / 8) + int2fix15(paddleVX / 4);
    dma_start_channel_mask(1u << ctrl_chan); // Start both channels
    sleep_ms(10);                            // Allow sound to play for 100 ms
    dma_channel_abort(ctrl_chan);            // Stop the control channel
    dma_channel_abort(data_chan);            // Stop the data channel
    *vx = multfix15(*vx, float2fix15(1.07f));
    *vy = multfix15(*vy, float2fix15(1.05f));
  }
}

// Draw the boundaries
void drawArena()
{
  drawVLine(320, 0, 480, WHITE);
  drawCircle(320, 240, 100, GREEN);
  setTextColor(WHITE);
  setTextSize(0.2);
  setCursor(10, 10);
  writeString("Player A ");

  char buffer[12];
  sprintf(buffer, "%d", Score_A);
  setCursor(10, 20);
  fillRect(10, 20, 15, 7, BLACK);
  writeString(buffer);
  setCursor(590, 10);
  writeString("Player B ");

  char buffer1[12];
  sprintf(buffer1, "%d", Score_B);
  setCursor(620, 20);
  fillRect(620, 20, 15, 7, BLACK);
  writeString(buffer1);

  char buffer2[12];
  sprintf(buffer2, "%d", WinningScore_A);
  setCursor(305, 10);
  fillRect(305, 10, 15, 7, BLACK);
  writeString(buffer2);

  char buffer3[12];
  sprintf(buffer3, "%d", WinningScore_B);
  setCursor(330, 10);
  fillRect(330, 10, 15, 7, BLACK);
  writeString(buffer3);
  // drawLine(100,50,200,20,WHITE);
  // drawLine(600,400,500,450,RED);
  //  drawVLine(540, 100, 280, WHITE) ;
  //  drawHLine(100, 100, 440, WHITE) ;
  //  drawHLine(100, 380, 440, WHITE) ;
}

void reset_board()
{
  fillRect(0, 0, 620, 480, BLACK);
}

void calculateScore()
{
  int diff1 = Score_A - Score_B;
  int diff2 = Score_B - Score_A;
  if (hitRight(boid0_x))
  {
    Score_A++;
    if ((Score_A == 11 && Score_B <= 9) || (Score_A > 11 && diff1 >= 1))
    {
      Score_A = 0;
      Score_B = 0;
      WinningScore_A++;
      dma_channel_abort(ctrl_chan);            // Stop the control channel
      dma_channel_abort(data_chan);            // Stop the data channel
      dma_start_channel_mask(1u << ctrl_chan); // Start both channels
      sleep_ms(10);                            // Allow sound to play for 100 ms
      dma_channel_abort(ctrl_chan);            // Stop the control channel
      dma_channel_abort(data_chan);            // Stop the data channel
      fillRect(fix2int15(boid0_x) - 4, fix2int15(boid0_y) - 4, 10, 10, BLACK);
      spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 1);
      if (WinningScore_A == 3)
      {
        dma_channel_abort(ctrl_chan); // Stop the control channel
        dma_channel_abort(data_chan); // Stop the data channel
        WinningScore_B = 0;
        WinningScore_A = 0;
        // Do Nothing - Print A Wins and Reset the Board
        setTextColor(WHITE);
        setTextSize(1);
        setCursor(280, 240);
        writeString("Player A Wins");
        sleep_ms(2000);
        dma_start_channel_mask(1u << ctrl_chan); // Start both channels
        sleep_ms(30);                            // Allow sound to play for 100 ms
        dma_channel_abort(ctrl_chan);            // Stop the control channel
        dma_channel_abort(data_chan);            // Stop the data channel
        reset_board();
        fillRect(fix2int15(boid0_x) - 4, fix2int15(boid0_y) - 4, 8, 8, BLACK);
        spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 1);
      }
    }
  }
  if (hitLeft(boid0_x))
  {
    Score_B++;
    if ((Score_B == 11 && Score_A <= 9) || (Score_B > 11 && diff2 >= 1))
    {
      Score_A = 0;
      Score_B = 0;
      dma_channel_abort(ctrl_chan);            // Stop the control channel
      dma_channel_abort(data_chan);            // Stop the data channel
      dma_start_channel_mask(1u << ctrl_chan); // Start both channels
      sleep_ms(10);                            // Allow sound to play for 100 ms
      dma_channel_abort(ctrl_chan);            // Stop the control channel
      dma_channel_abort(data_chan);            // Stop the data channel
      fillRect(fix2int15(boid0_x) - 4, fix2int15(boid0_y) - 4, 10, 10, BLACK);
      WinningScore_B++;
      spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 0);
      if (WinningScore_B == 3)
      {
        dma_channel_abort(ctrl_chan); // Stop the control channel
        dma_channel_abort(data_chan); // Stop the data channel
        WinningScore_B = 0;
        WinningScore_A = 0;
        // Do Nothing - Print A Wins and Reset the Board
        setTextColor(WHITE);
        setTextSize(1);
        setCursor(280, 240);
        writeString("Player B Wins");
        sleep_ms(2000);
        reset_board();
        dma_start_channel_mask(1u << ctrl_chan); // Start both channels
        sleep_ms(30);                            // Allow sound to play for 100 ms
        dma_channel_abort(ctrl_chan);            // Stop the control channel
        dma_channel_abort(data_chan);            // Stop the data channel
        fillRect(fix2int15(boid0_x) - 4, fix2int15(boid0_y) - 4, 10, 10, BLACK);
        spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 0);
      }
    }
  }
}

// call once at startup (before you launch cores/threads)
void init_two_mpus()
{
  // initialize I2C0 at 400 kHz on GP4=SDA, GP5=SCL, GP2 and GP3
  // since we are using I2C on channel 1 and
  // I2C0 is being used by vga;
  i2c_init(i2c1, 400 * 1000);
  gpio_set_function(2, GPIO_FUNC_I2C);
  gpio_set_function(3, GPIO_FUNC_I2C);
  // No need to turn pull up since they are on breakout board that we are using
  // gpio_pull_up(4); gpio_pull_up(5);
  mpu6050_reset(IMU_ADDR_A);
  mpu6050_reset(IMU_ADDR_B);
}

// Detect wallstrikes, update velocity and position
void wallsAndEdges(fix15 *x, fix15 *y, fix15 *vx, fix15 *vy)
{
  // ----------  [MOD]  ----------  Magnus from spin
  *vy += multfix15(ballSpin, magnusK);
  ballSpin = multfix15(ballSpin, spinDecay);
  // ---------- [END]  ----------
  if (hitTop(*y) || hitBottom(*y) || hitRight(*x) || hitLeft(*x))
  {
    // Reset DMA channels before starting a new transfer
    dma_channel_abort(ctrl_chan);
    dma_channel_abort(data_chan);
    printf("Starting DMA transfer...\n");
    dma_start_channel_mask(1u << ctrl_chan); // Start both channels
    sleep_ms(10);                            // Allow sound to play for 100 ms
    dma_channel_abort(ctrl_chan);            // Stop the control channel
    dma_channel_abort(data_chan);            // Stop the data channel
    printf("DMA transfer completed.\n");
  }
  if (hitTop(*y))
  {
    *vy = -*vy;
    *y += int2fix15(5);
  }
  if (hitBottom(*y))
  {
    *vy = -*vy;
    *y -= int2fix15(5);
  }
  if (hitRight(*x))
  {
    *vx = -*vx;
    *x -= int2fix15(5);
  }
  if (hitLeft(*x))
  {
    *vx = -*vx;
    *x += int2fix15(5);
  }

  *x += *vx;
  *y += *vy;
}

// ==================================================
// === users serial input thread
// ==================================================
static PT_THREAD(protothread_serial(struct pt *pt))
{
  PT_BEGIN(pt);
  // stores user input
  static int user_input;
  // wait for 0.1 sec
  PT_YIELD_usec(1000000);
  // announce the threader version
  sprintf(pt_serial_out_buffer, "Protothreads RP2040 v1.0\n\r");
  // non-blocking write
  serial_write;
  while (1)
  {
    // print prompt
    sprintf(pt_serial_out_buffer, "input a number in the range 1-15: ");
    // non-blocking write
    serial_write;
    // spawn a thread to do the non-blocking serial read
    serial_read;
    // convert input string to number
    sscanf(pt_serial_in_buffer, "%d", &user_input);
    // update boid color
    if ((user_input > 0) && (user_input < 16))
    {
      color = (char)user_input;
    }
  } // END WHILE(1)
  PT_END(pt);
} // timer thread

// Animation on core 0
static PT_THREAD(protothread_anim(struct pt *pt))
{
  // Mark beginning of thread
  PT_BEGIN(pt);

  // Variables for maintaining frame rate
  static int begin_time;
  static int spare_time;

  // Spawn a boid
  spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 0);

  while (1)
  {
    // Measure time at start of thread
    begin_time = time_us_32();
    // Check if the reset button (GPIO 15) is pressed
    // Check if the reset button (GPIO 15) is pressed
    if (!gpio_get(15)) // Button is active low
    {
      // Reset game state
      fillRect(0, 0, SCREEN_W, SCREEN_H, BLACK); // Clear the screen
      Score_A = 0;
      Score_B = 0;
      WinningScore_A = 0;
      WinningScore_B = 0;
      lastY_A = (SCREEN_H - PADDLE_H) / 2;
      lastY_B = (SCREEN_H - PADDLE_H) / 2;
      spawnBoid(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, 0);
      reset_board();

      // Display reset message only if not the first start
      if (!is_first_start)
      {
        setTextColor(WHITE);
        setTextSize(2);
        setCursor(200, 200);
        writeString("Game Reset!");
        sleep_ms(2000);                            // Pause for 2 seconds
        fillRect(0, 0, SCREEN_W, SCREEN_H, BLACK); // Clear the screen
      }

      // Set the flag to false after the first start
      is_first_start = false;
    }
    // erase boid
    fillCircle(fix2int15(boid0_x), fix2int15(boid0_y), 4, BLACK);
    // update boid's position and velocity
    wallsAndEdges(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy);
    // draw the boid at its new position
    fillCircle(fix2int15(boid0_x), fix2int15(boid0_y), 4, ORANGE);
    // draw the boundaries and calcultate the score
    drawArena();
    calculateScore();
    draw_paddles_core0();
    int readBuffer = activeBuffer;
    reflectBallFromPaddle(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, paddleState[readBuffer].xA, paddleState[readBuffer].yA, paddleState[readBuffer].vXA);
    reflectBallFromPaddle(&boid0_x, &boid0_y, &boid0_vx, &boid0_vy, paddleState[readBuffer].xB, paddleState[readBuffer].yB, paddleState[readBuffer].vXB);
    // delay in accordance with frame rate
    spare_time = FRAME_RATE - (time_us_32() - begin_time);
    // yield for necessary amount of time
    PT_YIELD_usec(spare_time);
    // NEVER exit while
  } // END WHILE(1)
  PT_END(pt);
} // Animation thread

// Animation on core 1
static PT_THREAD(protothread_imus(struct pt *pt))
{
  // ----------  [NEW]  ----------
  static fix15 filtAX = 0, filtAY = 0, filtAZ = 0;
  static fix15 filtBX = 0, filtBY = 0, filtBZ = 0;
  const fix15 alpha = float2fix15(0.025f); // Smoothing factor for LPF
  const float gyro_coeff = 0.08f;          // deg/s → g-eq
  static int lastxA = 0, lastxB = 0;
  PT_BEGIN(pt);

  while (1)
  {
    fix15 aA[3], gA[3], aB[3], gB[3];
    mpu6050_reset(IMU_ADDR_A);
    mpu6050_reset(IMU_ADDR_B);
    mpu6050_read_raw(IMU_ADDR_A, aA, gA);
    mpu6050_read_raw(IMU_ADDR_B, aB, gB);

    // Apply low-pass filter (LPF) to smooth IMU readings
    filtAX = filtAX + multfix15(alpha, (aA[0] << 1) - filtAX);
    filtAY = filtAY + multfix15(alpha, (aA[1] << 1) - filtAY);
    filtAZ = filtAZ + multfix15(alpha, (aA[2] << 1) - filtAZ);

    filtBX = filtBX + multfix15(alpha, (aB[0] << 1) - filtBX);
    filtBY = filtBY + multfix15(alpha, (aB[1] << 1) - filtBY);
    filtBZ = filtBZ + multfix15(alpha, (aB[2] << 1) - filtBZ);

    // ------------------ PLAYER A (left) ------------------
    int xA = mapAxisToRange(-filtAZ, XA_RANGE); // Horizontal
    int yA = mapAxisToRange(filtAX, Y_RANGE);   // Vertical
    int tiltA = -fix2int15(multfix15(filtAZ, int2fix15(MAX_TILT_PX)));

    // Clamp Player A's paddle position to its range
    xA = clamp(xA, 0, XA_RANGE);
    yA = clamp(yA, 0, SCREEN_H - PADDLE_H);

    // ------------------ PLAYER B (right) ------------------
    int xB = XB_MIN + mapAxisToRange(filtBZ, XB_RANGE); // Horizontal
    int yB = mapAxisToRange(filtBX, Y_RANGE);           // Vertical
    int tiltB = fix2int15(multfix15(filtBZ, int2fix15(MAX_TILT_PX)));
    // Clamp Player B's paddle position to its range
    xB = clamp(xB, XB_MIN, XB_MIN + XB_RANGE);
    yB = clamp(yB, 0, SCREEN_H - PADDLE_H);

    // Update paddle state for both players
    int writeBuffer = 1 - activeBuffer;
    paddleState[writeBuffer].vXA = xA - lastxA;
    paddleState[writeBuffer].vXB = xB - lastxB;
    paddleState[writeBuffer].xA = xA;
    paddleState[writeBuffer].yA = yA;
    paddleState[writeBuffer].tiltA = tiltA;
    paddleState[writeBuffer].xB = xB;
    paddleState[writeBuffer].yB = yB;
    paddleState[writeBuffer].tiltB = tiltB;
    activeBuffer = writeBuffer;

    lastxA = xA;
    lastxB = xB;

    PT_YIELD_usec(IMU_UPDATE_US); // Update at 50 Hz
  }
  PT_END(pt);
}

// ========================================
// === core 1 main -- started in main below
// ========================================
void core1_main()
{
  // Add animation thread
  pt_add_thread(protothread_imus);
  // Start the scheduler
  pt_schedule_start;
}

// ========================================
// === main
// ========================================
// USE ONLY C-sdk library
int main()
{
  // initialize stio
  stdio_init_all();

  // initialize VGA
  initVGA();

  // Initialize the button (e.g., GPIO15)
  const uint BUTTON_PIN = 15;
  gpio_init(BUTTON_PIN);
  gpio_set_dir(BUTTON_PIN, GPIO_IN);
  gpio_pull_up(BUTTON_PIN); // Enable internal pull-up resistor

  // Display the welcome message
  fillRect(0, 0, SCREEN_W, SCREEN_H, BLACK); // Clear the screen
  setTextColor(BLUE);
  setTextSize(6);
  setCursor(200, 50);
  writeString("Welcome");
  setCursor(280, 150);
  writeString("To");
  setCursor(80, 250);
  writeString("Table - Tennis");
  setTextColor(WHITE);
  setTextSize(1);
  setCursor(40, 350);
  writeString("Features and Rules:");
  setCursor(40, 360);
  writeString("1. Player A is on Left and Player B is on Right");
  setCursor(40, 370);
  writeString("2. Player A uses Left IMU and Player B uses Right IMU");
  setCursor(40, 380);
  writeString("3. The paddle is slanted and can be tilted to hit the ball");
  setCursor(40, 390);
  writeString("4. The ball can spin and curve in the air");
  setCursor(40, 400);
  writeString("5. The ball can bounce off the paddle and walls");
  setCursor(40, 410);
  writeString("6. Upon hitting, You can hear a sound");
  setCursor(40, 420);
  writeString("7. The game is played to 11 points, win by difference of 2");
  setCursor(40, 430);
  writeString("8. Whoever wins 3 sets wins the game");
  setTextColor(RED);
  setTextSize(1);
  setCursor(500, 460);
  writeString("Press button to start");

  // Wait for button press
  while (gpio_get(BUTTON_PIN))
  {
    sleep_ms(100); // Poll every 100ms
  }
  // Clear the screen after button press
  fillRect(0, 0, SCREEN_W, SCREEN_H, BLACK);

  // Initialise TWO IMUs
  init_two_mpus();

  // Initialize SPI channel (channel, baud rate set to 20MHz)
  spi_init(SPI_PORT, 20000000);

  // Format SPI channel (channel, data bits per transfer, polarity, phase, order)
  spi_set_format(SPI_PORT, 16, 0, 0, 0);

  // Map SPI signals to GPIO ports
  gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
  gpio_set_function(PIN_CS, GPIO_FUNC_SPI);
  gpio_set_function(PIN_SCK, GPIO_FUNC_SPI);
  gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

  // Build sine table and DAC data table
  for (int i = 0; i < sine_table_size; i++)
  {
    raw_sin[i] = (int)(2047 * sin((float)i * 6.283 / (float)sine_table_size) + 2047); // 12-bit
    DAC_data[i] = DAC_config_chan_A | (raw_sin[i] & 0x0fff);
  }

  // Configure DMA timer 0
  dma_hw->timer[0] = (1u << 16) | (125u); // Timer frequency: 125 cycles per tick

  // Select DMA channels
  data_chan = dma_claim_unused_channel(true);
  ctrl_chan = dma_claim_unused_channel(true);

  // Setup the control channel
  dma_channel_config c = dma_channel_get_default_config(ctrl_chan);
  channel_config_set_transfer_data_size(&c, DMA_SIZE_32);
  channel_config_set_read_increment(&c, false);
  channel_config_set_write_increment(&c, false);
  channel_config_set_chain_to(&c, data_chan);

  dma_channel_configure(
      ctrl_chan,
      &c,
      &dma_hw->ch[data_chan].read_addr,
      &address_pointer1,
      1,
      false);

  // Setup the data channel
  dma_channel_config c2 = dma_channel_get_default_config(data_chan);
  channel_config_set_transfer_data_size(&c2, DMA_SIZE_16);
  channel_config_set_read_increment(&c2, true);
  channel_config_set_write_increment(&c2, false);
  dma_timer_set_fraction(0, 0x0017, 0xffff);
  channel_config_set_dreq(&c2, 0x3b); // DREQ paced by timer 0
  channel_config_set_chain_to(&c2, ctrl_chan);

  dma_channel_configure(
      data_chan,
      &c2,
      &spi_get_hw(SPI_PORT)->dr,
      DAC_data,
      sine_table_size,
      false);

  multicore_reset_core1();
  multicore_launch_core1(&core1_main);

  // add threads
  // pt_add_thread(protothread_serial);
  // You can modify these to take number of balls, alpha and other parameters as input to make it more interactive
  pt_add_thread(protothread_anim);

  // start scheduler
  pt_schedule_start;
}


            </pre>
        </div>
    </footer>

</body>
</html>
