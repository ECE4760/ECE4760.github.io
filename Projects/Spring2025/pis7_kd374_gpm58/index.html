<!DOCTYPE HTML>
<!--
	Big Picture by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Smartwatch</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async
		src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
		</script>
	</head>
	<body class="is-preload">

		<!-- Header -->
		<header id="header">
			<h1>ECE 5730 Microcontrollers Final Project: Custom Smartwatch</h1>
			<nav>
				<ul>
					<li><a href="#intro" onclick="document.getElementById('intro').scrollIntoView({ behavior: 'smooth' }); return false;">Home</a></li>
					<li><a href="#work" onclick="document.getElementById('intro').scrollIntoView({ behavior: 'smooth' }); return false;">Design</a></li>
					<li><a href="#team">About Members</a></li>
				</ul>
			</nav>
		</header>

		<style>
			table {
				width: 100%;
				border-collapse: collapse;
				margin-top: 1em;
			}
			
			th, td {
				border: 1px solid #ccc;
				padding: 12px;
				text-align: left;
				vertical-align: top;
			}
			
			th {
				background-color: #222;
				color: #fff;
			}
			
			td {
				background-color: #111;
				color: #eee;
			}
			</style>

		<!-- Intro -->
		<section id="intro" class="main style1 dark fullscreen" style="background-image: url('images/fulls/smartwatch_cad_1.png'); background-size: cover; background-position: center;">
			<div class="content">
				<header>
					<h2>ECE 5730 Microcontrollers Final Project: Custom Smartwatch</h2>
				</header>
				<h1 style="color: #dddddd; background-color: #1a8ac1; padding: 5px; border-radius: 10px; display: inline-block;">
					Welcome to our Final Project website for ECE 5730: Microcontrollers!
					Developed by: Parker Schless, Katarina Duric, and George Maidhof
					</h1>
				<footer>
					<a href="#one" class="button style2 down">More</a>
				</footer>
			</div>
		</section>

		<!-- One -->
		<section id="one" class="main style2 right dark fullscreen" style="background-image: url('images/fulls/smartwatch_layout_fcu.png'); background-size: cover; background-position: center;">
			<div class="content box style2">
				<!-- <!-- <header> -->
					<h2>Hardware Design</h2>
				</header>
				<p>Our group takes pride in our robust hardware design incorporating
					custom PCBs, a 3D-printed case, and a variety of sensors and peripherals.
				</p>
			</div>
			<a href="#two" class="button style2 down anchored">Next</a>
		</section>

		<!-- Two -->
		<section id="two" class="main style2 left dark fullscreen"class="main style2 right dark fullscreen" style="background-image: url('images/fulls/software.png'); background-size: cover; background-position: center;">
			<div class="content box style2">
				<header>
					<h2>Software Development</h2>
				</header>
				<p>To support our hardware, we have developed a comphrensive software
					package that includes a user interface, real-time NTP time updating, 
					texting, heart rate and SPO2 monitoring, activity step tracking, 
					screen orientation checking, audio recording and playing, and a stopwatch.
				</p>
			</div>
			<a href="#work" class="button style2 down anchored">Next</a>
		</section>

		<!-- Work -->
		<section id="work" class="main style3 primary">
			<div class="content">
				<header>
					<h2>Project Introduction and Motivation</h2>
				</header>
					<p style="text-align: left;"><i>The aim of this project was to create a custom smartwatch using
						a Raspberry Pi Pico W because of its great functionalities, while 
						maintaining a simple and compact design embodying industry standard 
						smartwatches and their common features.</i></p>
					<figure>
						<img src="images/fulls/smartwatch_irl.JPG" alt="Smartwatch Picture" style="width: 60%; height: auto;">
						<figcaption style="font-size: 0.8em;">An in-real-life working version of our smartwatch design</figcaption>
					</figure>
					<p style="text-align: left;">The main motivation behind this project was combining and making the 
						most out of all of the team members' individual strengths into 
						an interesting and multifaceted project we would be proud of. 
						By tackling this large and comprehensive project, we hoped to 
						gain a deeper appreciation for devices we may take for granted, 
						as well as create a project that is able to fuel our passions for 
						health and well-being. We created a wearable, interactive device 
						of similar dimensions to industry standard smartwatch 
						devices which has many capabilities such as real-time NTP 
						time updating, texting, heart rate and SPO2 monitoring, activity 
						step tracking, screen orientation checking, audio recording and 
						playing, and a stopwatch integrated. Specifically, we utilize the WiFi
						features of the Pico W for real time updating and texting.</p>
					<figure>
						<img src="images/fulls/group.jpg" alt="Project Introduction" style="width: 60%; height: auto;">
						<figcaption style="font-size: 0.8em;">Our group - Parker Schless (left), Katarina Duric (middle), George Maidhof (right)</figcaption>
					</figure>
					&nbsp;

					<figure style="max-width: 1000px; margin: auto;">
					<div style="position: relative; width: 100%; padding-bottom: 56.25%; height: 0;">
						<iframe src="https://www.youtube.com/embed/u0ErQuF8XQI"
								style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
								frameborder="0" allowfullscreen>
						</iframe>
					</div>
					<figcaption  style="font-size: 0.8em;"; margin-top: 10px;">
						Final project demo video
					</figcaption>
					</figure>
					&nbsp;
					<h2>High-Level Design</h2>
					<h3>Rationale and Sources</h3>
					<p style="text-align: left;">The rationale behind this project is that we wanted to utilize a variety of 
						sensors and peripherals to implement interesting functionalities, all of 
						which interface with the central Raspberry Pi Pico W. Additionally, we wanted to 
						complete a project which involved a complete embedded-systems design experience
						by developing both the hardware and software from scratch, while also incorporating
						our shared interests in wearable technology that promotes health. The design involves a 
						combination of hardware design, software design, systems engineering, and 
						user interface design, promoting cross-domain engineering thinking. Some 
						of the sources that were very helpful for the project include Professor 
						Adams's Github Repository, Raspberry Pi Pico Repository, Professor Land's 
						Project Demos, as well as integrated component specific libraries, all 
						of which can be found under our References section in the Appendix.</p>
					<h3>Background Math</h3>
					<p style="text-align: left;">Much of our project was centered around embedded-system-level integration
						of various components to create a cohesive and multi-functional device.
						As such, there was not a significant amount of pure mathematical background
						and analysis required for this project. However, both the heart rate/SPO2 sensor
						as well as PDM microphone processing pipeline online code repositories (links
						in the Appendix section) utilized signal processing to interpret the raw
						data from the sensors. For instance, the heart rate/SPO2 sensor works by shining
						red and IR light onto the skin and measuring the amount of light reflected back
						using tuned photodetectors. These raw values from the photodetectors are then read
						out over the I2C bus to the host, where they are processed using a series of
						algorithms to determine the heart rate and SPO2 values.</p>
					<h4>Heart Rate/SPO2 Algorithm</h4>
					<p style="text-align: left;">For heart rate detection, an average DC estimator as well as a low-pass
						FIR (finite-impulese-response) filter are used. The DC estimator updates the average value of the IR
						photodetector over the past few samples with the a new sample by tracking the
						DC component of the signal over time and smoothing out fluctuations. This
						estimator is implemented with the following library code where "p" is the pointer
						to the variable holding the average and "x" is the new sample. An estimation
						of the DC component is also returned:
					<details><summary>Click here for DC Component Estimation Code Snippet!</summary><pre style="text-align: left;">
						<code>
//  Average DC Estimator
int16_t max30102_hr_avg_dc_estimator(
  int32_t* p, 
  uint16_t x
) {
  *p += ((((long) x << 15) - *p) >> 4);
  return (*p >> 15);
}
						</code>
					</pre></details></p>
					<p style="text-align: left;">
						The low-pass FIR filter works by multiplying accumulating the input signal
						with multiplications by pre-computed coefficients in what is considered a
						convolution. By doing this, the high-frequency components of the signal are filtered out,
						to produce a more stable signal. The filter is implemented with the following library code
						where "din" is the new sample minus the estimated average from the DC estimator, 
						"cbuf" is the circular buffer of the last 32 samples, "offset" is the current index in the
						circular buffer, and "FIRCoeffs" is the array of pre-computed coefficients:
					<details><summary>Click here for Low Pass FIR Filter Code Snippet!</summary><pre style="text-align: left;">
						<code>
// Low Pass FIR Filter
int16_t max30102_hr_low_pass_fir_filter(
  int16_t         din, 
  int16_t*        cbuf, 
  uint8_t*        offset, 
  const uint16_t* FIRCoeffs
) {  
  cbuf[*offset] = din;
  int32_t z = (long)(FIRCoeffs[11]) * (long)(cbuf[(*offset - 11) & 0x1F]);
  for (uint8_t i = 0; i < 11; i++)
    z += (long)(FIRCoeffs[i]) * (long)(cbuf[(*offset - i) & 0x1F] + cbuf[(*offset - 22 + i) & 0x1F]);
  *offset = *offset + 1;
  *offset = *offset % 32;
  return(z >> 15);
}
						</code>
					</pre></details></p>
					<p style="text-align: left;">Once the signal is smoothed out using the DC estimator and low-pass FIR filter,
						a positive crossing is detected by checking if the previous sample was negative
						and the current sample is positive. If this is true, then a heartbeat has been
						detected and necessary calculations can be made to determine the heart rate as
						described later in our software implementation section.
					</p>
					<p style="text-align: left;">For SPO2 detection, we first obtain the DC mean for the infrared (IR) signal by taking a simple
						average. Next, we find the two lowest values in the IR values signal and find the
						corresponding max to use between those. This process yields values for the following 
						equation for calculation of the
						SPO2 percentage: $$an\_ratio = \frac{AC_{red} \cdot DC_{IR}}{AC_{IR} \cdot DC_{red}}$$
						where the "AC_" values are the AC components of the red and IR signals
						and the "DC_" values are the DC components of the red and IR signals.
						The result of the calculation will then be put into a circular buffer, sorted in
						ascending order, and then the median used to index into a lookup table for the
						specific percentage to use. The library code to find the maximum value between the two
						lowest points in the IR signal and compute the above formula is as follows (see
						the code repository for more details on the specifics of the algorithm):
						<details><summary>Click here for SPO2 Algorithm Code Snippet!</summary><pre style="text-align: left;">
							<code>
// find max between two valley locations 
// and use an_ratio betwen AC compoent of Ir & Red and DC compoent of Ir & Red for SPO2 
for (k = 0; k < n_exact_ir_valley_locs_count-1; k++) {
	n_y_dc_max = -16777216; 
	n_x_dc_max = -16777216; 
	if (an_ir_valley_locs[k+1]-an_ir_valley_locs[k] >3) {
			for (i = an_ir_valley_locs[k]; i < an_ir_valley_locs[k+1]; i++) {
				if (an_ir[i] > n_x_dc_max) {n_x_dc_max = an_ir[i]; n_x_dc_max_idx = i;}
				if (an_red[i] > n_y_dc_max) {n_y_dc_max = an_red[i]; n_y_dc_max_idx = i;}
		}
		n_y_ac  = (an_red[an_ir_valley_locs[k+1]] - 
							an_red[an_ir_valley_locs[k] ] )*(n_y_dc_max_idx -an_ir_valley_locs[k]);
		n_y_ac  = an_red[an_ir_valley_locs[k]] + 
							n_y_ac/ (an_ir_valley_locs[k+1] - an_ir_valley_locs[k]) ; 
		n_y_ac  = an_red[n_y_dc_max_idx] - n_y_ac; // subracting linear DC compoenents from raw 
		n_x_ac  = (an_ir[an_ir_valley_locs[k+1]] - 
							an_ir[an_ir_valley_locs[k] ] )*(n_x_dc_max_idx -an_ir_valley_locs[k]);
		n_x_ac  = an_ir[an_ir_valley_locs[k]] + n_x_ac/ (an_ir_valley_locs[k+1] - an_ir_valley_locs[k]); 
		n_x_ac  = an_ir[n_y_dc_max_idx] - n_x_ac; // subracting linear DC compoenents from raw 
		n_nume  = (n_y_ac *n_x_dc_max)>>7; // prepare X100 to preserve floating value
		n_denom = (n_x_ac *n_y_dc_max)>>7;
		if (n_denom > 0 && n_i_ratio_count < 5 && n_nume != 0) {

			// formula is ( n_y_ac *n_x_dc_max) / ( n_x_ac *n_y_dc_max)
			an_ratio[n_i_ratio_count]= (n_nume*100)/n_denom; 
			n_i_ratio_count++;
		}
	}
}
							</code>
						</pre></details>
					</p>
					<h4>PDM Compression Algorithm</h4>
					<p style="text-align: left;">A single sample produced by the PDM PIO block is 1024 bits wide. However,
						this sample must be compressed to 16 bits so that multiple such samples can
						be reasonably stored in memory, which is limited on the Pico W. This is done
						using the OpenPDMFilter library which, at a high-level, extracts each bit of
						the input sample, multiplies it with a corresponding filter coefficient, and
						accumulates the result into a 16-bit output sample. The filter coefficients
						are pre-computed and stored in a lookup table. Similar to the heart rate/SPO2
						algorithm, low-pass and high-pass filtering is used to remove high-frequency
						noise. A library code snippet which implements this is as follows:
					<details><summary>Click here for PDM Compression Algorithm Code Snippet!</summary><pre style="text-align: left;">
						<code>
for (i = 0, data_out_index = 0; i < Param->Fs / 1000; i++, data_out_index += channels) {
    Z0 = filter_tables_64[j](data, 0);
    Z1 = filter_tables_64[j](data, 1);
    Z2 = filter_tables_64[j](data, 2);
 
    Z = Param->Coef[1] + Z2 - sub_const;
    Param->Coef[1] = Param->Coef[0] + Z1;
    Param->Coef[0] = Z0;
 
    OldOut = (Param->HP_ALFA * (OldOut + Z - OldIn)) >> 8;
    OldIn = Z;
    OldZ = ((256 - Param->LP_ALFA) * OldZ + Param->LP_ALFA * OldOut) >> 8;
 
    Z = OldZ * volume;
    Z = RoundDiv(Z, div_const);
    Z = SaturaLH(Z, -32700, 32700);
 
    dataOut[data_out_index] = Z;
    data += data_inc;
  }
						</code>
					</pre></details>
					</p>
					<h3>Logical Structure</h3>
					<p style="text-align: left;">Since our system involves significant hardware as well as software design,
						we needed to prioritize the different design phases in terms of how long each 
						would take. For instance, we knew designing the PCB and waiting for it to be
						delivered would take the longest, so we prioritized the design of it first such
						that we could send it out for manufacturing as soon as possible. While the PCB's
						were being made, we utilized breadboard testing to develop our basic software 
						for menu navigation and interacting with our various peripherals that were
						accessible without the PCB, such as the OLED screen. In this way, we were able
						to structure our design process such that we could work on both our hardware
						and software in parallel to complete this large project within such a short
						time frame.</p>
					<h3>Hardware/Software Tradeoffs</h3>
					<p style="text-align: left;">With such a small package, tradeoffs needed to be made for our hardware
						selection. For instance, all of our selected components needed to be small
						enough to fit on our compact PCB. Otherwise, the design would be far too large
						to be worn comfortably on the wrist. This meant we had to choose a very small
						speaker, which ended up being too small to be driven by the DAC without an
						external amplifier. Additionally, our OLED screen and battery needed to be
						quite small to fit within the design parameters. In terms of our software,
						we were primarily limited by the amount of on-board RAM on the Pi Pico W,
						which meant we could only use 5 second audio samples for our audio recording
						and playback application. The limited range of the built-in WiFi antenna
						also meant we needed to be quite close to the access point to get a reliable
						connection.
					</p>
					<h3>Existing Designs</h3>
					<p style="text-align: left;">Apart from drawing inspiration from companies that hold numerous 
						patents related to smartwatch design ideas such as Apple, Meta, 
						and Velancell, there are not any specific patents that we were inspired 
						by. The various high-level, user-facing features of such devices like heart rate
						monitoring, real-time updating, and microphone and speaker integration
						were the primary inspiration for our design choices.</p>
					<h2>Hardware Design</h2>
					<figure>
						<img src="images/fulls/high_level_block.png" alt="High-Level Block Diagram" style="width: 80%; height: auto;">
						<figcaption style="font-size: 0.8em;">Hardware block diagram for our design. Components within the Main PCB box are mounted on the main PCB, 
							and components within the Heart Rate PCB box are mounted on the heart rate daughter board. Components
							outside the boards are mounted within the 3D-printed case.</figcaption>
						</figcaption>
					</figure>
					&nbsp;
					<h3>PCB Design</h3>
					<p style="text-align: left;">Our hardware design is centered around our custom 2-layer PCB built to house 
						all components in as compact of a package as possible. This compactness 
						was our driving design principle as we did not want our watch to be 
						unwieldy on the wrist, and we were aiming to have a similar form factor 
						as an Apple Watch. To do this, we considered the placement of the largest 
						components first: the Pico W and the OLED screen. Specifically, we placed 
						the Pico W lengthwise on the back of the PCB, and the OLED screen on the 
						front. Incidentally, the mounting holes for the OLED screen fit just 
						outside the width of the Pico W, meaning we did not have any issues with 
						their bounding boxes colliding. We also placed these components based on 
						the intended direction the watch was to be worn on the wrist, 
						specifically so that a typical right-handed person who would wear a 
						watch on their left wrist would see the screen in the correct orientation 
						(so that we would not have to do any 180 degree flips in software) and the 
						Pico W's antenna would face outward from their wrist to have the 
						best signal integrity. After placing these largest components, we 
						placed the other smaller components in the voids remaining on the 
						board. For the microphone and speaker, it was critical that they 
						were on opposite sides of the board so as to not cause feedback 
						issues, although this did not end up being an issue as we 
						eventually replaced our tiny speaker with a standard 3.5mm headphone 
						jack as the speaker was not suitable to be driven without an 
						on-board amplifier. As such, the microphone was placed at the top left 
						and the speaker/DAC output at the top right. Next, we placed the 1.8V 
						LDO and LiPo connector on the bottom left of the board, and the 6-pin 
						JST connector for the heart rate "daughter" board on the bottom right. 
						For the heart rate sensor itself, we made a separate 2-layer daughter board 
						for it as well as the decoupling capacitors since it needs to press 
						tightly against the skin in order to work properly, and this could 
						not be accomplished if put on the main board. We also placed the DAC 
						and IMU on the right side of the board, as well as the three buttons 
						on the left side, with various decoupling capacitors and resistors 
						placed in any spare locations on either side of the board.</p>
					<figure>
						<img src="images/fulls/smartwatch_schem.png" alt="Smartwatch Main Board Schematic" style="width: 80%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch main board schematic</figcaption>
					</figure>
					<figure>
						<img src="images/fulls/smartwatch_layout_fcu.png" alt="Smartwatch Main Board Front Copper Layout" style="width: 80%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch main board front copper layout</figcaption>
					</figure>
					<figure>
						<img src="images/fulls/smartwatch_layout_bcu.png" alt="Smartwatch Main Board Back Copper Layout" style="width: 80%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch main board back copper layout</figcaption>
					</figure>
					<figure style="display: flex; flex-direction: column; align-items: center;">
						<img src="images/fulls/smartwatch_hr_schem.png" alt="Smartwatch Heart Rate Board Schematic" style="width: 80%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch heart rate board schematic</figcaption>
					</figure>
					<figure style="display: flex; flex-direction: column; align-items: center;">
						<img src="images/fulls/smartwatch_hr_layout_fcu.png" alt="Smartwatch Heart Rate Board Front Copper Layout" style="width: 20%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch heart rate board front copper layout</figcaption>
					</figure>
					<figure style="display: flex; flex-direction: column; align-items: center;">
						<img src="images/fulls/smartwatch_hr_layout_bcu.png" alt="Smartwatch Heart Rate Board Back Copper Layout" style="width: 20%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch heart rate board back copper layout</figcaption>
					</figure>

					&nbsp;

				<section class="tiles">

					<!-- Tile 1 -->
					<article class="style1" onclick="openModal('modal1-hw')">
						<span class="image">
						<img src="images/thumbs/01.jpg" alt="Pi Pico W" />
						</span>
						<a href="javascript:void(0);">
						<h2>Pi Pico W</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
							
					<!-- Tile 2 -->
					<article class="style2" onclick="openModal('modal2-hw')">
						<span class="image">
						<img src="images/thumbs/04.jpg" alt="Low-Dropout Regulator (LDO)" />
						</span>
						<a href="javascript:void(0);">
						<h2>Low-Dropout Regulator (LDO)</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
							
					<!-- Tile 3 -->
					<article class="style3" onclick="openModal('modal3-hw')">
						<span class="image">
						<img src="images/thumbs/05.jpg" alt="OLED Screen" />
						</span>
						<a href="javascript:void(0);">
						<h2>OLED Screen</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
					
					<!-- Tile 4 -->
					<article class="style1" onclick="openModal('modal4-hw')">
						<span class="image">
						<img src="images/thumbs/01.jpg" alt="Angle Rate Sensor" />
						</span>
						<a href="javascript:void(0);">
						<h2>Angle Rate Sensor</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
							
					<!-- Tile 5 -->
					<article class="style2" onclick="openModal('modal5-hw')">
						<span class="image">
						<img src="images/thumbs/04.jpg" alt="DAC and 3.5mm Out" />
						</span>
						<a href="javascript:void(0);">
						<h2>DAC and 3.5mm Out</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
					
					<!-- Tile 6 -->
					<article class="style3" onclick="openModal('modal6-hw')">
						<span class="image">
						<img src="images/thumbs/05.jpg" alt="PDM Microphone" />
						</span>
						<a href="javascript:void(0);">
						<h2>PDM Microphone</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
							
					<!-- Tile 7 -->
					<article class="style1" onclick="openModal('modal7-hw')">
					<span class="image">
						<img src="images/thumbs/01.jpg" alt="Heart Rate/SPO2 Sensor" />
					</span>
					<a href="javascript:void(0);">
						<h2>Heart Rate/SPO2 Sensor</h2>
						<div class="content">
						<p>Click to learn more</p>
						</div>
					</a>
					</article>
				</section>

						

			  <!-- Modals -->
				<div id="modal1-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal1-hw')">&times;</span>
				  <h2>Pi Pico W</h2>
				  <img src="images/fulls/pico_w_cad.png" class="modal-img" />
				  <p style="text-align: left;">A Pico W was necessary for this build as we required WiFi for the 
						network connection to obtain the real time and incorporate texting 
						abilities. The nominal 3.2V to 4.2V LiPo voltage is received on 
						the VSYS pin of the Pico which in turn generates a constant 3.3V 
						to be used by peripheral devices. Three buttons were also attached 
						to the Pico: a reset button used for resetting the main loop as well as 
						sending the Pico to bootsel mode on a double press, as well as a 
						select and cycle button used for control of the user interface. 
						Additionally, we use a simple voltage divider to divide down the 
						LiPo voltage to a range that fits within the 3.3V limit of the LDO 
						such that we can use the voltage of the LiPo as a proxy for battery 
						percentage in software.</p>
				</div>
			  </div>

			  <div id="modal2-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal2-hw')">&times;</span>
				  <h2>Low-Dropout Regulator (LDO)</h2>
				  <img src="images/fulls/ldo_cad.png" class="modal-img" />
				  <p style="text-align: left;">An LDO (low-dropout regulator) is required to generate the 
						1.8V supply voltage for the heart rate sensor. We chose the 
						TLV76701DRVR from Texas Instruments since the output voltage 
						can be easily adjusted using a resistive divider. When using 
						LDO's, it is important to ensure the output voltage is sufficiently 
						less than the input voltage, such that it satisfies the 
						"dropout voltage," a parameter that defines the margin 
						needed by the LDO to stabilize the output voltage generated 
						from the input voltage. In this way, LDO's can only step down 
						voltages, but are integrated in a much smaller package than 
						buck converters which serve the same purpose.</p>
				</div>
			  </div>

			  <div id="modal3-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal3-hw')">&times;</span>
				  <h2>OLED Screen</h2>
				  <img src="images/fulls/oled_cad.png" class="modal-img" />
				  <p style="text-align: left;">To keep the cost of our device down, we chose a generic 128x64 
						OLED screen module using the common SSH1106 display driver. 
						The screen is also quite compact with a 1.3" diagonal and 
						thus a high PPI (pixels per inch) count for sharp text. It is 
						also a graphics display as opposed to a character display, 
						meaning any graphic can be easily displayed on the screen by 
						writing to each individual pixel. This device operates at a 
						standard 3.3V and communicates over I2C, making it ideal for 
						this application.</p>
				</div>
			  </div>

			  <div id="modal4-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal4-hw')">&times;</span>
				  <h2>Angle Rate Sensor</h2>
				  <img src="images/fulls/angle_cad.png" class="modal-img" />
				  <p style="text-align: left;">We originally wanted to use the MPU6050 integrated IMU used 
						in Lab 3, but found that the individual IC is no longer stocked 
						at DigiKey. As such, we decided to use the I3G4250D angular rate 
						sensor instead, which also has fewer pins than the MPU6050 
						making it ideal for soldering. While a traditional IMU incorporates 
						both an accelerometer and gyroscope which can provide values for 
						the actual orientation of the sensor in space at any given time, 
						the angular rate sensor only detects changes in angle, meaning all 
						X, Y, and Z values will be 0 in any orientation if the sensor is 
						not rotating. This device operates at a standard 3.3V and 
						communicates over I2C, making it ideal for this application.</p>
				</div>
			  </div>
	
			  <div id="modal5-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal5-hw')">&times;</span>
				  <h2>DAC and 3.5mm Out</h2>
				  <img src="images/fulls/dac_cad.png" class="modal-img" />
					<p style="text-align: left;">We chose the MCP4822 DAC used from Lab 1 and Lab 2 to make it 
						easier to develop software for it, given we could reuse a lot of 
						our code from those previous labs. This device takes digital SPI 
						signals from the Pico W and converts them into an analog output, 
						suitable for driving some sort of audio output device. We originally 
						intended to hook this up directly to a mini 8-ohm speaker, but found 
						during testing that the DAC expected a high-impedance load such as 
						a dedicated audio amplifier IC which we did not include on our PCB. 
						However, including this amplifier IC would have caused a noticeable 
						increase in PCB size as we would not have had space to fit it on our existing design. Thus, 
						we swapped the speaker for a standard 3.5mm headphone jack so that 
						we could plug our own audio output device into the smartwatch. While we
						obviously did not have the correct footprint for this jack on the board,
						we soldered short wires directly onto the jack's leads and into the 
						througholes for the speaker wires. We then hot-glued the jack in place. We 
						envision a compact solution such as wired Apple EarPods as being 
						plugged into the device which have their own audio amplifier and 
						volume controller on-board. This also contributes to the discrete 
						nature of the watch, as a loudspeaker may be too noticeable in 
						typical use cases. This DAC communicates over a standard 
						unidirectional 3-wire SPI interface from controller to peripheral 
						only, making it ideal for small PCB's where routing space is limited.</p>
				</div>
			  </div>
	
			  <div id="modal6-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal6-hw')">&times;</span>
				  <h2>PDM Microphone</h2>
				  <img src="images/fulls/pdm_mic_cad.png" class="modal-img" />
				  <p style="text-align: left;">Purely analog microphones are notoriously hard to get clean 
						audio out of without significant DSP code, which would have surely 
						eaten into our resources on the Pico W. Instead, we chose to use 
						a digital microphone implementing the PDM (pulse density modulation) 
						two-wire interface so that the Pico need only deal with digital 
						signals from the microphone. Specifically, we chose the SPH0641LM4H-1 
						bottom-ported microphone due to its small size and bottom-facing 
						port, meaning debris would not clog the hole had it been an 
						upward-facing design. Such considerations are necessary for 
						smartwatches given they are much more likely to face harsh 
						conditions than, say, a laptop. The port is also ground-shielded 
						around the perimeter, meaning it has good noise-reduction 
						capabilities, again suitable for harsh conditions.</p>
				</div>
			  </div>

			  <div id="modal7-hw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal7-hw')">&times;</span>
				  <h2>Heart Rate/SPO2 Sensor</h2>
				  <img src="images/fulls/heartrate_cad.png" class="modal-img" />
				  <p style="text-align: left;">A fundamental feature of many modern smartwatches is the ability 
						to measure heart rate. However, not all watches can also measure 
						SPO2, or percent oxygen in the blood. Fortunately for us, Texas 
						Instruments makes an all-in-one heart rate and SPO2 sensor in a 
						compact package suitable for a smartwatch form factor called the 
						MAX30102. This device works by incorporating red and IR LEDs that 
						shine light onto the skin. A certain amount of this light gets 
						absorbed by the blood based on how much volume is pumped through 
						the veins. Photodetectors in the sensor measure the amount of 
						light reflected back, which is inversely proportional to the 
						amount of light absorbed. Using software algorithms, these reflected 
						light readings can be translated into both a beats per minute 
						reading as well as an SPO2 reading. The device requires a 1.8V 
						nominal power supply from the LDO, a 3.3V LED driver power supply, 
						and I2C connections to communicate with the host. All of these 
						nets are run over the 6-pin JST connector that connects the main 
						PCB to the heart rate daughter board.</p>
				</div>
			  </div>
			  &nbsp;

				<h3>3D-Printed Case</h3>
				<p style="text-align: left;">Given our size constraints for our custom PCB, we needed to design 
					a 3D-printable case that would mount the PCB, the LiPo battery, and the 
					heart rate daughter board together in one compact package while 
					also allowing for cable management and holes for the nylon wrist 
					straps. To do this, we utilized the four mounting holes of the 
					screen as our main connecting structure for the entire "sandwich," 
					running M2.5x20 screws through them and mounted to the underlying 
					case through 3D-printed cylinders. The LiPo battery sits directly 
					below the Pico W and was chosen to have a width less than the 
					distance between the mounting cylinders. We also needed to make 
					sure the Pico W USB port was easily accessible so we could program 
					it. The heart rate sensor daughter board is mounted directly behind 
					the battery using some M2.5x8 screws to secure it to the surface, 
					whose depth was chosen so that the surface of the heart rate sensor 
					would sit flush against the wrist. There is also ample room under 
					the PCB for routing the LiPo and heart rate sensor cables so that 
					they do not get in the way of normal operation. Rectangular slits 
					are also lengthwise on the bottom surface where 1" wide nylon straps 
					were mounted so that the watch could be worn on the wrist. A simple 
					nylon clip design was also made to secure the strap in place when 
					worn.</p>
				<figure>
					<img src="images/fulls/smartwatch_cad_1.png" alt="3D-Printed Case CAD 1" style="width:80%; height: auto;">
					<figcaption style="font-size: 0.8em;">3D-printed case CAD angle 1</figcaption>
				</figure>
				<figure>
					<img src="images/fulls/smartwatch_cad_2.png" alt="3D-Printed Case CAD 2" style="width:80%; height: auto;">
					<figcaption style="font-size: 0.8em;">3D-printed case CAD angle 2</figcaption>
				</figure>
				<figure>
					<img src="images/fulls/smartwatch_cad_3.png" alt="3D-Printed Case CAD 3" style="width:80%; height: auto;">
					<figcaption style="font-size: 0.8em;">3D-printed case CAD angle 3</figcaption>
				</figure>
				<figure>
					<img src="images/fulls/smartwatch_cad_4.png" alt="3D-Printed Case CAD 4" style="width:80%; height: auto;">
					<figcaption style="font-size: 0.8em;">3D-printed case CAD angle 4</figcaption>
				</figure>
				&thinsp;
				<h2>Costs</h2>
				<p style="text-align: left;">Project specifications required our total unit cost to be under 
					$125. We selected our parts using this as a guiding constraint. 
					Even accounting for $15 worth of price slack for passive components, 
					connectors, straps, hardware, etc., we are still well under the 
					$125 budget constraint at just around $64 per smartwatch excluding 
					shipping/customs for the custom PCBs.</p>
					<table border="1" cellpadding="8" cellspacing="0">
					<caption style="caption-side: bottom; font-size: 1em; margin-top: 10px;">
						Total Cost of components
					</caption>
					<thead>
						<tr>
						<th>Part</th>
						<th>Qty/Board</th>
						<th>Unit Price ($)</th>
						<th>Total Price ($)</th>
						</tr>
					</thead>
					<tbody>
						<tr>
						<td>Main PCB</td>
						<td>1</td>
						<td>0.86</td>
						<td>0.86</td>
						</tr>
						<tr>
						<td>Daughter PCB</td>
						<td>1</td>
						<td>0.41</td>
						<td>0.41</td>
						</tr>
						<tr>
						<td><a href="https://www.amazon.com/Raspberry-Pi-Pico-Wireless-Bluetooth/dp/B0B5H17CMK/ref=sr_1_5?crid=PQTLCEFRZFWQ&dib=eyJ2IjoiMSJ9.7CmGzjTpLh5397VPR9ybT24Rc46hgyc287VUutT3S_Hk_iYi6MDYZaeb27zuHGqsviXrW4IK106l5JvpCLEjaztyJnYnUnzaXRj92VMAag4v_F2axztdBShKbl8D4vLzOgUbH5ya1QE5afMxQl6sxc7F-P1__mm_0toeoWu9mbqr_RiHqgiO8z3FdsXiiEKijFE4wKdVrbCoIGt26voltr7eBae5wWKqwgG3SC3KG7c.H2ZAco2Q31ao8neRRp0-VtoJMo13mh8TDgkUIxXRfmk&dib_tag=se&keywords=pico+w&qid=1747179213&sprefix=pico+%2Caps%2C112&sr=8-5">Pi Pico W</a></td>
						<td>1</td>
						<td>10.99</td>
						<td>10.99</td>
						</tr>
						<tr>
						<td><a href="https://www.amazon.com/Hosyond-Display-Compatible-Arduino-Raspberry/dp/B0C3L7N917/ref=sr_1_2_sspa?crid=1WM1DPDK5HODY&dib=eyJ2IjoiMSJ9.58hVCpHB84ehQZ-yEi0ombKegJy6sMGLFEVEkkcjVHg4PfgzQYJ7BEIyE65x5gsMs-J2wjjdUv9z2kwAahZc94cNX-6tHFWGQ6pwWcOS8lyzug6k3PMby1HJSWEiQqHGBLEa0_AM9Hd-xiumvuF2FxaQV5GMH60JStK7Na2-g_I07cEHM-FO6GbRAUZ-w2me0AUE9b4p9mYn2lDwTjgYXoaJUMQ_K2QEVbU8o6hUTqk.mujYzHtN9jCkAToKsJz2Ax4WSQaaXe22_YFtI2-6izo&dib_tag=se&keywords=oled%2Bscreen&qid=1742094816&sprefix=oled%2Bscreen%2Caps%2C135&sr=8-2-spons&sp_csd=d2lkZ2V0TmFtZT1zcF9hdGY&th=1">OLED Screen</a></td>
						<td>1</td>
						<td>3.60</td>
						<td>3.60</td>
						</tr>
						<tr>
						<td><a href="https://www.amazon.com/sea-jump-Lithium-Quadcopter-Aircraft/dp/B07SLLVQ2Q/ref=sr_1_6?crid=3HDGDGMWOF7RC&dib=eyJ2IjoiMSJ9.MPvpqWiGH3hTueLyQogqhr8ah2V-7YexDvRKFDypc_S8Hcqvq8ECRT3QDh6EiOJzUyRH0yISLxLGyprnw1CPiTgSXL1d-HfbflJKEJx5Fsk2b0rmBIxx3Jtkda1p4REeGWvSOdz9nvSmkzRsTolBDWjX9bpWBpvfuElRYWU8n-qrjpRkfqDZQYJB5_JX2emoilnSyRkqFFCQDmoJEzHJz1h3kAFvP50mMD3P3sKUXxIYFcrBMHiA-fjL06q9-XBlz6YIz_cSl6cEvwF2F10me6VKSWiGchkp8OeKnXsMVJ8.xLy4sHIKKNsBuSyABoIyqjQzScRg5trvZP6ChcgByx8&dib_tag=se&keywords=3.7V+lipo+battery&qid=1743805949&sprefix=3.7v+lipo+battery%2Caps%2C110&sr=8-6">1S LiPo</a></td>
						<td>1</td>
						<td>3.00</td>
						<td>3.00</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/syntiant/SPH0641LM4H-1/5052769">PDM Microphone</a></td>
						<td>1</td>
						<td>1.06</td>
						<td>1.06</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/same-sky-formerly-cui-devices/SJ3-35094AG/24627966">3.5mm Jack</a></td>
						<td>1</td>
						<td>1.02</td>
						<td>1.02</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/analog-devices-inc-maxim-integrated/MAX30102EFD-T/6188734?s=N4IgTCBcDaIAQFkCCANAzABgIwbAUQDEARAagBUQBdAXyA">Heart Rate/SPO2 Sensor</a></td>
						<td>1</td>
						<td>12.04</td>
						<td>12.04</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/stmicroelectronics/I3G4250DTR/5268011">Angle Rate Sensor</a></td>
						<td>1</td>
						<td>8.89</td>
						<td>8.89</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/microchip-technology/MCP4822-E-SN/951466">DAC</a></td>
						<td>1</td>
						<td>3.97</td>
						<td>3.97</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/texas-instruments/TLV76701DRVR/10434713?s=N4IgTCBcDaIC4BsBuB2AbCgDARgCYCcl8QBdAXyA">LDO</a></td>
						<td>1</td>
						<td>0.32</td>
						<td>0.32</td>
						</tr>
						<tr>
						<td><a href="https://www.digikey.com/en/products/detail/omron-electronics-inc-emc-div/B3U-1000P-B/2567950">Buttons</a></td>
						<td>3</td>
						<td>0.98</td>
						<td>2.94</td>
						</tr>
						<tr>
						<td>Misc Passives</td>
						<td>1</td>
						<td>~5.00</td>
						<td>5.00</td>
						</tr>
						<tr>
						<td>Misc Connectors</td>
						<td>1</td>
						<td>~5.00</td>
						<td>5.00</td>
						</tr>
						<tr>
						<td>Misc Hardware</td>
						<td>1</td>
						<td>~5.00</td>
						<td>5.00</td>
						</tr>
						<tr>
						<td colspan="3" style="text-align: right; font-weight: bold;">Total</td>
						<td style="font-weight: bold;">64.10</td>
						</tr>
					</tbody>
					</table>

					<h2>Software Design</h2>
					<h3>Directory Structure</h3>
					<p style="text-align: left;">We structure our directory to have a main .c file for our primary 
						software loop, with a corresponding .h and .c file for each peripheral 
						we use on our board. For instance, we have a .h/.c pair for our OLED 
						screen, our heart rate sensor, and our angle rate sensor. Such structure 
						allows for clear hierarchy and abstraction in our code to make it more 
						readable and extensible for future iterations. To simplify includes, 
						we also have a common.h file that every .h file includes that has 
						common libraries such as stdio, math, string, and common definitions 
						that are needed by nearly every .c dependency. For our custom screen 
						images, we have a dat/ subdirectory that contains an array of (x,y) 
						coordinates for each image we draw on the screen as generated by our 
						image_convert.py Python script.</p>
					<h3>Initialization</h3>
					<p style="text-align: left;">During initialization, we include a power-on-reset delay of 10 ms 
						to allow all voltages to stabilize and all peripherals to properly 
						start up. We then initialize our I2C and SPI busses, as well as 
						initialize the GPIOs for the select and cycle buttons to be inputs 
						with internal pull-downs enabled. We also initialize the ADC for 
						the LiPo voltage reading, as well as call the initialization functions 
						for the OLED screen, the angle rate 
						sensor, the PDM microphone, and the heart rate sensor. Such initialization 
						functions write configuration registers within each device to set it 
						up to take the measurements we desire in our software. Next, we connect 
						to WiFi using the wifi_udp_init() function to obtain a MAC and IP address 
						for the Pico, as well as start the UDP threads for sending and receiving 
						data via UDP packets. In this function, we connect to a beacon, in our 
						case a WiFi hotspot, and receive our IP address back when connected. The 
						status of this connection is shown on the OLED screen, and will time out 
						after 10 seconds if a connection to the pre-programmed SSID in the 
						wifi_udp.c file cannot be obtained. If successful, we are able to 
						instantly poll using network time protocol to receive the real time 
						in EST. A message indicating a connection's success or failure is 
						written to the screen as a result. Next, the core 1 thread is launched 
						which handles the main menu checking and other basic functionalities. 
						Then, the main thread continues to its own loop on core 0 which grabs 
						the latest text message from UDP and fills the character buffer. The 
						UDP operations are performed on a separate core since they are quite 
						resource-intensive and we found that using only a single core caused 
						interference with the SPI interface to the DAC for reasons unknown.</p>
					<h2>Menu Loop</h2>
					<figure>
						<img src="images/fulls/smartwatch_menu.png" alt="Smartwatch Menu" style="width:100%; height: auto;">
						<figcaption style="font-size: 0.8em;">Smartwatch menu flow diagram. Actions that cause a transition to occur
							are seen on the transition arrows' edges, where CYC corresponds to the press
							of the CYC button, and SEL corresponds to a press of the SEL button. Example
							content that is displayed on the OLED screen is seen in the rectangles.</figcaption>
					</figure>

					&nbsp;
				<section class="tiles">

					<!-- Tile 1 -->
					<article class="style1" onclick="openModal('modal1-sw')">
						<span class="image">
						<img src="images/thumbs/01.jpg" alt="Screen Orientation Check" />
						</span>
						<a href="javascript:void(0);">
						<h2>Screen Orientation Check</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
			  
					<!-- Tile 2 -->
					<article class="style2" onclick="openModal('modal2-sw')">
						<span class="image">
						<img src="images/thumbs/04.jpg" alt="Real-Time NTP Update" />
						</span>
						<a href="javascript:void(0);">
						<h2>Real-Time NTP Update</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
					
					<!-- Tile 3 -->
					<article class="style3" onclick="openModal('modal3-sw')">
						<span class="image">
						<img src="images/thumbs/05.jpg" alt="Texting" />
						</span>
						<a href="javascript:void(0);">
						<h2>Texting</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
			  
					<!-- Tile 4 -->
					<article class="style1" onclick="openModal('modal4-sw')">
						<span class="image">
						<img src="images/thumbs/01.jpg" alt="Heart Rate and SPO2 Monitoring" />
						</span>
						<a href="javascript:void(0);">
						<h2>Heart Rate and SPO2 Monitoring</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
					
					<!-- Tile 5 -->
					<article class="style2" onclick="openModal('modal5-sw')">
						<span class="image">
						<img src="images/thumbs/04.jpg" alt="Activity Tracking" />
						</span>
						<a href="javascript:void(0);">
						<h2>Activity Tracking</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
			  
					<!-- Tile 6 -->
					<article class="style3" onclick="openModal('modal6-sw')">
						<span class="image">
						<img src="images/thumbs/05.jpg" alt="Stopwatch" />
						</span>
						<a href="javascript:void(0);">
						<h2>Stopwatch</h2>
						<div class="content">
							<p>Click to learn more</p>
						</div>
						</a>
					</article>
			  
					<!-- Tile 7 -->
					<article class="style1" onclick="openModal('modal7-sw')">
					<span class="image">
						<img src="images/thumbs/01.jpg" alt="Audio Recording" />
					</span>
					<a href="javascript:void(0);">
						<h2>Audio Recording</h2>
						<div class="content">
						<p>Click to learn more</p>
						</div>
					</a>
					</article>
			  
					<!-- Tile 8 -->
					<article class="style2" onclick="openModal('modal8-sw')">
					<span class="image">
						<img src="images/thumbs/04.jpg" alt="Info Screen" />
					</span>
					<a href="javascript:void(0);">
						<h2>Info Screen</h2>
						<div class="content">
						<p>Click to learn more</p>
						</div>
					</a>
					</article>
			  
					<!-- Tile 9 -->
					<article class="style3" onclick="openModal('modal9-sw')">
					<span class="image">
						<img src="images/thumbs/05.jpg" alt="Button Debouncing" />
					</span>
					<a href="javascript:void(0);">
						<h2>Button Debouncing</h2>
						<div class="content">
						<p>Click to learn more</p>
						</div>
					</a>
					</article>
				</section>
			  
			  <!-- Modals -->
				<div id="modal1-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal1-sw')">&times;</span>
				  <h2>Screen Orientation Check</h2>
				  <img src="images/fulls/rotation.png" class="modal-img" />
				  <p style="text-align: left;">Upon each loop iteration, we check the current status of the angle 
						rate sensor to see if the screen needs to be turned on or off in the 
						check_screen() function. To do this, the check_screen() function 
						obtains the current value of the x-dimension angle rate, which we 
						have experimentally determined to be the dimension in which a wrist 
						rotation occurs when looking at the watch. If this value is greater 
						than 2.0g, we return a 1, indicating that the screen should turn on 
						as this corresponds to a rotation of the wrist upward. Conversely, 
						if the value is less than -2.0g, we return a -1 to indicate the screen 
						should be turned off as this corresponds to a rotation of the wrist 
						downward. In any other case, we return a 0, indicating no action 
						should be taken. This return value is then checked in the main loop. 
						If a 1 is returned, we set screen_status to 1 to indicate it should 
						be on, else if a -1 was returned, we set screen_status to 0 to 
						indicate the screen should be turned off. If screen_status is a 1, 
						then we display the current state of the menu, else we clear the 
						screen so that it displays nothing. In this way, we get the same 
						functionality as off-the-shelf smartwatches that turn off the screen 
						when the user's wrist is down.</p>
					<details>
					<summary>Screen Orientation Check Code Here!</summary>
					<pre class="left-align-code">
						<code>
int check_screen() {
	float x = get_x_rateDPS();
	if (x > 2.0) return 1;
	if (x < -2.0) return -1;
	return 0; 
}

screen_rot = check_screen();
if (screen_rot == 1)  screen_status = 1;
if (screen_rot == -1) screen_status = 0;
if (screen_status) ... // do menu loop
else ... // display black screen
						</code>
					</pre>
					<table>
					<thead>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>screen_rot</td>
							<td>Return variable from check_screen(), 1 = turn screen on, -1 = turn screen off, 0 = no action</td>
						</tr>
						<tr>
							<td>screen_status</td>
							<td>Current power status of the screen, 1 = screen is on, 0 = screen is off</td>
						</tr>
					</tbody>
					</table>
				  </details>
				</div>
			  </div>

			  <div id="modal2-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal2-sw')">&times;</span>
				  <h2>Real-Time NTP Update</h2>
				  <img src="images/fulls/home_screen.png" class="modal-img" />
				  <p style="text-align: left;">Any smartwatch should be able to display the real time as pulled 
						from the network. Since we are using the Pico W, we accomplish this 
						by pulling the time via NTP upon a POR of the watch, and 
						subsequently update the time based on the internal timer 
						after this so as to not have to poll the network every second. 
						We keep a variable, ntp_time_initialized, which determines whether 
						or not the time has been initialized from the network yet. If it 
						has not, we call get_current_ntp_time() to obtain this time. If the 
						time has already been initialized, we simply check if the previous 
						update time subtracted from the current time is one second. If it 
						has been, we update the seconds, minutes, and hours variables 
						accordingly. In the event that the Pico W did not connect to the 
						network upon initialization, we simply use the uptime from power-on 
						as the time displayed. These updates happen every loop iteration so 
						that the time displayed is always accurate. If the main_menu_state 
						is currently on the MM_TIME setting, we display this real time on 
						the screen, alongside the date as pulled from NTP, the battery 
						percentage as read from the ADC, as well as an icon indicating the 
						connection status to the network. The battery percentage is 
						calculated using a custom map_batt() function which takes in the 
						minimum and maximum ADC values that correspond to the minimum and 
						maximum battery voltages of 3.2V and 4.2V, respectively, divided 
						in half as per the voltage divider on the PCB, as well as the minimum 
						and maximum battery percentages which are, of course, 0% and 100%. A 
						simple calculation using equivalent fractions is performed to convert 
						the raw ADC value into a battery percentage.</p>
					<details>
					<summary>Real-Time NTP Update Code Here!</summary>
					<pre class="left-align-code">
						<code>
// We have NTP time and this is the first initialization 
if (!ntp_time_initd && ntp_time_ready) {
	datetime_t now;
	get_current_ntp_time(&now);
	rt_hours = now.hour;
	rt_mins = now.min;
	rt_secs = now.sec;
	rt_month = now.month;
	day = now.day;
	prev_rt_secs = rt_secs;
	ntp_time_initd = true;
	rt_last_update = get_absolute_time();

// We have NTP time and we have already initialized
} else if (ntp_time_initd) {
	if (absolute_time_diff_us(rt_last_update, get_absolute_time()) >= 1000000) {
		sprintf(prev_rt_time_str, "%s", rt_time_str);
		rt_last_update = get_absolute_time();
		rt_secs++;
		if (rt_secs > 59) {
			rt_secs = 0;
			rt_mins++;
		}
		if (rt_mins > 59) {
			rt_mins = 0;
			rt_hours++;
		}
		if (rt_hours > 24){
			rt_hours = 0;
		}
	}

// NTP time has not been acquired - default to uptime
} else {
	sprintf(prev_rt_time_str, "%s", rt_time_str);
	rt_uptime_ms = time_us_64() / 1000;
	rt_hours = (rt_uptime_ms / (1000 * 60 * 60)) % 24;
	rt_mins = (rt_uptime_ms / (1000 * 60)) % 60;
	rt_secs = (rt_uptime_ms / 1000) % 60;
}
						</code>
					</pre>
					<table>
					<thread>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thread>
					<tbody>
						<tr>
							<td>ntp_time_initd</td>
							<td>1 if the NTP time has been initialized using get_current_ntp_time(), 0 otherwise</td>
						</tr>
						<tr>
							<td>rt_<hours, mins, secs></td>
							<td>Holds the value of the real time hours, minutes, or seconds</td>
						</tr>
						<tr>
							<td>prev_rt_secs</td>
							<td>Holds the previous value of rt_secs - when rt_secs is different than this, the screen is updated</td>
						</tr>
						<tr>
							<td>ntp_time_ready</td>
							<td>Indicates if the UDP module is ready to grab the NTP time</td>
						</tr>
						<tr>
							<td>rt_last_update</td>
							<td>The time uptime at which the last real time update occurred, used to check 
								if the displayed string should be updated which happens every second</td>
						</tr>
						<tr>
							<td>rt_uptime_ms</td>
							<td>Used to keep track of uptime in the event there was an unsuccessful WiFi connection</td>
						</tr>
					</tbody>
					</table>
				  </details>
				</div>
			  </div>

			  <div id="modal3-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal3-sw')">&times;</span>
				  <h2>Texting</h2>
				  <img src="images/fulls/texting.png" class="modal-img" />
				  <p style="text-align: left;">The ability to communicate between devices through texting in our 
						case is handled by UDP communication. When our watch connects 
						with the beacon and gathers an established IP address, we also 
						initialize a port for UDP communication to send and receive messages. 
						By using the netcat command on a computer, we can communicate with a hardware 
						device's specific IP and port if connected to the same SSID. 
						The watch has an IP address along with which it is constantly 
						polling on port 1234 for UDP messages. On our computer, we can 
						connect to the port and IP of the watch and send messages to it. 
						The watch interface will then receive the latest message using 
						the get_latest_udp_message() function. If the latest message is 
						different from the previous message, then we iterate through 
						each character and put a newline every 16 characters so that 
						the message will break onto the next line of the screen.</p>
					<details>
					<summary>Texting Code Here!</summary>
					<pre class="left-align-code">
						<code>
// Core 0 - handle texting and WiFi interface
while(1) {
	const char *msg = get_latest_udp_message();
	if (strcmp(msg, last_message) != 0) {
		int j = 0;
		int ypos = 10;
		for (int i = 0; i < BEACON_MSG_LEN_MAX && msg[i] != '\0' && 
				msg[i] != '\r' && msg[i] != '\n'; i++) {
			if (msg[i] >= 32 && msg[i] <= 126) {
				filtered_message[j++] = msg[i];
				if (j % 16 == 0)
					filtered_message[j++] = '\n';
			}
		}
		filtered_message[j] = '\0';
		strncpy(last_message, filtered_message, BEACON_MSG_LEN_MAX);
	}
}
						</code>
					</pre>
				  <table>
					<thead>
					  <tr>
						<th>Variable</th>
						<th>Description</th>
					  </tr>
					</thead>
					<tbody>
					  <tr>
						<td>msg</td>
						<td>Holds the latest UDP message as a character array.</td>
					  </tr>
					  <tr>
						<td>filtered_message</td>
						<td>Holds the latest UDP message as a character array with newlines and EOF's inserted for proper displaying on the screen.</td>
					  </tr>
					</tbody>
				  </table>
				  </details>
				</div>
			  </div>

			  <div id="modal4-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal4-sw')">&times;</span>
				  <h2>Heart Rate and SPO2 Monitoring</h2>
				  <img src="images/fulls/heartrate.png" class="modal-img" />
				  <p style="text-align: left;">The code for the MAX30102 is heavily adapted from Sparkfun's 
						demo code. When the heart rate screen is selected from the main 
						menu, the max30102_hr_check_for_beat() function is called once 
						per loop iteration using the latest value of the IR photodetector 
						obtained via the max30102_get_ir() function. Within this function, 
						a variety of variables are recorded to keep track of whether the 
						measured IR signal over time encounters a rising edge as it passes 
						from a negative to a positive value, with such an event indicating 
						a heartbeat has just occurred. When this happens, the function 
						returns true, else it returns false. Back in the main loop, if 
						the function has returned true, the difference in time from the 
						last time a heartbeat was detected is taken and used to directly 
						calculate the latest beats per minute (BPM). Since this value can 
						fluctuate quite easily, the BPM values, when obtained, are stored 
						in a ring buffer and averaged out to the final BPM value 
						displayed to the screen, hr_bpm_avg.</p>
					<p style="text-align: left;">If the cycle button is pressed, the sensor toggles to SPO2 mode, 
						where the percentage of oxygen in the blood is displayed. Since 
						these values are also quite volatile, a buffer of 100 entries is 
						used to store the latest red and IR photodetector values. Upon 
						every loop iteration, the last 75 values are shifted to the front 
						of the buffer, and 25 new values are read into the buffer by 
						first waiting until a new sample is ready on both the red and 
						IR photodetectors using the max30102_avail() function and then 
						retrieving these values using the max30102_get_red() and 
						max30102_get_ir() functions. Once the 25 new samples have been 
						obtained, both buffers are passed to the max30102_read_spo2() 
						function to calculate the next SPO2 value. To do this, this 
						function first subtracts the DC mean from the signal formed by 
						the values in each buffer, taking a moving average of the signal, 
						and finding the two minimum values. The maximum between these two 
						minimum values is then taken and used to do a lookup in a 
						table of precomputed percentages to output the current SPO2 
						percentage to be displayed on the screen.</p>
					<details>
					<summary>Heart Rate and SPO2 Monitoring Code Here!</summary>
					<pre class="left-align-code">
						<code>
// Currently displaying heart rate
if (hr_screen) {

	// If there is a new heart beat
	if (max30102_hr_check_for_beat(max30102_get_ir(&hr_sense), &hr_signal, fir_coeffs)) {
		long hr_bpm_delta = to_ms_since_boot(get_absolute_time()) - hr_last_beat;
		hr_last_beat = to_ms_since_boot(get_absolute_time());            
		hr_bpm = 60 / (hr_bpm_delta / 1000.0);
		if (hr_bpm < 255 && hr_bpm > 20) {

			// Store this reading in the array
			hr_rates[hr_rate_spot++] = (uint8_t)hr_bpm;

			// Wrap variable
			hr_rate_spot %= HR_RATE_SZ;

			// Take average of readings
			hr_bpm_avg = 0;
			for (uint8_t x = 0 ; x < HR_RATE_SZ ; x++)
				hr_bpm_avg += hr_rates[x];
			hr_bpm_avg /= HR_RATE_SZ;
		}
	}
	sprintf(screen_str, "BPM: %d", hr_bpm_avg);
	SSH1106_GotoXY(15, 25);
	SSH1106_Puts(screen_str, &Font_11x18, 1);
} else {

	// Shift SPO2 buffer
	for (int i = SPO2_BUFF_LEN/4; i < SPO2_BUFF_LEN; i++) {
		spo2_ir_buff[i - SPO2_BUFF_LEN/4] = spo2_ir_buff[i];
		spo2_red_buff[i - SPO2_BUFF_LEN/4] = spo2_red_buff[i];
	}

	// Fill in new values to SPO2 buffers
	for (int i = 3*SPO2_BUFF_LEN/4; i < SPO2_BUFF_LEN; i++) {

		// Wait until new sample is available
		while (!max30102_avail(&hr_sense)) max30102_hr_check(&hr_sense);
		spo2_red_buff[i] = max30102_get_red(&hr_sense);
		spo2_ir_buff[i] = max30102_get_ir(&hr_sense);
		max30102_next_sample(&hr_sense);

		// Perform SPO2 calculation
		max30102_read_spo2(
			spo2_ir_buff, 
			SPO2_BUFF_LEN, 
			spo2_red_buff, 
			&spo2_rdg, 
			&spo2_valid
		);
	}

	// Only display valid SPO2 value
	if (!spo2_valid) {
		sprintf(screen_str, "SPO2: %d", prev_spo2_rdg);
	} else {
		sprintf(screen_str, "SPO2: %d", spo2_rdg);
		prev_spo2_rdg = spo2_rdg;
	}
	SSH1106_GotoXY(15, 25);
	SSH1106_Puts(screen_str, &Font_11x18, 1);
}
						</code>
					</pre>
					<table>
					<thread>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thread>
					<tbody>
						<tr>
							<td>hr_screen</td>
							<td>1 if the app selection is on BPM, 0 if it is on SPO2</td>
						</tr>
						<tr>
							<td>hr_sense</td>
							<td>A structure containing a buffer for red and IR photodetector 
								values, as well as a head and tail pointer for the buffers</td>
						</tr>
						<tr>
							<td>hr_signal</td>
							<td>A structure holding parameters for the IR signal over time, 
								including AC max and min, value of the positive and negative 
								edge, etc.</td>
						</tr>
						<tr>
							<td>fir_coeffs</td>
							<td>A constant array holding pre-defined coefficients for 
								the FIR filter used for measuring BPM</td>
						</tr>
						<tr>
							<td>hr_last_beat</td>
							<td>The time at which the last heart beat occurred</td>
						</tr>
						<tr>
							<td>hr_bpm_delta</td>
							<td>The difference in time between the current 
								heart beat and the previous heart beat</td>
						</tr>
						<tr>
							<td>hr_bpm</td>
							<td>The instantaneous bpm as calculated with hr_bpm_delta</td>
						</tr>
						<tr>
							<td>hr_rates</td>
							<td>Array holding the last HR_RATE_SZ BPM values</td>
						</tr>
						<tr>
							<td>hr_rate_spot</td>
							<td>The index of the next entry in hr_rates</td>
						</tr>
						<tr>
							<td>hr_bpm_avg</td>
							<td>The average of the BPM's stored in hr_rates, this 
								is the BPM value displayed to the screen</td>
						</tr>
						<tr>
							<td>spo2_ir_buff</td>
							<td>Buffer holding the last SPO2_BUFF_LEN IR 
								photodetector values</td>
						</tr>
						<tr>
							<td>spo2_red_buff</td>
							<td>Buffer holding the last SPO2_BUFF_LEN red 
								photodetector values</td>
						</tr>
						<tr>
							<td>spo2_rdg</td>
							<td>The current SPO2 value</td>
						</tr>
						<tr>
							<td>prev_spo2</td>
							<td>The previous SPO2 value, written to the screen if the new value is not valid</td>
						</tr>
						<tr>
							<td>spo2_valid</td>
							<td>Indicates if the current SPO2 value in spo2_rdg is a valid reading</td>
						</tr>
					</tbody>
					</table>
					</details>
				</div>
			  </div>
	
			  <div id="modal5-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal5-sw')">&times;</span>
				  <h2>Activity Tracking</h2>
				  <img src="images/fulls/activity.png" class="modal-img" />
					<p style="text-align: left;">To detect a step using the angle rate sensor, we call the 
						update_step() function once per loop iteration to check the 
						current angular rate of change in the z-dimension, which is 
						the dimension that has been experimentally determined to be 
						in the direction of the swing of an arm during regular walking. 
						Specifically, we check to see if this value is greater than 1.2g, 
						an experimentally-determined threshold. If this condition is true 
						and the previous measured value was less than 1.2g, then we 
						increment a pointer to the step_count variable. In terms of 
						bodily movements, this corresponds to when the hand is at the 
						bottom position of the swing and is moving forward, which, with 
						normal walking, occurs once per step. The current step count is 
						displayed on the screen when that app is selected, and it can 
						be reset if the select button is pressed when in the app. 
						Otherwise, the step count since power-on will be stored 
						indefinitely.</p>
					<details>
					<summary>Activity Tracking Code Here!</summary>
					<pre class="left-align-code">
						<code>
void update_step(float* prev_z, int* step_count) {
	float z = get_z_rateDPS();
	if (z > 1.2 && *prev_z <= 1.2)
		(*step_count)++;  
	*prev_z = z;
}
						</code>
					</pre>
					<table>
					<thread>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thread>
					<tbody>
						<tr>
							<td>step_count</td>
							<td>The current number of recorded steps</td>
						</tr>
						<tr>
							<td>prev_z</td>
							<td>The last z-dimension reading from the angle rate sensor</td>
						</tr>
					</tbody>
					</table>
				  </details>
				</div>
			  </div>
	
			  <div id="modal6-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal6-sw')">&times;</span>
				  <h2>Stopwatch</h2>
				  <img src="images/fulls/stopwatch.png" class="modal-img" />
				  <p style="text-align: left;">The stopwatch code is similar to the real time code in that a 
						series of conditionals are used to check if the seconds, minutes, 
						or hours displayed should be updated, as well as using the 
						difference in current absolute time to the last updated time 
						to detect when an update should occur. However, the stopwatch 
						increments in 100s of milliseconds as opposed to one second as 
						with the real time. As such, we need an extra variable sw_decisecs 
						to hold this value. Upon entering the stopwatch app, the 
						stopwatch is not running. Only upon pressing the select button 
						will it start to run. Pressing the select button again will stop 
						the stopwatch and keep the time displayed on the screen. Pressing 
						the select button another time will resume it. By pressing the 
						cycle button to exit the stopwatch app, the stopwatch values 
						will reset to 0.</p>
					<details>
					<summary>Stopwatch Code Here!</summary>
					<pre class="left-align-code">
						<code>
// Update stopwatch values only if enabled
if (sw_en) {
	if (sw_decisecs > 9) {
		sw_decisecs = 0;
		sw_secs++;
	}
	if (sw_secs > 59) {
		sw_secs = 0;
		sw_mins++;
	}
	if (sw_mins > 59) {
		sw_mins = 0;
		sw_hours++;
	}
	if (sw_hours > 9) {
		sw_hours = 0;
	}

	// Only update screen every 100ms
	if (absolute_time_diff_us(sw_last_update, get_absolute_time()) >= 100000) {
		sw_last_update = get_absolute_time();
		sprintf(screen_str, "%01u:%02u:%02u.%d", sw_hours, sw_mins, sw_secs, sw_decisecs);
		SSH1106_GotoXY(20, 25);
		SSH1106_Puts(screen_str, &Font_11x18, 1);
		SSH1106_UpdateScreen();
		sw_decisecs++;
	}
}
						</code>
					</pre>
					<table>
					<thead>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>sw_en</td>
							<td>1 if the stopwatch is currently running, 0 otherwise</td>
						</tr>
						<tr>
							<td>sw_decisecs</td>
							<td>The current number of deciseconds (100 milliseconds)</td>
						</tr>
						<tr>
							<td>sw_<secs, mins, hours></td>
							<td>The current seconds, minutes, or hours of the stopwatch</td>
						</tr>
						<tr>
							<td>sw_last_update</td>
							<td>The time uptime at which the last stopwatch time 
								update occurred, used to check if the displayed string 
								should be updated which happens every 100 milliseconds</td>
						</tr>
					</tbody>
					</table>
				</div>
			  </div>

			  <div id="modal7-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal7-sw')">&times;</span>
				  <h2>Audio Recording</h2>
				  <img src="images/fulls/audio.png" class="modal-img" />
				  <p style="text-align: left;">Audio recording is accomplished using a serialized order of steps 
						that first records the audio sample using the Pico PDM library 
						adapted from hackster.io, storing each sample in a buffer, and then 
						playing back each sample in the buffer by sending the data to the 
						DAC using appropriate timing between messages. This sequence of 
						steps will only be executed if the audio_done_rec variable is false, 
						indicating we have not completed a recording yet. Once the recording 
						and subsequent playback is complete, the variable will be set to 
						true so that the record-and-playback loop does not repeat without user 
						intervention. If the user then presses the select button after 
						playback is done, the loop will reset, allowing the user to record 
						new audio and play it back. The PDM library works by using a PIO 
						block to generate a 1.024 MHz clock on the PDM clock line that 
						goes to the microphone. Upon receiving this clock signal, the 
						microphone will send back digitally-encoded audio data, with the 
						width of each pulse corresponding to the analog value of the 
						audio the microphone has recorded. The PIO block will also capture 
						a single digital value on the PDM data line every clock cycle. The 
						DMA controller will then capture audio at 8000 samples per second, 
						meaning each millisecond of data will contain 8 samples. An 
						interrupt handler which occurs every millisecond will capture 
						these 8 samples into a 2D audio buffer which stores 8 samples 
						at each index. When the interrupt handler is called, the outer 
						index is incremented so that the next millisecond of audio will 
						be stored in the subsequent entry. Given the RAM limitations of 
						the Pico W, we have found that we are able to have an outer length 
						value for this 2D array of 5000, which corresponds to five seconds 
						of audio since each 8-sample subarray is 1 ms worth of audio. 
						Additionally, each raw PDM data sample is 1024 bits wide, so an 
						intermediate filter, OpenPDM2PCM, is used to convert this into 
						16-bit samples to be stored in each subarray. The provided code 
						uses a 16 KHz sample rate, but we chose to use 8 KHz to save on 
						memory. We have found minimal audio degradation from halving the 
						sample rate. When starting the audio recording phase, we call the 
						pdm_microphone_start() function to enable the interrupt handler 
						which fills the array. When the array is full, which is determined 
						upon checking the current subarray index, the microphone is 
						stopped using the pdm_microphone_stop() function to disable the 
						interrupt handler from updating the audio buffer. Finally, the 
						audio samples can be written to the DAC by simply iterating through 
						each entry of each subarray one at a time, downconverting the 
						16-bit samples into 12-bit values suitable for our 12-bit DAC, 
						and writing the value to the DAC over SPI. The amount of time to 
						wait between sending each sample is determined by the DAC_DELAY 
						parameter, which is simply the inverse of the audio sample rate, 
						8 KHz. By setting the delay to this value, we ensure the playback 
						of the audio sample matches the rate at which it was recorded, 
						meaning it will sound correct. This application was definitely the 
					  hardest to write as we needed to get the timing correct to ensure
					  the audio was played back correctly. We also encountered the additional
					  problem of the WiFi connection interfering with the SPI transactions
					  to the DAC as discussed in further detail in our Challenges 
						section.</p>
					<figure>
				  	<img src="images/fulls/PDM_mic.png" style="width:30%; height: auto;" />
						<figcaption style="font-size: 0.8em;">
							PDM microphone processing block diagram. Arrows correspond to the flow of data.
						</figcaption>
					</figure>
					<details>
					<summary>Audio Recording Code Here!</summary>
					<pre class="left-align-code">
						<code>
// If we are not done recording, start recording
if (!audio_done_rec) {
	SSH1106_Clear();
	sprintf(screen_str, "Recording");
	SSH1106_GotoXY(20, 25);
	SSH1106_Puts(screen_str, &Font_11x18, 1);
	SSH1106_UpdateScreen();
	audio_samp_idx_outer = 0;

	// Start recording from PDM microphone
	pdm_microphone_start();
	while (audio_samp_idx_outer < MIC_NUM_BURSTS) tight_loop_contents();
	pdm_microphone_stop();
	SSH1106_Clear();
	sprintf(screen_str, "Playback");
	SSH1106_GotoXY(20, 25);
	SSH1106_Puts(screen_str, &Font_11x18, 1);
	SSH1106_UpdateScreen();
	audio_samp_idx_outer = 0;
	audio_samp_idx_inner = 0;

	// Start playback from stored samples to DAC
	while (audio_samp_idx_outer < MIC_NUM_BURSTS) {
		dac_value = (audio_samp_buff[audio_samp_idx_outer][audio_samp_idx_inner++] 
									+ 32768) >> 4;
		dac_msg = (DAC_CFG_A | (dac_value & 0x0FFF));
		spi_write16_blocking(SPI_PORT, &dac_msg, 1);
		if (audio_samp_idx_inner == MIC_SAMP_BUFF_SZ) {
			audio_samp_idx_inner = 0;
			audio_samp_idx_outer++;
		}
		busy_wait_us(DAC_DELAY);
	}
	audio_samp_idx_outer = 0;
	audio_samp_idx_inner = 0;
	audio_done_rec = 1;
}
						</code>
					</pre>
					<table>
					<thread>
						<tr>
							<th>Variable</th>
							<th>Description</th>
						</tr>
					</thread>
					<tbody>
						<tr>
							<td>audio_done_rec</td>
							<td>1 if a record-playback sequence has been completed, 0 otherwise</td>
						</tr>
						<tr>
							<td>audio_samp_idx_outer</td>
							<td>Current index of the 8-entry subarray of the audio sample 
								buffer, between 0 and 5000 inclusive</td>
						</tr>
						<tr>
							<td>audio_samp_idx_inner</td>
							<td>Current index within a given 8-entry subarray of the audio 
								sample buffer, between 0 and 8 inclusive</td>
						</tr>
						<tr>
							<td>dac_value</td>
							<td>The 12-bit digital audio sample to send to the DAC, 
								it has been downconverted from the original 16-bit sample</td>
						</tr>
						<tr>
							<td>dac_msg</td>
							<td>The dac_value combined with DAC_CFG_A which sets the 
								appropriate DAC channel, gain, and other parameters</td>
						</tr>
					</tbody>
					</table>
				</div>
			  </div>

			  <div id="modal8-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal8-sw')">&times;</span>
				  <h2>Info Screen</h2>
				  <img src="images/fulls/info.png" class="modal-img" />
				  <p style="text-align: left;">A simple info screen is also available which displays the IP address, 
						MAC address, and UDP port of the smartwatch given it is connected 
						to the network. This screen is essential for configuring a computer 
						to be able to send messages to the watch via our texting app.</p>
				</div>
			  </div> 

				<div id="modal9-sw" class="custom-modal">
				<div class="custom-modal-content">
				  <span class="close" onclick="closeModal('modal9-sw')">&times;</span>
				  <h2>Button Debouncing</h2>
					<figure>
						<img src="images/fulls/debounce_fsm.png" alt="Button Debounce FSM Diagram" style="width:100%; height: auto;">
						<figcaption style="font-size: 0.8em;">Button debounce FSM diagram. Actions that cause a transition to occur
							are seen on the transition arrows' edges. Actions that are taken as a result of a
							transition are seen after the backslash on the transition arrows. BUTTON refers
							to either the CYC or SEL button as both buttons have a similar debounce FSM.</figcaption>
					</figure>
					<p style="text-align: left;">For both the cycle and select buttons, we use an identical FSM as 
						in our previous labs, where we only detect a true button press upon 
						two loop iterations of detecting a pressed state, with the same for 
						a button release. Such a mechanism prevents us from detecting multiple 
						false button presses as the mechanical switch opens or closes. The 
						cycle button's main function is to switch between apps in the main 
						menu, as well as return to the main menu when in an app. 
						The select button is used to select a specific app or perform a 
						function within an app such as starting and stopping the stopwatch 
						or resetting the step count. The debounce FSM's are checked once per 
						loop iteration by calling the update_menu() function.</p>
					<details>
					<summary>Example Button Debounce Code Here!</summary>
					<pre class="left-align-code">
						<code>
int pressed = gpio_get(BUTTON);
switch (button_state) {
	case DB_NOT_PRESSED:
		if (pressed)
			button_state = DB_MAYBE_PRESSED;
		else
			button_state = DB_NOT_PRESSED;
		break;
	case DB_MAYBE_PRESSED:
		if (pressed) {
			// Do action on press
			button_state = DB_PRESSED;
		}
		else
			button_state = DB_NOT_PRESSED;
		break;
	case DB_PRESSED:
		if (pressed)
			button_state = DB_PRESSED;
		else
			button_state = DB_MAYBE_NOT_PRESSED;
		break;
	case DB_MAYBE_NOT_PRESSED:
		if (pressed)
			button_state = DB_PRESSED;
		else
			button_state = DB_NOT_PRESSED;
		break;
	default:
		button_state = DB_NOT_PRESSED;
		break;
}
					  </code>
					</pre>
					<table>
					<thead>
						<tr>
						<th>Variable</th>
						<th>Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
						<td><code>main_menu_state</code></td>
						<td>Enumerated type representing the current app selected<code>get_current_ntp_time()</code>, 0 otherwise.</td>
						</tr>
						<tr>
						<td><code>in_sub_menu</code></td>
						<td>1 if the menu FSM is currently entered into an app, 0 otherwise</td>
						</tr>
						<tr>
						<td><code>sel_pressed</code></td>
						<td>Current GPIO state of the SEL button</td>
						</tr>
						<tr>
						<td><code>sel_button_state	</code></td>
						<td>Debounce FSM state for the SEL button</td>
						</tr>
						<tr>
						<td><code>cyc_pressed</code></td>
						<td>Current GPIO state of the CYC button</td>
						</tr>
						<tr>
						<td><code>cyc_button_state</code></td>
						<td>Debounce FSM state for the CYC button</td>
						</tr>
					</tbody>
					</table>
				  </details>
				</div>
			  </div> 
			  &nbsp;

				<h3>Custom Images</h3>
				<p style="text-align: left;">Each app is represented by a small image when cycling 
					through the main menu. We generate this image 
					using our image_convert.py program that takes in a png image 
					as input, resizes it to a specified number of pixels in the x- and 
					y-directions, and extracts the pixels that are not empty by checking 
					if the alpha parameter is not equal to 0. The x and y dimensions of 
					these extracted pixels are written out to a C-style array such that 
					the array contains the (x,y) coordinates of pixels to draw to the 
					screen. Since the screen is monochrome, we need only specify the 
					(x,y) coordinates and not the color. When displaying these images 
					via the generated C-arrays stored in the dat/ subdirectory, for 
					loops can be used to iterate over each pair of (x,y) coordinates 
					and draw them to the screen.</p>
			  <h2>Design Challenges</h2>
			  <p style="text-align: left;">As previously mentioned, one challenge we ran into was not being 
					able to drive the 8-ohm speaker to a sufficient enough volume using 
					the MCP4822 DAC. To solve this, we simply replaced the speaker with 
					a 3.5mm headphone jack so that any audio output device with a built-in 
					amplifier could be used. This ended up working to our benefit, 
					however, since including an amplifier on the PCB would have 
					increased the size, and the speaker's volume would have reduced 
					the discreteness of the smartwatch we were aiming to achieve.</p>
				<p style="text-align: left;">We also intended to use the advertised temperature sensor in the 
					IMU to report real-time temperature in the user interface. Upon 
					testing, however, we discovered that the temperature sensor was 
					not very accurate, and further research on online forums revealed 
					its purpose was primarily to account for sensor drift, thus the 
					relative differences in values read from it were intended by the 
					manufacturer to be used, not the raw values.</p>
				<p style="text-align: left;">Another issue we had was related to interference between the WiFi 
					and SPI modules on the board. We found that using the texting feature 
					and then switching to the audio recording was causing the loop to 
					freeze on playback of the audio. Upon debugging, we found that the 
					spi_write16_blocking() function would work properly for a few transactions, 
					but freeze up about 100 transactions in. By temporarily disabling different 
					peripherals, we identified the issue as being related to the WiFi 
					infrastructure. To fix this, we put all WiFi-related functionality 
					on core 0, and moved all other operations to core 1. By doing this, 
					we no longer had interference between WiFi and SPI, and the audio 
					recording worked correctly.</p>
				<p style="text-align: left;">When using the PDM microphone for the first time, we found that 
					the code would also freeze when calling the pdm_microphone_stop() 
					function. By narrowing down the problem area to the dma_channel_abort() 
					function call in the pdm_microphone_stop() function, we found that 
					calling disable_interrupts() before aborting the DMA, and then calling 
					enable_interrupts() to re-enable them after aborting the DMA fixed the 
					issue.</p>
				
			  <h2>Results of Design</h2>
				<h3>Accuracy of Sensor Data</h3>
			  <p style="text-align: left;">The accuracy of our data is something our group took pride in. Our 
					real time clock accuracy was checked by comparing against the time on 
					any WiFi-connected device. After leaving the watch on for hours, we 
					confirmed that the times still matched. A similar methodology was used 
					for our stopwatch, for which we compared it against the stopwatch app 
					on an iPhone. For our heart-rate sensor, we compared the reading against 
					those provided by an Apple Watch, and found the measurements to be 
					within 10 BPM, which is quite accurate given the complexity of the 
					algorithm. While we did not have access to a dedicated pulse oximeter, 
					all three of us knew our appropriate percentages were above 95%, and 
					our SPO2 readings always showed at or above this value for all of us. 
					Step tracking was verified by walking a predetermined number of steps 
					that we counted manually and ensuring the reading on the watch matched 
					it.</p>
				<h3>Safety of Design</h3>
				<p style="text-align: left;">Additionally, ensuring safety with our watch was paramount for our 
					design. Our first priority when designing the watch was to make it 
					something practical the everyday consumer could use with limited 
					drawbacks. When designing the 3D mount and straps for the watch, we 
					were sure to make the design as sleek and comfortable as possible 
					while fitting everything inside the case. This included making sure 
					the screw heads were mounted against the wrist, instead of the other 
					way around which would cause the ends of the screws to dig into the 
					wrist. For our prototype, we made an open shell to encase everything, 
					but for a final design, we would provide some waterproofing and enclose 
					the shell to make sure all of the electronics were safe. The 
					rechargeability of the battery is something else we made sure to 
					include when making the design in that the Molex connector is easily 
					accessible. As for the sensors utilized, none have been noted to cause 
					any harm to the user, so we can be sure there are no long-term risks 
					associated with our design.</p>
				<h3>Usability of Design</h3>
				<p style="text-align: left;">As for usability, one aspect we aimed for was cost-efficiency, meaning 
					we used parts that would get the results we wanted accurately without 
					having to send much money. The placement of the components on the PCB 
					as described in the hardware section were also carefully considered to 
					allow for easy access of the buttons, as well as clear readability of 
					all on-screen elements. Finally, we originally intended for the Pico W 
					to connect to a stationary WiFi network, but eventually decided that 
					this would limit its range to a singular network. This led us to make 
					the decision to connect the watch using a phone's hotspot as most 
					people who would have a smartwatch would likely have a smartphone 
					to pair with it.</p>
				
			  <h2>Conclusions</h2>
				<h3>Meeting Expectations/Standards</h3>
        <p style="text-align: left;">In reflection, the goals we set out to meet for this project were 
					achieved. When pitching our smartwatch, our group aimed to create a 
					custom PCB that would incorporate the Pico W, an OLED screen display, 
					an angular rate sensor, mic and speaker, heart rate sensing, and a 3D 
					printed case to hold all the components.</p>
				<p style="text-align: left;">We decided to measure the success of our project in three parts. 
					These aspects would take into account the effectiveness of the watch 
					in reference to our original goal of health tracking, if we were 
					able to effectively use the sensors and components we aimed to 
					initially include, and the accuracy of the data we were able to 
					collect from the sensors. Another skill that we took away from this 
					project was the ability to distribute work among all three members 
					to create a cohesive project utilizing each other's strengths while 
					also learning new skills in the process.</p>
				<p style="text-align: left;">The original motive of this project was to take inspiration from 
					each of our passions for health and to partner it with the field of 
					electronics, hence how we came to the idea of making a smartwatch. 
					When defining the constraints for the project, we wanted to make 
					sure we could monitor someone's everyday health with sensors along 
					with using WiFi to enhance the features included. With that being 
					said, we did have some important lessons learned during this project 
					that contributed to some changes in our original design.</p>
				<p style="text-align: left;">During the first prototype of our PCB and soldering our components, 
					we found some of the components' packages to be quite challenging 
					to mount such as the IMU. Luckily, we had access to a hot plate 
					and solder paste which meant we did not have to rely solely on hand 
					soldering. Additionally, we found that the lack of an on-board 
					amplifier prevented us from using an 8-ohm speaker. As 
					such, we ended up using a standard 3.5mm headphone jack to pipe 
					the audio out to an external audio interface, which worked just fine 
					for our application as a lightweight pair of earbuds could be easily 
					plugged in and not add any bulk to the device.</p>
				<p style="text-align: left;">In the mix of the software and hardware interaction, we found that 
					data transmission was the biggest challenge as there was limited 
					documentation for implementation. One example of an obstacle we 
					faced coming into the smartwatch project was that we expected it 
					would be relatively easy to communicate with two watches as 
					walkie-talkies. There were two main limiting factors, that being 
					Pico's limited pool of RAM and the integration of TCP and UDP 
					together. With this, we managed to find some ways to integrate 
					features that would compensate. This brought about the texting 
					feature and the ability to record and playback audio samples up 
					to 5 seconds. While these objectives were not originally planned, 
					our incorporation of these shows our adaptability to solving 
					problems within the scope of our 5 week project window.</p>
				<p style="text-align: left;">In future versions of our project, we would like to include walkie-talkie 
					functionality such that two smartwatches can talk to each other
					directly over WiFi, which would be accomplished by converting audio samples
					into UDP packets and sending them over the network. Additionally, we 
					would add the ability for the watch to poll local weather data beased on 
					the assigned IP address such as temperature, cloud cover, and humidity.
					We did not include this in our project since it requires TCP, which
					requires significantly more time, effort, and system resources to
					implement compared to UDP. Along with this, obtaining an approximate 
					geolocation based on IP would also be a welcome addition. Finally,
				  we would also like to include external flash memory on the next version
				  of our smartwatch so that we can store longer audio samples and possibly
				  even entire MP3 files. This way, we could store songs and play them back
				  through the connected audio device, similar to an iPod.</p>
				<p style="text-align: left;">With the conclusion of our prototype of a smartwatch, 
					we are proud to see the work we have put in come to 
					fruition under both tight time as well as budget constraints. 
					We had established a system capable of a real-time clock, audio 
					and microphone accessibility, heart rate and oxygen tracking, 
					step count, stopwatch functionality, and text communications all 
					with a rechargeable battery and a Raspberry Pi Pico W. This system 
					made use of our experiences in PCB and circuit design, sensor data 
					extraction, and microcontroller programming. We also enhanced our 
					knowledge of communication protocols and physics related knowledge 
					of how sensors can monitor and interact with metrics related to our 
					health. Our team has met the goals we aimed to achieve coming 
					into this project and produced a completely functional product within 
					just a 5 week period.</p>
				<h3>IP Considerations</h3>
				<p style="text-align: left;">In terms of IP considerations, all of our publicly-available code
					is shown in the Appendix section. The hardware design of the smartwatch
					was fully designed by our group, as well as the non-public software code.
				</p>

				<h2>Appendix</h2>
				<h3><a href="https://github.com/pis7/ECE5730_Smartwatch_SW">Code Repository (Click Here!)</a></h3>
				<h3>Approvals</h3>
				<p style="text-align: left;">The group approves this report for inclusion on the course website.</p>
				<p style="text-align: left;">The group approves the video for inclusion on the course YouTube channel.</p>
				<h3>References</h3>
				<p><a href="https://github.com/vha3/Hunter-Adams-RP2040-Demos">Hunter Adams GitHub Repo</a></p>
				<p><a href="https://github.com/raspberrypi/pico-examples">Raspberry Pi Pico Repo</a></p>
				<p><a href="https://people.ece.cornell.edu/land/courses/projects/index_projects.html">Bruce Land Demos</a></p>
				<p><a href="https://github.com/sparkfun/SparkFun_MAX3010x_Sensor_Library/tree/master">Sparkfun MAX30102 Library</a></p>
				<p><a href="https://www.hackster.io/sandeep-mistry/create-a-usb-microphone-with-the-raspberry-pi-pico-cc9bd5">PDM Microphone Library</a></p>
				<p><a href="https://github.com/AminSahebi/OLED_SSH1106_I2C/blob/main/oled.c">SSH1106 Screen Driver Library</a></p>
				<p><a href="https://www.printables.com/model/533906-nylon-strap-retainer-clip/files">Nylon Strap Clip Design</a></p>
				<h3>Datasheets</h3>
				<p><a href="https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/20002249B.pdf">MCP4822 Datasheet</a></p>
				<p><a href="https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/1290/SPH0641LM4H-1.pdf">SPH0641LM4H-1 Microphone Datasheet</a></p>
				<p><a href="https://cdn.sparkfun.com/assets/8/3/c/3/2/MAX30102_Datasheet.pdf">MAX30102 Datasheet</a></p>
				<p><a href="https://www.ti.com/lit/ds/symlink/tlv767.pdf?HQS=dis-dk-null-digikeymode-dsf-pf-null-wwe&ts=1747126861712&ref_url=https%253A%252F%252Fwww.ti.com%252Fgeneral%252Fdocs%252Fsuppproductinfo.tsp%253FdistId%253D10%2526gotoUrl%253Dhttps%253A%252F%252Fwww.ti.com%252Flit%252Fgpn%252Ftlv767">TLV767 Datasheet</a></p>
				<p><a href="https://www.st.com/content/ccc/resource/technical/document/datasheet/e4/b1/d1/62/1a/e6/44/2f/DM00168691.pdf/files/DM00168691.pdf/jcr:content/translations/en.DM00168691.pdf">I3G4250D Datasheet</a></p>
				<h3>Tasks for Each Team Member</h3>
			  <p style="text-align: left;">Parker was responsible for the high-level 
					design of the PCB as well as the CAD for the case. He was also 
					responsible for the overall software infrastructure including the 
					menu system and basic sensor integration.</p>
			  <p style="text-align: left;">Katarina was responsible for PCB layout, 
					integration of the heart rate sensor and angle rate sensor, 
					and website design.</p>
			  <p style="text-align: left;">George was responsible for the 
					integration of the Pico W libraries to make use of UDP and 
					NTP for the real-time clock and communication between devices.</p>
			 
			  <!-- Modal JS -->
			  <script>
				function openModal(id) {
				  document.getElementById(id).style.display = 'block';
				}
			  
				function closeModal(id) {
				  document.getElementById(id).style.display = 'none';
				}
			  
				window.onclick = function(event) {
				  document.querySelectorAll('.custom-modal').forEach(modal => {
					if (event.target === modal) {
					  modal.style.display = 'none';
					}
				  });
				}
			  </script>

			<section id="team" class="main style3 secondary">
				<div class="content">
				  <header>
					<h2>About Members</h2>
					<p>We are a group of friends with different interests!</p>
				  </header>
			
				  <div class="team">

					<!-- Member 1 -->
					<div class="member">
					  <h3>Parker Schless</h3>
					  <img src="images/fulls/parker_image.png" alt="Parker">
					  <ul class="icons">
						<li>
						  <a href="https://github.com/pis7" class="icon brands fa-github" target="_blank">
							<span class="label">GitHub</span>
						  </a>
						</li>
						<li>
						  <a href="https://linkedin.com/in/parker-schless" class="icon brands fa-linkedin" target="_blank">
							<span class="label">LinkedIn</span>
						  </a>
						</li>
					  </ul>
					  
					  <p>Parker is a senior and early MEng student at Cornell University. He enjoys computer architecture and Digital VLSI.</p>
					</div>
			
					<!-- Member 2 -->
					<div class="member">
						<h3>Katarina Duric</h3>
						<img src="images/fulls/katarina_image.jpg" alt="Katarina">
						<ul class="icons">
						  <li>
							<a href="https://github.com/kd374" class="icon brands fa-github" target="_blank">
							  <span class="label">GitHub</span>
							</a>
						  </li>
						  <li>
							<a href="https://linkedin.com/in/katarina-duric" class="icon brands fa-linkedin" target="_blank">
							  <span class="label">LinkedIn</span>
							</a>
						  </li>
						</ul>
						
						<p>Katarina is a senior and early MEng student at Cornell University. She enjoys Analog and Mixed-Signal Design, and Digital VLSI.</p>
					  </div>
			
					<!-- Member 3 -->
					<div class="member">
						<h3>George Maidhof</h3>
						<img src="images/fulls/george_image.png" alt="Parker">
						<ul class="icons">
						  <li>
							<a href="https://github.com/georgemaid" class="icon brands fa-github" target="_blank">
							  <span class="label">GitHub</span>
							</a>
						  </li>
						  <li>
							<a href="https://linkedin.com/in/george-maidhof/" class="icon brands fa-linkedin" target="_blank">
							  <span class="label">LinkedIn</span>
							</a>
						  </li>
						</ul>
						
						<p>George is a senior and early MEng student 
							at Cornell University. He enjoys computer architecture and high-level synthesis.</p>
					  </div>
				  </div>
				</div>
			  </section>
			
			  <script>
				const members = document.querySelectorAll('.member');
				const observer = new IntersectionObserver(entries => {
				  entries.forEach(entry => {
					if (entry.isIntersecting) {
					  entry.target.classList.add('show');
					}
				  });
				}, { threshold: 0.1 });
			
				members.forEach(member => observer.observe(member));
			  </script>  

		<!-- Footer -->
			<footer id="footer">

				<!-- Menu -->
					<ul class="menu">
						<li>&copy; Copyright Parker Schless, Katarina Duric, and George Maidhof</li><li>Design Template: <a href="https://html5up.net">HTML5 UP</a></li>
					</ul>

			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.poptrox.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
