<!DOCTYPE html>
<html style="font-size: 16px;" lang="en"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="ECE 5730Animatronic Hand, Project Introduction, Societal Impact, High-Level Design, Logical Structure, Hardware/Software Tradeoffs, Animatronic Hand Design, Circuit Design, Software Design, Results, Conclusion, Appendix A: Permission, Appendix B: Source Code, Appendix C: Circuit Diagram, Appendix D: Task Breakdown, Appendix E: Cost Breakdown, Appendix F: References">
    <meta name="description" content="">
    <title>Main</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="Main.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery-1.9.1.min.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 5.1.5, nicepage.com">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,500,500i,600,600i,700,700i,800,800i">
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i">
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": "",
		"url": "/"
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="Main">
    <meta property="og:type" content="website">
    <link rel="canonical" href="/">
  </head>
  <body class="u-body u-xl-mode" data-lang="en">
    <section class="u-align-center u-clearfix u-container-align-center-md u-container-align-center-sm u-container-align-center-xs u-white u-section-1" id="carousel_e777">
      <div class="u-clearfix u-sheet u-valign-middle-sm u-valign-middle-xs u-sheet-1">
        <h2 class="u-align-center u-custom-font u-font-montserrat u-text u-text-1" spellcheck="false">ECE 5730<br><b>Animatronic Hand</b>
          <br>
        </h2>
        <h6 class="u-align-center u-text u-text-2">Team Member:&nbsp;Zilin Wang (zw543), Yilu Zhou (yz2797), Henry Tenecela (hft9)</h6>
        <img class="u-expanded-width u-image u-image-default u-image-1" src="images/kiborg-robot-ruka-mekhanizm.jpg" alt="" data-image-width="596" data-image-height="380">
      </div>
    </section>
    <section class="u-align-left u-clearfix u-white u-section-2" id="sec-9984">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Project Introduction</h2>
          <p id="isPasted" style="text-align: justify;">For our final project, we used a Pi Pico with several servo motors for our final project to control an Animatronic Hand. Specifically, we used these servo motors actuated by flex sensors to control the fingers of an Animatronic Hand. These flex sensors were attached to fingers on a glove enabling any user to wear this glove and actuate the animatronic hand by flexing their fingers.</p>
          <p style="text-align: justify;">The expected performance of this project is human hand can directly control each finger’s movement of the animatronic hand by moving the corresponding finger. Technology and industries are continuously looking for improvements in everyday processes. One of these improvements is precision. The motivation for our project relies on improving this level of accuracy that sometimes the human hand cannot achieve. Our project’s applications could be vast and not restricted to only one industry.</p>
          <p style="text-align: justify;">
            <br>
          </p>
          <p style="text-align: justify;">
            <br>
          </p>
          <h2 style="text-align: left;">Societal Impact</h2>
          <p id="isPasted" style="text-align: justify;">Our “Animatronic Hand” project could positively impact different industries and serve various field applications (e.g., aerospace, medical, manufacturing, and automotive). We plan to merge this intelligent system with evolving technological advancement for the betterment of society. This project’s societal impact aligns with the IEEE Code of Ethics section I., which says, “To improve the understanding by individuals and society of the capabilities and societal implications of conventional and emerging technologies, including intelligent systems.”&nbsp;</p>
          <p style="text-align: justify;">As a team, we planned to adhere to OSHA Electrical Safety Standards to ensure that all humans used in the process of this project are held to a high safety standard to avoid injuring them or their property. As mentioned above, we could use flex sensors to sense signals from the human hand. This design implicates working with sensors that contain voltage.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-white u-section-3" id="sec-2cee">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: justify;">High-Level Design</h2>
          <p id="isPasted" style="text-align: justify;">Our idea comes from two previous projects. The first project is the EMG Robotic Hand project done by Michael Haidar, Jason Hwang, and Srikrishnaa Vadivel in the Fall of 2016 (Haidar et al., n.d.). In this project, they tried to control the robotic hand by sensing the muscular contractions. They used electrodes on the arm to differentiate between signals from different fingers. Besides, they designed their instrumentation amplifier and bandpass filter to extract the small signal from the skin’s surface. The second project is the Tendon Flex Controlled Robot Hand project done by Caeli MacLennan, Cassandra Scarpa, and Parth Saraswat in the fall of 2019 (MacLennan et al., n.d.). In this project, they used a cuff on the user’s forearm to control the robotic arm. By reading the flex sensors, they could determine which finger the movement occurred on.&nbsp;</p>
          <p style="text-align: justify;">&nbsp; &nbsp; We wanted to improve the design and accuracy of the robotic hand based on their design. One major problem is that their project needed to be more accurate because the sensors were placed far away from the fingers. They tried to measure the muscular movement on the forearm to determine the finger movement, while the muscular movement was minor. The other problem is that a calibration process is necessary if someone else wants to use the system because of muscular differences from person to person.&nbsp;</p>
          <p style="text-align: justify;">&nbsp; &nbsp; To improve the system’s accuracy, we stitch the flex sensors directly onto a glove the user needs to wear. By doing so, the system’s accuracy is improved because of the apparent movement of fingers. Since everyone will have similar finger movements, we also eliminate the need for further calibration: we only need to perform one initial calibration. </p>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-white u-section-4" id="sec-8ca5">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-align-center u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Logical Structure</h2>
          <p style="text-align: justify;">After the initial calibration, the user can wear the glove. Then the Pi Pico will try to read ADC input 0, 1, and 2 sequentially and determine whether a new counter-compare is needed for the corresponding servo to control the rotational position of the servo. Then the servo will try to pull or release the string attached to it and thus increase or decrease the curvature of the cardboard finger. The cardboard finger will rely on the restoring force of the cardboard to return to the initial position after the release of the string. The whole process will repeat forever. The logical structure is as follows:</p>
          <p>
            <br>
          </p>
          <p>
            <img src="images/logic.png" align="center" style="width: 366px;" class="fr-dib fr-fic" width="342">
            <span style="line-height: 2.0;">&nbsp;</span>
          </p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-5" id="sec-a9a7">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 id="isPasted" style="text-align: justify;">Hardware/Software Tradeoffs</h2>
          <p style="text-align: justify;">We wanted to control all five cardboard fingers independently. However, the Pi Pico only had three user-usable ADC inputs. We modified the hardware and software to accommodate the number of ADCs. We modified the hardware to use three servos to change the gesture of the five fingers. The software was modified to read only three ADCs as well.</p>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-section-6" id="sec-fd55">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-align-center u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Animatronic Hand Design</h2>
          <p style="text-align: justify;">We used cardboard, straws, and strings to build the animatronic hand. We traced our hands on the cardboard, then cut out the pattern with scissors. We hinged the finger joints with the help of a knife to give a natural curl to the fingers. We attached one edge of the string to the tip of the finger and the other to the servo motors. This setup will enable the fingers to curl when the servo motor is activated. The straws helped us create a channel that would later be used to feed the strings through. The whole design comes from John Park with minor modifications to use three servos instead of four (Park, 2018). A better picture of the setup is illustrated below:</p>
          <p style="text-align: justify;">
            <br>
          </p>
          <p>
            <br>
          </p>
          <p>
            <img src="images/hand.png" align="center" style="width: 633px;" class="fr-dib fr-fic" width="512">&nbsp;
          </p>
          <p>
            <br>
          </p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-7" id="sec-3753">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2>Circuit Design</h2>
          <p id="isPasted" style="text-align: justify;">We used three flex sensors, three 22 kOhm resistors, and three servo motors to construct our circuit in this project. The flex sensor is just like a potentiometer, whose resistance would change if one bends the sensor. From this idea, we decided to mount three flex sensors on three different fingers of a glove. And one flex sensor controls the thumb servo motor, and the other two individually control two other fingers of the mechatronic hand. We only use three flex sensors because our Pi Pico only has three usable ADC pins. One way to improve this project in the future is to use a microcontroller with five usable ADC pins.&nbsp;</p>
          <p style="text-align: justify;">&nbsp; &nbsp; Then, we use three 22 kOhm resistors with three flex sensors in series to create a voltage divider. We chose 22 kOhm resistors because our flex sensor is 25 kOhm resistance, and with a similar resistance voltage divider, the change in measured voltage is more significant. After that, we will measure the voltage change of the flex sensor and use a linear function to map the voltage to corresponding Duty cycles. We will explain this later in the Software Design section.</p>
          <p style="text-align: justify;">&nbsp; &nbsp; After measuring the voltage from three different flex sensors, we connect three servo motors to three PWM output pins on the Pi Pico. And these three servo motors are connected to five fingers directly using five strings. &nbsp;We also have a serial connection directly from the Pi Pico to our computer for debugging purposes. Appendix C is the circuit diagram for your reference.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-8" id="sec-3f6f">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 id="isPasted">Software Design</h2>
          <p style="text-align: justify;">The main goal of the software design is to first read from the ADC of the Pi Pico to get the current voltage across the flex sensor. After that, we used a linear mapping from voltage to PWM compare value and then sent the PWM signal to the servo motor. Since the PWM signal controls the rotational position of the servos, we can adjust the servo position using the flex sensor and eliminate the need to use electrodes as in the initial design.</p>
          <h4 style="text-align: left;">ADC Reading</h4>
          <p id="isPasted" style="text-align: justify;">The first step is to read from the ADC on Pi Pico. The original plan is to control five servos using five fingers. There are only 4 ADCs on the Pi Pico; one is connected directly to the temperature sensor and is not usable. Therefore, we decided to use three servos and flex sensors to implement the system. Flex sensors 0, 1, and 2 will control the thumb, index finger and middle finger, ring finger, and little finger.</p>
          <p style="text-align: justify;">We use ADC channels 0, 1, and 2 from GPIO pins 26, 27, and 28 to read the flex sensor voltage. Since we need to know the maximum and minimum voltage across each flex sensor for the later mapping, a serial protothread shows us the raw readings and the converted voltage across the flex sensor. We recorded these readings and found that each flex sensor has different resistance-curvature characteristics. For example, the maximum voltage across flex sensor zero is 3.145V, while the maximum voltage across flex sensor one is 2.933V. This behavior means we must design different voltage-counter compare mappings for each flex sensor-servo pair.</p>
          <h4 style="text-align: left;">Set PWM Frequency</h4>
          <p style="text-align: justify;">
            <span style="line-height: 2.0;">The second step is to set the proper PWM frequency. Since the required PWM frequency of the servo is 50 Hz, we first used a clock divider of 250 to lower the clock frequency of the PWM channel from 125 Mhz to 500 kHz. After that, we set the PWM wrap value to 10000 so that when the PWM counter reaches 10000, it will restart from 0. Since we used the same model of servos, all three PWM channels are set to the same frequency using the same clock divider and wrap value. Thus, the frequency of the PWM channel is 50 Hz after the configuration.</span>
          </p>
          <h4>Voltage-PWM Mapping</h4>
          <p id="isPasted" style="text-align: justify;">To get an accurate mapping, we first need to know the maximum and minimum counter-compare values for the servos. Using a serial input thread, we found that the maximum counter-compare value for the servo is 1250 (max_CCV) while the minimum value is 275 (min_CCV). Any value beyond this range will make the servo produce a clicking sound.</p>
          <p style="text-align: justify;">After knowing the range of the counter compare value and the range of the voltage across the flex sensor, we can get the mapping by using the formula:</p>
          <p style="text-align: justify;">(CCV - min_PWM) * (max_volt - min_volt) = (max_CCV - min_CCV) * (volt-min_volt)</p>
          <p style="text-align: justify;">The CCV is the counter-compare value we need for the PWM channel. We are changing the duty cycle of the PWM channel by altering the counter-compare value. Since the duty cycle controls the servo’s position, the servo’s position will also change.</p>
          <h4 style="text-align: justify;">PWM Interrupt Service Routine</h4>
          <p style="text-align: justify;">The PWM Interrupt Service Routine (ISR) is configured to be called when we reach the PWM wrap value on PWM channel 0. Since all three PWM channels have the same frequency, we can use a single ISR to control all three PWM channels simultaneously. Once we reach this value on PWM channel 0, we will check whether the new counter-compare value for each channel is different from the old value by 50. If it is more significant than 50, we will write the new counter compare value to the corresponding PWM channel. This additional checking guarantees that the new rotational position of the servo is different from the old position by about 10 degrees and eliminates the random shaking caused by minor variations in flex sensor curvature.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-9" id="sec-d871">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">
            <span style="line-height: 2.0;">Results</span>
          </h2>
          <p id="isPasted" style="text-align: justify;">The results of this project met our expectation. We successfully control our custom-made mechatronic hands with three flex sensors. And we can perform simple gestures on the mechatronic hands with the movement of our fingers. Because of linear mapping and threshold in our software, we can precisely control each finger’s degree of movement.&nbsp;</p>
          <p style="text-align: justify;">&nbsp; &nbsp; The only setback of this project is that we only have three ADC pins on the Pi Pico, and we have to use only three flex sensors. If we want to make improvements, we could use a microcontroller with five usable ADC pins so that each finger can control corresponding fingers on the mechatronic hand. The other improvement we might want is to make this control wireless so that we can control the mechatronic hand in different locations.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-10" id="sec-dc36">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">
            <span style="line-height: 2.0;">Conclusion</span>
          </h2>
          <p id="isPasted" style="text-align: justify;">Our design met our expectations and initial design goals, although some modifications were added to overcome the fewer ADC channels. Our initial design goal was to use Pi Pico with five servo motors to independently control the Animatronic Hand’s five fingers. At the end of the project, we could control the five fingers of the Animatronic Hand using three servo-flex sensor pairs because of the limitation of Pi Pico. Judging from the hardware’s design, we could make our cardboard hand using recycled materials instead of making new purchases.&nbsp;</p>
          <p style="text-align: justify;">&nbsp; &nbsp; We can use a multiplexer circuit to read from five flex sensors using only three ADC channels. By doing so, each of the five fingers of the Animatronic Hand can be controlled independently, and the accuracy of the gesture will be further improved. Another way to improve the project will be to use rubber bands to increase the restoring force of the cardboard hand. Without rubber bands, the restoring force of the cardboard is insufficient to restore the position of the fingers fully.</p>
          <h4 style="text-align: left;">Applicable Standards Conformity</h4>
          <p style="text-align: left;">No standards apply to our design.</p>
          <h4 style="text-align: left;">Intellectual Property Considerations</h4>
          <p style="text-align: left;">The design of the cardboard hand comes from Build the Animatronic Hand on Adafruit by John Park (Park, 2018). Some minor modifications are applied to the original design to reduce the number of servos required to control the fingers. Other parts of the design do not use any other sources of intellectual property.</p>
          <h4 style="text-align: left;">Ethical Considerations</h4>
          <p style="text-align: justify;">Throughout the project, from the design of the circuit to writing the software, we followed all the aspects listed within the IEEE Code of Ethics. All the testing results are authentic and are not taken from somewhere else. There are no forms of discrimination based on race, religion, gender, disability, age, national origin, sexual orientation, gender identity, or gender expression during the project. We ensure the product is safe and will not cause any harm to the user: a 5V DC power supply powers the system, and the electrical components will not directly contact the user. Doing so guarantees the user’s safety when interacting with the device.</p>
          <h4 id="isPasted">Potential Opportunities</h4>
          <p>The current design needs more improvement for a patent or publishing opportunity. For example, we can develop plans to fabricate the gloves in large quantities using more sophisticated industrial processes. A separate software that can be written to calibrate the system automatically before the first use is also an excellent idea to improve the project for further opportunities.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-11" id="sec-5185">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Appendix A: Permission</h2>
          <p id="isPasted">The group approves this report for inclusion on the course website.</p>
          <p>The group approves the video for inclusion on the course’s youtube channel.</p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-12" id="sec-8f02">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Appendix B: Source Code</h2>
          <p id="isPasted">/*</p>
          <p>* HARDWARE CONNECTIONS</p>
          <p>* &nbsp; - GPIO 22 ---&gt; PWM output 0</p>
          <p>* &nbsp; - GPIO 20 ---&gt; PWM output 1</p>
          <p>* &nbsp; - GPIO 18 ---&gt; PWM output 2</p>
          <p>* &nbsp; - GPIO 26 ---&gt; ADC 0</p>
          <p>* &nbsp; - GPIO 27 ---&gt; ADC 1</p>
          <p>* &nbsp; - GPIO 28 ---&gt; ADC 2</p>
          <p>*/</p>
          <p>&nbsp;</p>
          <p>// * ADC 0 Raw value: 0xd57, voltage: 2.751343 V, max: 3.145313 V.</p>
          <p>// * ADC 1 Raw value: 0xc11, voltage: 2.488696 V, max: 2.933423 V.</p>
          <p>// * ADC 2 Raw value: 0x776, voltage: 1.538818 V, max: 2.103589 V.</p>
          <p>&nbsp;</p>
          <p>// Software design:</p>
          <p>// 1. The Pi Pico will read from the ADC channel.</p>
          <p>// 2. Then we record the max and min value of the ADC reading for each flex sensor</p>
          <p>// &nbsp; &nbsp;using serial output.</p>
          <p>// 3. Since the duty cycle determines the rotational position of the servo motor,</p>
          <p>// &nbsp; &nbsp;we can control the servo motor using a linear mapping from ADC to duty cycle</p>
          <p>// &nbsp; &nbsp;by changing the compare value of the PWM channel.</p>
          <p>// 4. We also write the code so that the new PWM will only be sent when the</p>
          <p>// &nbsp; &nbsp;difference in rotational position is larger than 10 degrees.</p>
          <p>&nbsp;</p>
          <p>#include&nbsp;</p>
          <p>#include&nbsp;</p>
          <p>#include&nbsp;</p>
          <p>#include&nbsp;</p>
          <p>&nbsp;</p>
          <p>#include "hardware/adc.h"</p>
          <p>#include "hardware/irq.h"</p>
          <p>#include "hardware/pwm.h"</p>
          <p>#include "pico/multicore.h"</p>
          <p>#include "pico/stdlib.h"</p>
          <p>#include "pt_cornell_rp2040_v1.h"</p>
          <p>&nbsp;</p>
          <p>// PWM wrap value and clock divide value</p>
          <p>// For a CPU rate of 125 MHz, this gives</p>
          <p>// a PWM frequency of 50Hz.</p>
          <p>#define WRAPVAL 10000</p>
          <p>#define CLKDIV 250.0f</p>
          <p>&nbsp;</p>
          <p>#define SERVO_PIN_0 22</p>
          <p>#define SERVO_PIN_1 20</p>
          <p>#define SERVO_PIN_2 18</p>
          <p>#define SERVO_PIN_3 16</p>
          <p>#define LED 25</p>
          <p>&nbsp;</p>
          <p>// ADC Channel and pin</p>
          <p>#define ADC_CHAN_0 0</p>
          <p>#define ADC_PIN_0 26</p>
          <p>#define ADC_CHAN_1 1</p>
          <p>#define ADC_PIN_1 27</p>
          <p>#define ADC_CHAN_2 2</p>
          <p>#define ADC_PIN_2 28</p>
          <p>&nbsp;</p>
          <p>// Variable to hold PWM slice number</p>
          <p>uint slice_num_0, slice_num_1, slice_num_2;</p>
          <p>&nbsp;</p>
          <p>// PWM duty cycle</p>
          <p>volatile int control_0, control_1, control_2;</p>
          <p>volatile int old_control_0, old_control_1, old_control_2;</p>
          <p>&nbsp;</p>
          <p>// PWM interrupt service routine</p>
          <p>void on_pwm_wrap() {</p>
          <p>&nbsp; &nbsp;// Clear the interrupt flag that brought us here</p>
          <p>&nbsp; &nbsp;pwm_clear_irq(pwm_gpio_to_slice_num(SERVO_PIN_0));</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Update duty cycle by changing the</p>
          <p>&nbsp; &nbsp;if (abs(control_0 - old_control_0) &gt; 50) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;// If the difference is less than ~10 degrees, ignore it.</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;old_control_0 = control_0;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;pwm_set_chan_level(slice_num_0, PWM_CHAN_A, control_0);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;// Set the new counter compare value for PWM channel.</p>
          <p>&nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;if (abs(control_1 - old_control_1) &gt; 50) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;old_control_1 = control_1;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;pwm_set_chan_level(slice_num_1, PWM_CHAN_A, control_1);</p>
          <p>&nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;if (abs(control_2 - old_control_2) &gt; 50) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;old_control_2 = control_2;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;pwm_set_chan_level(slice_num_2, PWM_CHAN_A, control_2);</p>
          <p>&nbsp; &nbsp;}</p>
          <p>}</p>
          <p>&nbsp;</p>
          <p>// Set the new counter compare value to the PWM channel.</p>
          <p>void servo_go(int servo_num, int pwm) {</p>
          <p>&nbsp; &nbsp;if (pwm &lt; 275) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;pwm = 275;</p>
          <p>&nbsp; &nbsp;} else if (pwm &gt; 1250) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;pwm = 1250;</p>
          <p>&nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;if (servo_num == 0) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;control_0 = pwm;</p>
          <p>&nbsp; &nbsp;} else if (servo_num == 1) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;control_1 = pwm;</p>
          <p>&nbsp; &nbsp;} else if (servo_num == 2) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;control_2 = pwm;</p>
          <p>&nbsp; &nbsp;}</p>
          <p>}</p>
          <p>&nbsp;</p>
          <p>// User input thread. The user can use this thread to know about the max and</p>
          <p>// min valid counter compare value for each servo.</p>
          <p>static PT_THREAD(protothread_serial(struct pt *pt)) {</p>
          <p>&nbsp; &nbsp;PT_BEGIN(pt);</p>
          <p>&nbsp; &nbsp;static int test_in, servo_num;</p>
          <p>&nbsp; &nbsp;while (1) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sprintf(pt_serial_out_buffer, "input a duty cycle (275-1250): ");</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;serial_write;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;// spawn a thread to do the non-blocking serial read</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;serial_read;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;// convert input string to number</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sscanf(pt_serial_in_buffer, "%d %d", &amp;servo_num, &amp;test_in);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sprintf(pt_serial_out_buffer, "received: %d \r\n", servo_num, test_in);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;serial_write;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;if (test_in &gt; 1250) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;} else if (test_in &lt; 275) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;} else {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;servo_go(servo_num, test_in);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;PT_END(pt);</p>
          <p>}</p>
          <p>&nbsp;</p>
          <p>// The protothread used to read from each of the ADC channel.</p>
          <p>static PT_THREAD(protothread_adc(struct pt *pt)) {</p>
          <p>&nbsp; &nbsp;PT_BEGIN(pt);</p>
          <p>&nbsp; &nbsp;while (1) {</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;const float conversion_factor = 3.3f / (1 &lt;&lt; 12);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;// convert factor used to convert from raw reading to voltage.</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;adc_select_input(ADC_CHAN_0);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;uint16_t result_0 = adc_read();</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;printf("0 Raw value: 0x%03x, voltage: %f V\n", result_0, result_0 * conversion_factor);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;servo_go(0, 2475 * result_0 * conversion_factor - 6533); &nbsp;// send the new counter compare value.</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sleep_ms(100);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;adc_select_input(ADC_CHAN_1);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;uint16_t result_1 = adc_read();</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;printf("1 Raw value: 0x%03x, voltage: %f V\n", result_1, result_1 * conversion_factor);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;servo_go(1, 2196 * result_1 * conversion_factor - 5191);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sleep_ms(100);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;adc_select_input(ADC_CHAN_2);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;uint16_t result_2 = adc_read();</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;printf("2 Raw value: 0x%03x, voltage: %f V\n", result_2, result_2 * conversion_factor);</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;servo_go(2, 1726 * result_2 * conversion_factor - 2381);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp; &nbsp; &nbsp;sleep_ms(100);</p>
          <p>&nbsp; &nbsp;}</p>
          <p>&nbsp; &nbsp;PT_END(pt);</p>
          <p>}</p>
          <p>&nbsp;</p>
          <p>void core1_entry() {</p>
          <p>&nbsp; &nbsp;// core 1 only reads from the ADC.</p>
          <p>&nbsp; &nbsp;pt_add_thread(protothread_adc);</p>
          <p>&nbsp; &nbsp;pt_schedule_start;</p>
          <p>}</p>
          <p>&nbsp;</p>
          <p>int main() {</p>
          <p>&nbsp; &nbsp;// Initialize stdio</p>
          <p>&nbsp; &nbsp;stdio_init_all();</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Tell GPIO 18, 20, 22 that it is allocated to the PWM.</p>
          <p>&nbsp; &nbsp;gpio_set_function(SERVO_PIN_0, GPIO_FUNC_PWM);</p>
          <p>&nbsp; &nbsp;gpio_set_function(SERVO_PIN_1, GPIO_FUNC_PWM);</p>
          <p>&nbsp; &nbsp;gpio_set_function(SERVO_PIN_2, GPIO_FUNC_PWM);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;gpio_init(LED);</p>
          <p>&nbsp; &nbsp;gpio_set_dir(LED, GPIO_OUT);</p>
          <p>&nbsp; &nbsp;gpio_put(LED, 0);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Find out which PWM slice is connected to each GPIO.</p>
          <p>&nbsp; &nbsp;slice_num_0 = pwm_gpio_to_slice_num(SERVO_PIN_0);</p>
          <p>&nbsp; &nbsp;slice_num_1 = pwm_gpio_to_slice_num(SERVO_PIN_1);</p>
          <p>&nbsp; &nbsp;slice_num_2 = pwm_gpio_to_slice_num(SERVO_PIN_2);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Mask our slice's IRQ output into the PWM block's single interrupt line,</p>
          <p>&nbsp; &nbsp;// and register our interrupt handler.</p>
          <p>&nbsp; &nbsp;// Only need one handler since we can control all three PWM channel using</p>
          <p>&nbsp; &nbsp;// one interrupt.</p>
          <p>&nbsp; &nbsp;pwm_clear_irq(slice_num_0);</p>
          <p>&nbsp; &nbsp;pwm_set_irq_enabled(slice_num_0, true);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;irq_set_exclusive_handler(PWM_IRQ_WRAP, on_pwm_wrap);</p>
          <p>&nbsp; &nbsp;irq_set_enabled(PWM_IRQ_WRAP, true);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// This section configures the frequency of the PWM signals to 50Hz.</p>
          <p>&nbsp; &nbsp;pwm_set_wrap(slice_num_0, WRAPVAL);</p>
          <p>&nbsp; &nbsp;pwm_set_clkdiv(slice_num_0, CLKDIV);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;pwm_set_wrap(slice_num_1, WRAPVAL);</p>
          <p>&nbsp; &nbsp;pwm_set_clkdiv(slice_num_1, CLKDIV);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;pwm_set_wrap(slice_num_2, WRAPVAL);</p>
          <p>&nbsp; &nbsp;pwm_set_clkdiv(slice_num_2, CLKDIV);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// This sets duty cycle, initialize to 500</p>
          <p>&nbsp; &nbsp;pwm_set_chan_level(slice_num_0, PWM_CHAN_A, 500);</p>
          <p>&nbsp; &nbsp;pwm_set_chan_level(slice_num_1, PWM_CHAN_A, 500);</p>
          <p>&nbsp; &nbsp;pwm_set_chan_level(slice_num_2, PWM_CHAN_A, 500);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Start the channel</p>
          <p>&nbsp; &nbsp;pwm_set_mask_enabled((1u &lt;&lt; slice_num_0) | (1u &lt;&lt; slice_num_1) | (1u &lt;&lt; slice_num_2));</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// ADC</p>
          <p>&nbsp; &nbsp;// Init GPIO for analogue use: hi-Z, no pulls, disable digital input buffer.</p>
          <p>&nbsp; &nbsp;adc_gpio_init(ADC_PIN_0);</p>
          <p>&nbsp; &nbsp;adc_gpio_init(ADC_PIN_1);</p>
          <p>&nbsp; &nbsp;adc_gpio_init(ADC_PIN_2);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Initialize the ADC harware, blocking.</p>
          <p>&nbsp; &nbsp;adc_init();</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// Select analog mux input.</p>
          <p>&nbsp; &nbsp;adc_select_input(ADC_CHAN_0);</p>
          <p>&nbsp;</p>
          <p>&nbsp; &nbsp;// start core 1</p>
          <p>&nbsp; &nbsp;multicore_reset_core1();</p>
          <p>&nbsp; &nbsp;multicore_launch_core1(core1_entry);</p>
          <p>&nbsp; &nbsp;pt_add_thread(protothread_serial);</p>
          <p>&nbsp; &nbsp;pt_schedule_start;</p>
          <p>}</p>
          <p>
            <br>
          </p>
          <h1 dir="ltr" style="line-height:1.7999999999999998;text-align: justify;margin-top:0pt;margin-bottom:0pt;">
            <br>
          </h1>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-section-13" id="sec-013b">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-align-center u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Appendix C: Circuit Diagram</h2>
          <p style="text-align: justify;">
            <span style="line-height: 2.0;">
              <img src="images/circuit.png" align="center" style="width: 547px;" class="fr-dib fr-fic" width="570">&nbsp;
            </span>
          </p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-14" id="sec-39d9">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 id="isPasted">Appendix D: Task Breakdown</h2>
          <p style="text-align: justify;">Zilin Wang is in charge of designing the hardware. Yilu Zhou is in charge of designing the software. Henry Tenecela is in charge of making the whole animatronic hand. All partners test and debug the system together.</p>
        </div>
      </div>
    </section>
    <section class="u-clearfix u-section-15" id="sec-1c21">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-align-center u-clearfix u-rich-text u-text u-text-1">
          <h2 style="text-align: left;">Appendix E: Cost Breakdown</h2>
          <p style="text-align: center;">
            <span style="line-height: 2.0;">
              <img src="images/Table.png" align="center" style="width: 736px;" class="fr-dib fr-fic" width="570">&nbsp;
            </span>
          </p>
        </div>
      </div>
    </section>
    <section class="u-align-left u-clearfix u-section-16" id="sec-17ca">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <div class="fr-view u-clearfix u-rich-text u-text u-text-1">
          <h2 id="isPasted">Appendix F: References</h2>
          <p style="text-align: left;">Haidar, M., Hwang, J., &amp; Vadivel, S. (n.d.). EMG Robotic Hand. EMG Robotic Hand. Retrieved December 9, 2022, from <a class="u-active-none u-border-none u-btn u-button-style u-hover-none u-none u-text-palette-1-base u-btn-1" href="https://nicepage.com">https://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/f2016/mh2298_jyh37_sv376/mh2298_jyh37_sv376/mh2298_jyh37_sv376/index.html</a>
          </p>
          <p style="text-align: left;">MacLennan, C., Scarpa, C., &amp; Saraswat, P. (n.d.). Tendon Flex Controlled Robot Hand. Tendon Flex Controlled Robot Hand. Retrieved December 9, 2022, from <a class="u-active-none u-border-none u-btn u-button-style u-hover-none u-none u-text-palette-1-base u-btn-2" href="https://nicepage.com">https://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/f2019/cam476_cls354_ps978/cam476_cls354_ps978/cam476_cls354_ps978/cam476_cls354_ps978.html</a>
          </p>
          <p style="text-align: left;">Park, J. (2018, May 23). Build the Animatronic Hand | Animatronic Hand. Adafruit Learning System. Retrieved December 9, 2022, from <a class="u-active-none u-border-none u-btn u-button-style u-hover-none u-none u-text-palette-1-base u-btn-3" href="https://nicepage.com">https://learn.adafruit.com/animatronic-hands/build-the-animatronic-hand</a>
          </p>
          <p style="text-align: left;">SparkFun Electronics. (n.d.). Flex Sensor 2.2" - SEN-10264. SparkFun Electronics. Retrieved December 9, 2022, from <a class="u-active-none u-border-none u-btn u-button-style u-hover-none u-none u-text-palette-1-base u-btn-4" href="https://nicepage.com">https://www.sparkfun.com/products/10264</a>
          </p>
        </div>
      </div>
    </section>
    
    
    
    <section class="u-backlink u-clearfix u-grey-80">
      <a class="u-link" href="https://nicepage.com/html5-template" target="_blank">
        <span>HTML5 Templates</span>
      </a>
      <p class="u-text">
        <span>created with</span>
      </p>
      <a class="u-link" href="https://nicepage.com/website-builder" target="_blank">
        <span>Free Website Builder</span>
      </a>. 
    </section>
  
</body></html>