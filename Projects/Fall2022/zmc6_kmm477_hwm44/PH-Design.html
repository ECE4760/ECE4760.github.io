<!DOCTYPE html>
<html style="font-size: 16px;">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Program &amp; Hardware Design, Summary:&nbsp;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean lectus felis, dictum ultrices arcu et, rhoncus tempus lorem. Praesent id molestie orci, et varius mauris. Pellentesque eu arcu vulputate, condimentum urna eu, interdum nulla. Cras eget odio venenatis arcu mattis porta eu sed ligula., Summary:&nbsp;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean lectus felis, dictum ultrices arcu et, rhoncus tempus lorem. Praesent id molestie orci, et varius mauris. Pellentesque eu arcu vulputate, condimentum urna eu, interdum nulla. Cras eget odio venenatis arcu mattis porta eu sed ligula., Summary:&nbsp;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean lectus felis, dictum ultrices arcu et, rhoncus tempus lorem. Praesent id molestie orci, et varius mauris. Pellentesque eu arcu vulputate, condimentum urna eu, interdum nulla. Cras eget odio venenatis arcu mattis porta eu sed ligula.">
    <meta name="description" content="">
    <meta name="page_type" content="np-template-header-footer-from-plugin">
    <title>PH Design</title>
    <link rel="stylesheet" href="nicepage.css" media="screen">
<link rel="stylesheet" href="PH-Design.css" media="screen">
    <script class="u-script" type="text/javascript" src="jquery.js" defer=""></script>
    <script class="u-script" type="text/javascript" src="nicepage.js" defer=""></script>
    <meta name="generator" content="Nicepage 3.24.1, nicepage.com">
    <link id="u-theme-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i|Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i">
    <link id="u-page-google-font" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:100,100i,300,300i,400,400i,700,700i,900,900i|Titillium+Web:200,200i,300,300i,400,400i,600,600i,700,700i,900">
    
    
    
    
    <script type="application/ld+json">{
		"@context": "http://schema.org",
		"@type": "Organization",
		"name": ""
}</script>
    <meta name="theme-color" content="#478ac9">
    <meta property="og:title" content="PH Design">
    <meta property="og:type" content="website">
  </head>
  <body class="u-body"><header class="u-clearfix u-header u-white u-header" id="sec-d3f3"><style class="u-sticky-style" data-style-id="4c27">.u-sticky-fixed.u-sticky-4c27, .u-body.u-sticky-fixed .u-sticky-4c27 {
box-shadow: 2px 2px 8px 0 rgba(128,128,128,1) !important
}.u-sticky-fixed.u-sticky-4c27:before, .u-body.u-sticky-fixed .u-sticky-4c27:before {
borders: top right bottom left !important
}</style><div class="u-clearfix u-sheet u-sheet-1">
        <nav class="u-menu u-menu-dropdown u-offcanvas u-menu-1">
          <div class="menu-collapse u-custom-font u-font-titillium-web" style="font-size: 1.125rem; letter-spacing: 0px;">
            <a class="u-button-style u-custom-active-border-color u-custom-active-color u-custom-border u-custom-border-color u-custom-borders u-custom-hover-border-color u-custom-hover-color u-custom-left-right-menu-spacing u-custom-padding-bottom u-custom-text-active-color u-custom-text-color u-custom-text-hover-color u-custom-top-bottom-menu-spacing u-nav-link u-text-active-palette-1-base u-text-hover-palette-2-base" href="#">
              <svg><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#menu-hamburger"></use></svg>
              <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><symbol id="menu-hamburger" viewBox="0 0 16 16" style="width: 16px; height: 16px;"><rect y="1" width="16" height="2"></rect><rect y="7" width="16" height="2"></rect><rect y="13" width="16" height="2"></rect>
</symbol>
</defs></svg>
            </a>
          </div>
          <div class="u-custom-menu u-nav-container">
            <ul class="u-custom-font u-font-titillium-web u-nav u-spacing-2 u-unstyled u-nav-1"><li class="u-nav-item"><a class="u-active-grey-5 u-button-style u-hover-grey-10 u-nav-link u-text-active-grey-90 u-text-grey-90 u-text-hover-grey-90" href="Home.html" style="padding: 10px 20px;">Home</a>
</li><li class="u-nav-item"><a class="u-active-grey-5 u-button-style u-hover-grey-10 u-nav-link u-text-active-grey-90 u-text-grey-90 u-text-hover-grey-90" href="High-Level-Design.html" style="padding: 10px 20px;">High Level Design</a>
</li><li class="u-nav-item"><a class="u-active-grey-5 u-button-style u-hover-grey-10 u-nav-link u-text-active-grey-90 u-text-grey-90 u-text-hover-grey-90" href="PH-Design.html" style="padding: 10px 20px;">Program &amp; Hardware Design</a>
</li><li class="u-nav-item"><a class="u-active-grey-5 u-button-style u-hover-grey-10 u-nav-link u-text-active-grey-90 u-text-grey-90 u-text-hover-grey-90" href="Results-and-Conclusion.html" style="padding: 10px 20px;">Results &amp; Conclusion</a>
</li><li class="u-nav-item"><a class="u-active-grey-5 u-button-style u-hover-grey-10 u-nav-link u-text-active-grey-90 u-text-grey-90 u-text-hover-grey-90" href="Appendix.html" style="padding: 10px 20px;">Appendix</a>
</li></ul>
          </div>
          <div class="u-custom-menu u-nav-container-collapse">
            <div class="u-black u-container-style u-inner-container-layout u-opacity u-opacity-95 u-sidenav">
              <div class="u-sidenav-overflow">
                <div class="u-menu-close"></div>
                <ul class="u-align-center u-nav u-popupmenu-items u-unstyled u-nav-2"><li class="u-nav-item"><a class="u-button-style u-nav-link" href="Home.html" style="padding: 10px 20px;">Home</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="High-Level-Design.html" style="padding: 10px 20px;">High Level Design</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="PH-Design.html" style="padding: 10px 20px;">Program &amp; Hardware Design</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="Results-and-Conclusion.html" style="padding: 10px 20px;">Results &amp; Conclusion</a>
</li><li class="u-nav-item"><a class="u-button-style u-nav-link" href="Appendix.html" style="padding: 10px 20px;">Appendix</a>
</li></ul>
              </div>
            </div>
            <div class="u-black u-menu-overlay u-opacity u-opacity-70"></div>
          </div>
        </nav>
        <img class="u-image u-image-default u-image-1" src="images/download1.png" alt="" data-image-width="396" data-image-height="127">
        <img class="u-image u-image-default u-image-2" src="images/ScreenShot2022-12-01at1.27.43PM.png" alt="" data-image-width="742" data-image-height="752">
      </div></header>
    <section class="u-clearfix u-image u-section-1" id="sec-b8aa" data-image-width="1280" data-image-height="720">
      <div class="u-clearfix u-sheet u-valign-middle u-sheet-1">
        <h1 class="u-align-center u-custom-font u-font-lato u-text u-text-body-alt-color u-text-1"><i>Program &amp; Hardware Design</i>
        </h1>
      </div>
    </section>
    <section class="u-clearfix u-section-2" id="sec-2f01">
      <div class="u-align-left u-clearfix u-sheet u-sheet-1">
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-1"><i><b>Hardware Design</b></i>
        </h1>
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-2"> In terms of hardware external to RP2040, we connected each of the 8 GPIO pins that will be configured as PWM channels to opto-isolators, the output of which are each connected to a servo. This isolated the microcontrollers supply and ground lines from those for the servos which draw comparatively higher current. Additionally, this allowed us to power the servos according to its own ratings (4-6V), which is greater than the microcontroller’s capability (3.3V). The design of the opto-isolator circuit was derived from the motor H-bridge circuit used in Lab 3. For hardware peripherals onboard the RP2040, we will be using the PWM module, the Timer module, and one of the UART modules. These hardware modules are configured in the setup of our program. We will only be using a single core (core0) for this project.<br>
        </h1>
        <img class="u-image u-image-default u-image-1" src="images/ScreenShot2022-12-09at2.12.41PM1.png" alt="" data-image-width="2304" data-image-height="1508">
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-3">Figure 4. Microcontroller and opto-isolator circuit connections</h1>
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-4"><i>Program Design</i>
        </h1>
        <p class="u-align-center u-custom-font u-font-titillium-web u-text u-text-5"> Our program starts by initializing all the hardware modules. First, we call stdio_init_all() to activate the UART module on GPIOs 1 and 2. Before any of the PWM channels are initialized, we set all of the PWM duty cycles to a value that will set the servo mallets to an upright position, since the duty cycle of a servo’s PWM input signal is what controls its position. This prevents them from moving into an invalid position if the PWM channel would be initialized immediately. Now we initialize all 8 PWM channels by following the procedure for each one:</p>
        <p class="u-align-left u-custom-font u-font-titillium-web u-text u-text-6"> 1. Use gpio_set_function to set the pin to GPIO_FUNC_PWM<br>
          <br>2. Calculate the slice number by calling pwm_gpio_to_slice_num and saving to an array<br>
          <br>3. Clear and enable IRQs by calling pwm_clear_irq and pwm_set_irq_enabled, passing the calculated slice number as argument<br>
          <br>4. Configure clock divider and wrap values by calling pwm_set_wrap and pwm_set_clkdiv, passing the appropriate values (macros) to set the period of the PWM signal<br>
          <br>5. Configure duty cycle by calling pwm_set_chan_level, passing the slice number and channel macro (channel A or channel B) as appropriate
        </p>
        <p class="u-align-center u-custom-font u-font-titillium-web u-text u-text-7"> To set up the ISR, we call irq_set_exclusive_handler and pass PWM_IRQ_WRAP and the function on_pwm_wrap as arguments. This is enabled by calling irq_set_enabled. All the PWM channels are then enabled by calling pwm_set_mask_enabled with a mask with the bits corresponding to the used pins. This ISR is used by the PWM to check if the duty cycle value has changed and updates the output channel accordingly.&nbsp;<br>
          <br>A repeating_timer struct is created and initialized with a call to add_repeating_timer_us with the arguments -1000 (denotes a 1ms timer that requests interrupt immediately), repeating_timer_callback (set up the ISR function), and &amp;timer (tie it back to the struct). This timer is used to handle the timing between beats and determine when a servo mallet should strike the key based on the song’s data.&nbsp;<br>
          <br>Our program consists of two protothreads, one thread for handling serial input via a UART interface and one thread for handling the state machine associated with each servo. Protothreads is a non-preemptive threading library written by Adam Dunkels and ported to the RP2040 by Bruce Land. The threads contained within the functions protothread_serial and protothread_play are added to the scheduler by passing them as arguments to the function pt_add_thread and the scheduler is started by calling the macro pt_schedule_start.<br>
          <br>To support our program, we have a handful of global variables. An array slice_num is initialized as described previously and stores the PWM slice number associated with each servo, an array XYLO_STATE that stores the state (either WAIT, STRIKE_DOWN, or STRIKE_UP enums) for each servo, a const array that stores the channel macro information (PWM_CHAN_A and PWM_CHAN_B alternating), two more const arrays UP and DOWN that store the PWM values that we have calibrated for the servo resting and servo hitting positions, and two last volatile arrays control and old_control for storing the current and past PWM duty cycle values. The other global variables we have are two volatile uints that store the current counter and beat values for song timing, and a volatile pointer (type song_t*) that stores the current song.<br>
          <br>The header file music.h provides most of the definitions solely related to our song storage system. There are macro definitions for common values such as MAX_LEN (maximum beat length of any song), NUM_SERVOS, and NUM_SONGS. Here we also define our custom struct type song_t that contains the beat_period and end_beat values, and a two-dimensional notes array that is of size NUM_SERVOS by MAX_LEN (currently 8 by 160). The last thing the header does it provide some externs so that we can provide our main program xylophone.c with variable names but include the definitions in music.c. These include extern song_t types for each of our songs and an extern song_t* called song_list so we have an array of pointers to each song (having the pointers in an array makes it much easier to store and load song data). The organization of the song data is discussed later, but music.c includes an element definition of song_list ({a, b, c} format) and in-place struct definitions of songs ({.a=1, .b=2, .c=3} format).&nbsp;<br>
          <br>When the timer ISR repeating_timer_callback is called, it starts by increasing the counter variable. This counts how many milliseconds have passed. If curr_song is a valid pointer (not NULL, therefore a song is loaded/playing) and the counter’s value is greater than the current song’s beat_period, we want to play the next note. So on this condition, we reset the counter to zero and do one final check to make sure that the loaded song has a valid beat period (non-zero). If that checks out, we loop through all 8 state machines and transition each one to the STRIKE_DOWN state only if the corresponding beat is set true in the corresponding note array. We then increase the beat counter and the process repeats again once the counter reaches the beat period again. If the beat counter is greater than the number of beats in the song, we know the song has finished playing and so we reset the beat counter and set the current song pointer to NULL to signify this.&nbsp;<br>
          <br>The PWM ISR on_pwm_wrap serves to update the PWM duty cycle for each servo asynchronously from the state machine triggers. The function first loops through all channels and checks if the duty cycle for that channel (stored in control) has been updated (by comparing it to old_control). If so, it saves the value (into old_control) and sets the duty cycle by calling pwm_set_chan_level and providing the slice number, channel macro, and duty cycle as arguments. After all possible changes have been made, all of the IRQs are cleared by calling pwm_clear_irq on the slice number (this will clear each of the four slices twice, but has no negative effect).<br>
          <br>
          <br>Our serial protothread is very similar to that of previous labs. It starts by printing out all the available options (in our case, what songs are available) to the pt_serial_out_buffer and calls the protothread macro serial_write to provide non-blocking printing. A while(1) loop then calls the non-blocking read macro serial_read to wait for serial input, then calls sscanf with the format character %d to read integers. Once a valid number is provided, the current song pointer is set to the appropriate song pointer in the song_list array.<br>
          <br>
          <br>Our music playing protothread provides the rest of the state machine transitions and functionality besides the initial transition provided by the timer ISR. It loops through all the servos and performs the following checks before yielding to the serial thread:<br>
        </p>
        <p class="u-align-left u-custom-font u-font-titillium-web u-text u-text-8"> 1. If in the STRIKE_DOWN state, set the PWM value to the corresponding value in DOWN to strike the note and transition to the STRIKE_UP state.<br>
          <br>
          <br>2. If in the STRIKE_UP state and the counter is greater than 70 (number of milliseconds elapsed since the beat began), set the PWM value to the corresponding value in UP to release the note and transition to the WAIT state.
        </p>
      </div>
    </section>
    <section class="u-clearfix u-section-3" id="sec-e7dc">
      <div class="u-clearfix u-sheet u-sheet-1">
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-1">
          <br>
          <br>The note data used in the timer ISR for determining if a servo mallet should strike the key was generated from arrays of 0s and 1s for each servo. This data was included in a separate C file for organizational purposes. We first created Excel spreadsheets where we entered 1s into eight columns corresponding to each note for when we wanted that note to be played. We decided on this structure because it was easier to visually read and add 1s to the spreadsheet than it would be to write the arrays from scratch. These spreadsheets were then processed by a Python script that would format the note arrays of 1s and 0s in the same order as the spreadsheet but in proper C syntax.&nbsp;<br>
          <br>
          <br>The script automatically inserted the 0s wherever there was not a 1 in the spreadsheet, which made the music creation process more efficient. Once all the data in the spreadsheet was processed, the script would print out a song_t struct with the name of the song, a default beat period of 250, the nested note arrays, and calculated end beat in proper C syntax so that we could easily copy and paste it into the music.c file. The only necessary change for this data is to update the beat period to set the desired tempo after testing the song.&nbsp;<br>
        </h1>
        <img class="u-image u-image-default u-image-1" src="images/ScreenShot2022-12-09at3.19.37PM.png" alt="" data-image-width="1394" data-image-height="1018">
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-2">Figure 5. Example Excel spreadsheet for scales</h1>
        <img class="u-image u-image-default u-image-2" src="images/ScreenShot2022-12-09at3.20.02PM.png" alt="" data-image-width="1600" data-image-height="728">
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-3">Figure 6. Example song_t struct for scales</h1>
        <h1 class="u-align-center u-custom-font u-font-titillium-web u-text u-text-4"> The song list was chosen to test different capabilities of the system. We began with a simple scale that played each of the notes from lowest to highest pitch sequentially to verify that each of the servos can be played independently. To test playing multiple notes at once, we wrote a simple chord progression that played 3-4 notes at once and verified that all the notes in a chord were synchronized. We also wrote songs to stress test the timing capabilities of the servos. Our “Baby Shark” song was created for testing the repetition of a single note quickly to see if the servo had enough time to strike down, return upright, then strike again on the subsequent beat and our “A Thousand Miles” song was written to instead test how quickly we can switch between different notes.&nbsp;<br>
          <br>Since the xylophone only contained a single octave of white keys on piano (C to C), we were restricted to creating songs whose range could fit onto the xylophone. This meant that some of the songs needed to be transposed to a different key or have some notes in the song slightly modified to use one of the available keys. (For example, the final “happy birthday” is played on a pitch slightly lower than the actual melody of the song.) If we were not able to make these modifications, then we did not program that song.&nbsp;<br>
        </h1>
      </div>
    </section>
  </body>
</html>
